var THREE = {
    REVISION: "68"
};
"object" == typeof module && (module.exports = THREE), THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = function() {}, THREE.CubeReflectionMapping = function() {}, THREE.CubeRefractionMapping = function() {}, THREE.SphericalReflectionMapping = function() {}, THREE.SphericalRefractionMapping = function() {}, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.Color = function(t) {
        return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(t)
    }, THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t instanceof THREE.Color ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, r) {
            return this.r = t, this.g = e, this.b = r, this
        },
        setHSL: function(t, e, r) {
            if (0 === e) this.r = this.g = this.b = r;
            else {
                var n = function(t, e, r) {
                        return 0 > r && (r += 1), r > 1 && (r -= 1), 1 / 6 > r ? t + 6 * (e - t) * r : .5 > r ? e : 2 / 3 > r ? t + 6 * (e - t) * (2 / 3 - r) : t
                    },
                    i = .5 >= r ? r * (1 + e) : r + e - r * e,
                    o = 2 * r - i;
                this.r = n(o, i, t + 1 / 3), this.g = n(o, i, t), this.b = n(o, i, t - 1 / 3)
            }
            return this
        },
        setStyle: function(t) {
            if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(t)) {
                var e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(t);
                return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this
            }
            if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(t)) {
                var e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(t);
                return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this
            }
            if (/^\#([0-9a-f]{6})$/i.test(t)) {
                var e = /^\#([0-9a-f]{6})$/i.exec(t);
                return this.setHex(parseInt(e[1], 16)), this
            }
            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(t)) {
                var e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(t);
                return this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this
            }
            return /^(\w+)$/i.test(t) ? (this.setHex(THREE.ColorKeywords[t]), this) : void 0
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t) {
            return this.r = t.r * t.r, this.g = t.g * t.g, this.b = t.b * t.b, this
        },
        copyLinearToGamma: function(t) {
            return this.r = Math.sqrt(t.r), this.g = Math.sqrt(t.g), this.b = Math.sqrt(t.b), this
        },
        convertGammaToLinear: function() {
            var t = this.r,
                e = this.g,
                r = this.b;
            return this.r = t * t, this.g = e * e, this.b = r * r, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            var e, r, n = t || {
                    h: 0,
                    s: 0,
                    l: 0
                },
                i = this.r,
                o = this.g,
                a = this.b,
                s = Math.max(i, o, a),
                h = Math.min(i, o, a),
                u = (h + s) / 2;
            if (h === s) e = 0, r = 0;
            else {
                var l = s - h;
                switch (r = .5 >= u ? l / (s + h) : l / (2 - s - h), s) {
                    case i:
                        e = (o - a) / l + (a > o ? 6 : 0);
                        break;
                    case o:
                        e = (a - i) / l + 2;
                        break;
                    case a:
                        e = (i - o) / l + 4
                }
                e /= 6
            }
            return n.h = e, n.s = r, n.l = u, n
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, r) {
            var n = this.getHSL();
            return n.h += t, n.s += e, n.l += r, this.setHSL(n.h, n.s, n.l), this
        },
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t) {
            return this.r = t[0], this.g = t[1], this.b = t[2], this
        },
        toArray: function() {
            return [this.r, this.g, this.b]
        },
        clone: function() {
            return (new THREE.Color).setRGB(this.r, this.g, this.b)
        }
    }, THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, THREE.Quaternion = function(t, e, r, n) {
        this._x = t || 0, this._y = e || 0, this._z = r || 0, this._w = void 0 !== n ? n : 1
    }, THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        _x: 0,
        _y: 0,
        _z: 0,
        _w: 0,
        get x() {
            return this._x
        },
        set x(t) {
            this._x = t, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(t) {
            this._y = t, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(t) {
            this._z = t, this.onChangeCallback()
        },
        get w() {
            return this._w
        },
        set w(t) {
            this._w = t, this.onChangeCallback()
        },
        set: function(t, e, r, n) {
            return this._x = t, this._y = e, this._z = r, this._w = n, this.onChangeCallback(), this
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (t instanceof THREE.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var r = Math.cos(t._x / 2),
                n = Math.cos(t._y / 2),
                i = Math.cos(t._z / 2),
                o = Math.sin(t._x / 2),
                a = Math.sin(t._y / 2),
                s = Math.sin(t._z / 2);
            return "XYZ" === t.order ? (this._x = o * n * i + r * a * s, this._y = r * a * i - o * n * s, this._z = r * n * s + o * a * i, this._w = r * n * i - o * a * s) : "YXZ" === t.order ? (this._x = o * n * i + r * a * s, this._y = r * a * i - o * n * s, this._z = r * n * s - o * a * i, this._w = r * n * i + o * a * s) : "ZXY" === t.order ? (this._x = o * n * i - r * a * s, this._y = r * a * i + o * n * s, this._z = r * n * s + o * a * i, this._w = r * n * i - o * a * s) : "ZYX" === t.order ? (this._x = o * n * i - r * a * s, this._y = r * a * i + o * n * s, this._z = r * n * s - o * a * i, this._w = r * n * i + o * a * s) : "YZX" === t.order ? (this._x = o * n * i + r * a * s, this._y = r * a * i + o * n * s, this._z = r * n * s - o * a * i, this._w = r * n * i - o * a * s) : "XZY" === t.order && (this._x = o * n * i - r * a * s, this._y = r * a * i - o * n * s, this._z = r * n * s + o * a * i, this._w = r * n * i + o * a * s), e !== !1 && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            var r = e / 2,
                n = Math.sin(r);
            return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(r), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            var e, r = t.elements,
                n = r[0],
                i = r[4],
                o = r[8],
                a = r[1],
                s = r[5],
                h = r[9],
                u = r[2],
                l = r[6],
                c = r[10],
                p = n + s + c;
            return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (l - h) * e, this._y = (o - u) * e, this._z = (a - i) * e) : n > s && n > c ? (e = 2 * Math.sqrt(1 + n - s - c), this._w = (l - h) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (o + u) / e) : s > c ? (e = 2 * Math.sqrt(1 + s - n - c), this._w = (o - u) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (h + l) / e) : (e = 2 * Math.sqrt(1 + c - n - s), this._w = (a - i) / e, this._x = (o + u) / e, this._y = (h + l) / e, this._z = .25 * e), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var t, e, r = 1e-6;
            return function(n, i) {
                return void 0 === t && (t = new THREE.Vector3), e = n.dot(i) + 1, r > e ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, i), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize(), this
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize(), this
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        multiplyQuaternions: function(t, e) {
            var r = t._x,
                n = t._y,
                i = t._z,
                o = t._w,
                a = e._x,
                s = e._y,
                h = e._z,
                u = e._w;
            return this._x = r * u + o * a + n * h - i * s, this._y = n * u + o * s + i * a - r * h, this._z = i * u + o * h + r * s - n * a, this._w = o * u - r * a - n * s - i * h, this.onChangeCallback(), this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        },
        slerp: function(t, e) {
            var r = this._x,
                n = this._y,
                i = this._z,
                o = this._w,
                a = o * t._w + r * t._x + n * t._y + i * t._z;
            if (0 > a ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = r, this._y = n, this._z = i, this;
            var s = Math.acos(a),
                h = Math.sqrt(1 - a * a);
            if (Math.abs(h) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (r + this._x), this._y = .5 * (n + this._y), this._z = .5 * (i + this._z), this;
            var u = Math.sin((1 - e) * s) / h,
                l = Math.sin(e * s) / h;
            return this._w = o * u + this._w * l, this._x = r * u + this._x * l, this._y = n * u + this._y * l, this._z = i * u + this._z * l, this.onChangeCallback(), this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], this._w = t[3], this.onChangeCallback(), this
        },
        toArray: function() {
            return [this._x, this._y, this._z, this._w]
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {},
        clone: function() {
            return new THREE.Quaternion(this._x, this._y, this._z, this._w)
        }
    }, THREE.Quaternion.slerp = function(t, e, r, n) {
        return r.copy(t).slerp(e, n)
    }, THREE.Vector2 = function(t, e) {
        this.x = t || 0, this.y = e || 0
    }, THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            if (0 !== t) {
                var e = 1 / t;
                this.x *= e, this.y *= e
            } else this.x = 0, this.y = 0;
            return this
        },
        min: function(t) {
            return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this
        },
        max: function(t) {
            return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this
        },
        clamp: function(t, e) {
            return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this
        },
        clampScalar: function() {
            var t, e;
            return function(r, n) {
                return void 0 === t && (t = new THREE.Vector2, e = new THREE.Vector2), t.set(r, r), e.set(n, n), this.clamp(t, e)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                r = this.y - t.y;
            return e * e + r * r
        },
        setLength: function(t) {
            var e = this.length();
            return 0 !== e && t !== e && this.multiplyScalar(t / e), this
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t) {
            return this.x = t[0], this.y = t[1], this
        },
        toArray: function() {
            return [this.x, this.y]
        },
        clone: function() {
            return new THREE.Vector2(this.x, this.y)
        }
    }, THREE.Vector3 = function(t, e, r) {
        this.x = t || 0, this.y = e || 0, this.z = r || 0
    }, THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function(t, e, r) {
            return this.x = t, this.y = e, this.z = r, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function() {
            var t;
            return function(e) {
                return e instanceof THREE.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromEuler(e)), this
            }
        }(),
        applyAxisAngle: function() {
            var t;
            return function(e, r) {
                return void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromAxisAngle(e, r)), this
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = t.elements;
            return this.x = i[0] * e + i[3] * r + i[6] * n, this.y = i[1] * e + i[4] * r + i[7] * n, this.z = i[2] * e + i[5] * r + i[8] * n, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = t.elements;
            return this.x = i[0] * e + i[4] * r + i[8] * n + i[12], this.y = i[1] * e + i[5] * r + i[9] * n + i[13], this.z = i[2] * e + i[6] * r + i[10] * n + i[14], this
        },
        applyProjection: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = t.elements,
                o = 1 / (i[3] * e + i[7] * r + i[11] * n + i[15]);
            return this.x = (i[0] * e + i[4] * r + i[8] * n + i[12]) * o, this.y = (i[1] * e + i[5] * r + i[9] * n + i[13]) * o, this.z = (i[2] * e + i[6] * r + i[10] * n + i[14]) * o, this
        },
        applyQuaternion: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = t.x,
                o = t.y,
                a = t.z,
                s = t.w,
                h = s * e + o * n - a * r,
                u = s * r + a * e - i * n,
                l = s * n + i * r - o * e,
                c = -i * e - o * r - a * n;
            return this.x = h * s + c * -i + u * -a - l * -o, this.y = u * s + c * -o + l * -i - h * -a, this.z = l * s + c * -a + h * -o - u * -i, this
        },
        transformDirection: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = t.elements;
            return this.x = i[0] * e + i[4] * r + i[8] * n, this.y = i[1] * e + i[5] * r + i[9] * n, this.z = i[2] * e + i[6] * r + i[10] * n, this.normalize(), this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            if (0 !== t) {
                var e = 1 / t;
                this.x *= e, this.y *= e, this.z *= e
            } else this.x = 0, this.y = 0, this.z = 0;
            return this
        },
        min: function(t) {
            return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this
        },
        max: function(t) {
            return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this
        },
        clamp: function(t, e) {
            return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this
        },
        clampScalar: function() {
            var t, e;
            return function(r, n) {
                return void 0 === t && (t = new THREE.Vector3, e = new THREE.Vector3), t.set(r, r, r), e.set(n, n, n), this.clamp(t, e)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(t) {
            var e = this.length();
            return 0 !== e && t !== e && this.multiplyScalar(t / e), this
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        cross: function(t, e) {
            if (void 0 !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e);
            var r = this.x,
                n = this.y,
                i = this.z;
            return this.x = n * t.z - i * t.y, this.y = i * t.x - r * t.z, this.z = r * t.y - n * t.x, this
        },
        crossVectors: function(t, e) {
            var r = t.x,
                n = t.y,
                i = t.z,
                o = e.x,
                a = e.y,
                s = e.z;
            return this.x = n * s - i * a, this.y = i * o - r * s, this.z = r * a - n * o, this
        },
        projectOnVector: function() {
            var t, e;
            return function(r) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(r).normalize(), e = this.dot(t), this.copy(t).multiplyScalar(e)
            }
        }(),
        projectOnPlane: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Vector3), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            var e = this.dot(t) / (this.length() * t.length());
            return Math.acos(THREE.Math.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                r = this.y - t.y,
                n = this.z - t.z;
            return e * e + r * r + n * n
        },
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        setFromMatrixPosition: function(t) {
            return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this
        },
        setFromMatrixScale: function(t) {
            var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length(),
                r = this.set(t.elements[4], t.elements[5], t.elements[6]).length(),
                n = this.set(t.elements[8], t.elements[9], t.elements[10]).length();
            return this.x = e, this.y = r, this.z = n, this
        },
        setFromMatrixColumn: function(t, e) {
            var r = 4 * t,
                n = e.elements;
            return this.x = n[r], this.y = n[r + 1], this.z = n[r + 2], this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t) {
            return this.x = t[0], this.y = t[1], this.z = t[2], this
        },
        toArray: function() {
            return [this.x, this.y, this.z]
        },
        clone: function() {
            return new THREE.Vector3(this.x, this.y, this.z)
        }
    }, THREE.Vector4 = function(t, e, r, n) {
        this.x = t || 0, this.y = e || 0, this.z = r || 0, this.w = void 0 !== n ? n : 1
    }, THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function(t, e, r, n) {
            return this.x = t, this.y = e, this.z = r, this.w = n, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                r = this.y,
                n = this.z,
                i = this.w,
                o = t.elements;
            return this.x = o[0] * e + o[4] * r + o[8] * n + o[12] * i, this.y = o[1] * e + o[5] * r + o[9] * n + o[13] * i, this.z = o[2] * e + o[6] * r + o[10] * n + o[14] * i, this.w = o[3] * e + o[7] * r + o[11] * n + o[15] * i, this
        },
        divideScalar: function(t) {
            if (0 !== t) {
                var e = 1 / t;
                this.x *= e, this.y *= e, this.z *= e, this.w *= e
            } else this.x = 0, this.y = 0, this.z = 0, this.w = 1;
            return this
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return 1e-4 > e ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, r, n, i, o = .01,
                a = .1,
                s = t.elements,
                h = s[0],
                u = s[4],
                l = s[8],
                c = s[1],
                p = s[5],
                f = s[9],
                d = s[2],
                m = s[6],
                g = s[10];
            if (Math.abs(u - c) < o && Math.abs(l - d) < o && Math.abs(f - m) < o) {
                if (Math.abs(u + c) < a && Math.abs(l + d) < a && Math.abs(f + m) < a && Math.abs(h + p + g - 3) < a) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var v = (h + 1) / 2,
                    E = (p + 1) / 2,
                    y = (g + 1) / 2,
                    T = (u + c) / 4,
                    x = (l + d) / 4,
                    _ = (f + m) / 4;
                return v > E && v > y ? o > v ? (r = 0, n = .707106781, i = .707106781) : (r = Math.sqrt(v), n = T / r, i = x / r) : E > y ? o > E ? (r = .707106781, n = 0, i = .707106781) : (n = Math.sqrt(E), r = T / n, i = _ / n) : o > y ? (r = .707106781, n = .707106781, i = 0) : (i = Math.sqrt(y), r = x / i, n = _ / i), this.set(r, n, i, e), this
            }
            var b = Math.sqrt((m - f) * (m - f) + (l - d) * (l - d) + (c - u) * (c - u));
            return Math.abs(b) < .001 && (b = 1), this.x = (m - f) / b, this.y = (l - d) / b, this.z = (c - u) / b, this.w = Math.acos((h + p + g - 1) / 2), this
        },
        min: function(t) {
            return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this.w > t.w && (this.w = t.w), this
        },
        max: function(t) {
            return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this.w < t.w && (this.w = t.w), this
        },
        clamp: function(t, e) {
            return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this.w < t.w ? this.w = t.w : this.w > e.w && (this.w = e.w), this
        },
        clampScalar: function() {
            var t, e;
            return function(r, n) {
                return void 0 === t && (t = new THREE.Vector4, e = new THREE.Vector4), t.set(r, r, r, r), e.set(n, n, n, n), this.clamp(t, e)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(t) {
            var e = this.length();
            return 0 !== e && t !== e && this.multiplyScalar(t / e), this
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t) {
            return this.x = t[0], this.y = t[1], this.z = t[2], this.w = t[3], this
        },
        toArray: function() {
            return [this.x, this.y, this.z, this.w]
        },
        clone: function() {
            return new THREE.Vector4(this.x, this.y, this.z, this.w)
        }
    }, THREE.Euler = function(t, e, r, n) {
        this._x = t || 0, this._y = e || 0, this._z = r || 0, this._order = n || THREE.Euler.DefaultOrder
    }, THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
        constructor: THREE.Euler,
        _x: 0,
        _y: 0,
        _z: 0,
        _order: THREE.Euler.DefaultOrder,
        get x() {
            return this._x
        },
        set x(t) {
            this._x = t, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(t) {
            this._y = t, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(t) {
            this._z = t, this.onChangeCallback()
        },
        get order() {
            return this._order
        },
        set order(t) {
            this._order = t, this.onChangeCallback()
        },
        set: function(t, e, r, n) {
            return this._x = t, this._y = e, this._z = r, this._order = n || this._order, this.onChangeCallback(), this
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e) {
            var r = THREE.Math.clamp,
                n = t.elements,
                i = n[0],
                o = n[4],
                a = n[8],
                s = n[1],
                h = n[5],
                u = n[9],
                l = n[2],
                c = n[6],
                p = n[10];
            return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(c, h), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(s, h)) : (this._y = Math.atan2(-l, i), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(-l, p), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(s, i))) : "ZYX" === e ? (this._y = Math.asin(-r(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(c, p), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-o, h))) : "YZX" === e ? (this._z = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-l, i)) : (this._x = 0, this._y = Math.atan2(a, p))) : "XZY" === e ? (this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(c, h), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, this.onChangeCallback(), this
        },
        setFromQuaternion: function(t, e, r) {
            var n = THREE.Math.clamp,
                i = t.x * t.x,
                o = t.y * t.y,
                a = t.z * t.z,
                s = t.w * t.w;
            return e = e || this._order, "XYZ" === e ? (this._x = Math.atan2(2 * (t.x * t.w - t.y * t.z), s - i - o + a), this._y = Math.asin(n(2 * (t.x * t.z + t.y * t.w), -1, 1)), this._z = Math.atan2(2 * (t.z * t.w - t.x * t.y), s + i - o - a)) : "YXZ" === e ? (this._x = Math.asin(n(2 * (t.x * t.w - t.y * t.z), -1, 1)), this._y = Math.atan2(2 * (t.x * t.z + t.y * t.w), s - i - o + a), this._z = Math.atan2(2 * (t.x * t.y + t.z * t.w), s - i + o - a)) : "ZXY" === e ? (this._x = Math.asin(n(2 * (t.x * t.w + t.y * t.z), -1, 1)), this._y = Math.atan2(2 * (t.y * t.w - t.z * t.x), s - i - o + a), this._z = Math.atan2(2 * (t.z * t.w - t.x * t.y), s - i + o - a)) : "ZYX" === e ? (this._x = Math.atan2(2 * (t.x * t.w + t.z * t.y), s - i - o + a), this._y = Math.asin(n(2 * (t.y * t.w - t.x * t.z), -1, 1)), this._z = Math.atan2(2 * (t.x * t.y + t.z * t.w), s + i - o - a)) : "YZX" === e ? (this._x = Math.atan2(2 * (t.x * t.w - t.z * t.y), s - i + o - a), this._y = Math.atan2(2 * (t.y * t.w - t.x * t.z), s + i - o - a), this._z = Math.asin(n(2 * (t.x * t.y + t.z * t.w), -1, 1))) : "XZY" === e ? (this._x = Math.atan2(2 * (t.x * t.w + t.y * t.z), s - i + o - a), this._y = Math.atan2(2 * (t.x * t.z + t.y * t.w), s + i - o - a), this._z = Math.asin(n(2 * (t.z * t.w - t.x * t.y), -1, 1))) : console.warn("THREE.Euler: .setFromQuaternion() given unsupported order: " + e), this._order = e, r !== !1 && this.onChangeCallback(), this
        },
        reorder: function() {
            var t = new THREE.Quaternion;
            return function(e) {
                t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        },
        toArray: function() {
            return [this._x, this._y, this._z, this._order]
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {},
        clone: function() {
            return new THREE.Euler(this._x, this._y, this._z, this._order)
        }
    }, THREE.Line3 = function(t, e) {
        this.start = void 0 !== t ? t : new THREE.Vector3, this.end = void 0 !== e ? e : new THREE.Vector3
    }, THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        copy: function(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        center: function(t) {
            var e = t || new THREE.Vector3;
            return e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            var e = t || new THREE.Vector3;
            return e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            var r = e || new THREE.Vector3;
            return this.delta(r).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(r, n) {
                t.subVectors(r, this.start), e.subVectors(this.end, this.start);
                var i = e.dot(e),
                    o = e.dot(t),
                    a = o / i;
                return n && (a = THREE.Math.clamp(a, 0, 1)), a
            }
        }(),
        closestPointToPoint: function(t, e, r) {
            var n = this.closestPointToPointParameter(t, e),
                i = r || new THREE.Vector3;
            return this.delta(i).multiplyScalar(n).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        },
        clone: function() {
            return (new THREE.Line3).copy(this)
        }
    }, THREE.Box2 = function(t, e) {
        this.min = void 0 !== t ? t : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector2(-1 / 0, -1 / 0)
    }, THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, r = t.length; r > e; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new THREE.Vector2;
            return function(e, r) {
                var n = t.copy(r).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function(t) {
            var e = t || new THREE.Vector2;
            return e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(t) {
            var e = t || new THREE.Vector2;
            return e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y ? !1 : !0
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y ? !0 : !1
        },
        getParameter: function(t, e) {
            var r = e || new THREE.Vector2;
            return r.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        isIntersectionBox: function(t) {
            return t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function(t, e) {
            var r = e || new THREE.Vector2;
            return r.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new THREE.Vector2;
            return function(e) {
                var r = t.copy(e).clamp(this.min, this.max);
                return r.sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        },
        clone: function() {
            return (new THREE.Box2).copy(this)
        }
    }, THREE.Box3 = function(t, e) {
        this.min = void 0 !== t ? t : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0)
    }, THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, r = t.length; r > e; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new THREE.Vector3;
            return function(e, r) {
                var n = t.copy(r).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        setFromObject: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var r = this;
                return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse(function(e) {
                    if (void 0 !== e.geometry && void 0 !== e.geometry.vertices)
                        for (var n = e.geometry.vertices, i = 0, o = n.length; o > i; i++) t.copy(n[i]), t.applyMatrix4(e.matrixWorld), r.expandByPoint(t)
                }), this
            }
        }(),
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function(t) {
            var e = t || new THREE.Vector3;
            return e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(t) {
            var e = t || new THREE.Vector3;
            return e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z ? !1 : !0
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z ? !0 : !1
        },
        getParameter: function(t, e) {
            var r = e || new THREE.Vector3;
            return r.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        isIntersectionBox: function(t) {
            return t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z ? !1 : !0
        },
        clampPoint: function(t, e) {
            var r = e || new THREE.Vector3;
            return r.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var r = t.copy(e).clamp(this.min, this.max);
                return r.sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var r = e || new THREE.Sphere;
                return r.center = this.center(), r.radius = .5 * this.size(t).length(), r
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function() {
            var t = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function(e) {
                return t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.makeEmpty(), this.setFromPoints(t), this
            }
        }(),
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        },
        clone: function() {
            return (new THREE.Box3).copy(this)
        }
    }, THREE.Matrix3 = function(t, e, r, n, i, o, a, s, h) {
        this.elements = new Float32Array(9);
        var u = this.elements;
        u[0] = void 0 !== t ? t : 1, u[3] = e || 0, u[6] = r || 0, u[1] = n || 0, u[4] = void 0 !== i ? i : 1, u[7] = o || 0, u[2] = a || 0, u[5] = s || 0, u[8] = void 0 !== h ? h : 1
    }, THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function(t, e, r, n, i, o, a, s, h) {
            var u = this.elements;
            return u[0] = t, u[3] = e, u[6] = r, u[1] = n, u[4] = i, u[7] = o, u[2] = a, u[5] = s, u[8] = h, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        copy: function(t) {
            var e = t.elements;
            return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
        },
        applyToVector3Array: function() {
            var t = new THREE.Vector3;
            return function(e, r, n) {
                void 0 === r && (r = 0), void 0 === n && (n = e.length);
                for (var i = 0, o = r; n > i; i += 3, o += 3) t.x = e[o], t.y = e[o + 1], t.z = e[o + 2], t.applyMatrix3(this), e[o] = t.x, e[o + 1] = t.y, e[o + 2] = t.z;
                return e
            }
        }(),
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                r = t[1],
                n = t[2],
                i = t[3],
                o = t[4],
                a = t[5],
                s = t[6],
                h = t[7],
                u = t[8];
            return e * o * u - e * a * h - r * i * u + r * a * s + n * i * h - n * o * s
        },
        getInverse: function(t, e) {
            var r = t.elements,
                n = this.elements;
            n[0] = r[10] * r[5] - r[6] * r[9], n[1] = -r[10] * r[1] + r[2] * r[9], n[2] = r[6] * r[1] - r[2] * r[5], n[3] = -r[10] * r[4] + r[6] * r[8], n[4] = r[10] * r[0] - r[2] * r[8], n[5] = -r[6] * r[0] + r[2] * r[4], n[6] = r[9] * r[4] - r[5] * r[8], n[7] = -r[9] * r[0] + r[1] * r[8], n[8] = r[5] * r[0] - r[1] * r[4];
            var i = r[0] * n[0] + r[1] * n[3] + r[2] * n[6];
            if (0 === i) {
                var o = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (e) throw new Error(o);
                return console.warn(o), this.identity(), this
            }
            return this.multiplyScalar(1 / i), this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        flattenToArrayOffset: function(t, e) {
            var r = this.elements;
            return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t
        },
        getNormalMatrix: function(t) {
            return this.getInverse(t).transpose(), this
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        fromArray: function(t) {
            return this.elements.set(t), this
        },
        toArray: function() {
            var t = this.elements;
            return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]]
        },
        clone: function() {
            var t = this.elements;
            return new THREE.Matrix3(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8])
        }
    }, THREE.Matrix4 = function(t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m) {
        this.elements = new Float32Array(16);
        var g = this.elements;
        g[0] = void 0 !== t ? t : 1, g[4] = e || 0, g[8] = r || 0, g[12] = n || 0, g[1] = i || 0, g[5] = void 0 !== o ? o : 1, g[9] = a || 0, g[13] = s || 0, g[2] = h || 0, g[6] = u || 0, g[10] = void 0 !== l ? l : 1, g[14] = c || 0, g[3] = p || 0, g[7] = f || 0, g[11] = d || 0, g[15] = void 0 !== m ? m : 1
    }, THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function(t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m) {
            var g = this.elements;
            return g[0] = t, g[4] = e, g[8] = r, g[12] = n, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = h, g[6] = u, g[10] = l, g[14] = c, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        copy: function(t) {
            return this.elements.set(t.elements), this
        },
        extractPosition: function(t) {
            return console.warn("THREEMatrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        copyPosition: function(t) {
            var e = this.elements,
                r = t.elements;
            return e[12] = r[12], e[13] = r[13], e[14] = r[14], this
        },
        extractRotation: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var r = this.elements,
                    n = e.elements,
                    i = 1 / t.set(n[0], n[1], n[2]).length(),
                    o = 1 / t.set(n[4], n[5], n[6]).length(),
                    a = 1 / t.set(n[8], n[9], n[10]).length();
                return r[0] = n[0] * i, r[1] = n[1] * i, r[2] = n[2] * i, r[4] = n[4] * o, r[5] = n[5] * o, r[6] = n[6] * o, r[8] = n[8] * a, r[9] = n[9] * a, r[10] = n[10] * a, this
            }
        }(),
        makeRotationFromEuler: function(t) {
            t instanceof THREE.Euler == !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                r = t.x,
                n = t.y,
                i = t.z,
                o = Math.cos(r),
                a = Math.sin(r),
                s = Math.cos(n),
                h = Math.sin(n),
                u = Math.cos(i),
                l = Math.sin(i);
            if ("XYZ" === t.order) {
                var c = o * u,
                    p = o * l,
                    f = a * u,
                    d = a * l;
                e[0] = s * u, e[4] = -s * l, e[8] = h, e[1] = p + f * h, e[5] = c - d * h, e[9] = -a * s, e[2] = d - c * h, e[6] = f + p * h, e[10] = o * s
            } else if ("YXZ" === t.order) {
                var m = s * u,
                    g = s * l,
                    v = h * u,
                    E = h * l;
                e[0] = m + E * a, e[4] = v * a - g, e[8] = o * h, e[1] = o * l, e[5] = o * u, e[9] = -a, e[2] = g * a - v, e[6] = E + m * a, e[10] = o * s
            } else if ("ZXY" === t.order) {
                var m = s * u,
                    g = s * l,
                    v = h * u,
                    E = h * l;
                e[0] = m - E * a, e[4] = -o * l, e[8] = v + g * a, e[1] = g + v * a, e[5] = o * u, e[9] = E - m * a, e[2] = -o * h, e[6] = a, e[10] = o * s
            } else if ("ZYX" === t.order) {
                var c = o * u,
                    p = o * l,
                    f = a * u,
                    d = a * l;
                e[0] = s * u, e[4] = f * h - p, e[8] = c * h + d, e[1] = s * l, e[5] = d * h + c, e[9] = p * h - f, e[2] = -h, e[6] = a * s, e[10] = o * s
            } else if ("YZX" === t.order) {
                var y = o * s,
                    T = o * h,
                    x = a * s,
                    _ = a * h;
                e[0] = s * u, e[4] = _ - y * l, e[8] = x * l + T, e[1] = l, e[5] = o * u, e[9] = -a * u, e[2] = -h * u, e[6] = T * l + x, e[10] = y - _ * l
            } else if ("XZY" === t.order) {
                var y = o * s,
                    T = o * h,
                    x = a * s,
                    _ = a * h;
                e[0] = s * u, e[4] = -l, e[8] = h * u, e[1] = y * l + _, e[5] = o * u, e[9] = T * l - x, e[2] = x * l - T, e[6] = a * u, e[10] = _ * l + y
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements,
                r = t.x,
                n = t.y,
                i = t.z,
                o = t.w,
                a = r + r,
                s = n + n,
                h = i + i,
                u = r * a,
                l = r * s,
                c = r * h,
                p = n * s,
                f = n * h,
                d = i * h,
                m = o * a,
                g = o * s,
                v = o * h;
            return e[0] = 1 - (p + d), e[4] = l - v, e[8] = c + g, e[1] = l + v, e[5] = 1 - (u + d), e[9] = f - m, e[2] = c - g, e[6] = f + m, e[10] = 1 - (u + p), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        lookAt: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                r = new THREE.Vector3;
            return function(n, i, o) {
                var a = this.elements;
                return r.subVectors(n, i).normalize(), 0 === r.length() && (r.z = 1), t.crossVectors(o, r).normalize(), 0 === t.length() && (r.x += 1e-4, t.crossVectors(o, r).normalize()), e.crossVectors(r, t), a[0] = t.x, a[4] = e.x, a[8] = r.x, a[1] = t.y, a[5] = e.y, a[9] = r.y, a[2] = t.z, a[6] = e.z, a[10] = r.z, this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        multiplyMatrices: function(t, e) {
            var r = t.elements,
                n = e.elements,
                i = this.elements,
                o = r[0],
                a = r[4],
                s = r[8],
                h = r[12],
                u = r[1],
                l = r[5],
                c = r[9],
                p = r[13],
                f = r[2],
                d = r[6],
                m = r[10],
                g = r[14],
                v = r[3],
                E = r[7],
                y = r[11],
                T = r[15],
                x = n[0],
                _ = n[4],
                b = n[8],
                R = n[12],
                w = n[1],
                H = n[5],
                M = n[9],
                S = n[13],
                A = n[2],
                C = n[6],
                k = n[10],
                L = n[14],
                z = n[3],
                P = n[7],
                D = n[11],
                F = n[15];
            return i[0] = o * x + a * w + s * A + h * z, i[4] = o * _ + a * H + s * C + h * P, i[8] = o * b + a * M + s * k + h * D, i[12] = o * R + a * S + s * L + h * F, i[1] = u * x + l * w + c * A + p * z, i[5] = u * _ + l * H + c * C + p * P, i[9] = u * b + l * M + c * k + p * D, i[13] = u * R + l * S + c * L + p * F, i[2] = f * x + d * w + m * A + g * z, i[6] = f * _ + d * H + m * C + g * P, i[10] = f * b + d * M + m * k + g * D, i[14] = f * R + d * S + m * L + g * F, i[3] = v * x + E * w + y * A + T * z, i[7] = v * _ + E * H + y * C + T * P, i[11] = v * b + E * M + y * k + T * D, i[15] = v * R + E * S + y * L + T * F, this
        },
        multiplyToArray: function(t, e, r) {
            var n = this.elements;
            return this.multiplyMatrices(t, e), r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = n[3], r[4] = n[4], r[5] = n[5], r[6] = n[6], r[7] = n[7], r[8] = n[8], r[9] = n[9], r[10] = n[10], r[11] = n[11], r[12] = n[12], r[13] = n[13], r[14] = n[14], r[15] = n[15], this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), t.applyProjection(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
        },
        applyToVector3Array: function() {
            var t = new THREE.Vector3;
            return function(e, r, n) {
                void 0 === r && (r = 0), void 0 === n && (n = e.length);
                for (var i = 0, o = r; n > i; i += 3, o += 3) t.x = e[o], t.y = e[o + 1], t.z = e[o + 2], t.applyMatrix4(this), e[o] = t.x, e[o + 1] = t.y, e[o + 2] = t.z;
                return e
            }
        }(),
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                r = t[4],
                n = t[8],
                i = t[12],
                o = t[1],
                a = t[5],
                s = t[9],
                h = t[13],
                u = t[2],
                l = t[6],
                c = t[10],
                p = t[14],
                f = t[3],
                d = t[7],
                m = t[11],
                g = t[15];
            return f * (+i * s * l - n * h * l - i * a * c + r * h * c + n * a * p - r * s * p) + d * (+e * s * p - e * h * c + i * o * c - n * o * p + n * h * u - i * s * u) + m * (+e * h * l - e * a * p - i * o * l + r * o * p + i * a * u - r * h * u) + g * (-n * a * u - e * s * l + e * a * c + n * o * l - r * o * c + r * s * u)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        flattenToArrayOffset: function(t, e) {
            var r = this.elements;
            return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t[e + 9] = r[9], t[e + 10] = r[10], t[e + 11] = r[11], t[e + 12] = r[12], t[e + 13] = r[13], t[e + 14] = r[14], t[e + 15] = r[15], t
        },
        getPosition: function() {
            var t = new THREE.Vector3;
            return function() {
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var e = this.elements;
                return t.set(e[12], e[13], e[14])
            }
        }(),
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        },
        getInverse: function(t, e) {
            var r = this.elements,
                n = t.elements,
                i = n[0],
                o = n[4],
                a = n[8],
                s = n[12],
                h = n[1],
                u = n[5],
                l = n[9],
                c = n[13],
                p = n[2],
                f = n[6],
                d = n[10],
                m = n[14],
                g = n[3],
                v = n[7],
                E = n[11],
                y = n[15];
            r[0] = l * m * v - c * d * v + c * f * E - u * m * E - l * f * y + u * d * y, r[4] = s * d * v - a * m * v - s * f * E + o * m * E + a * f * y - o * d * y, r[8] = a * c * v - s * l * v + s * u * E - o * c * E - a * u * y + o * l * y, r[12] = s * l * f - a * c * f - s * u * d + o * c * d + a * u * m - o * l * m, r[1] = c * d * g - l * m * g - c * p * E + h * m * E + l * p * y - h * d * y, r[5] = a * m * g - s * d * g + s * p * E - i * m * E - a * p * y + i * d * y, r[9] = s * l * g - a * c * g - s * h * E + i * c * E + a * h * y - i * l * y, r[13] = a * c * p - s * l * p + s * h * d - i * c * d - a * h * m + i * l * m, r[2] = u * m * g - c * f * g + c * p * v - h * m * v - u * p * y + h * f * y, r[6] = s * f * g - o * m * g - s * p * v + i * m * v + o * p * y - i * f * y, r[10] = o * c * g - s * u * g + s * h * v - i * c * v - o * h * y + i * u * y, r[14] = s * u * p - o * c * p - s * h * f + i * c * f + o * h * m - i * u * m, r[3] = l * f * g - u * d * g - l * p * v + h * d * v + u * p * E - h * f * E, r[7] = o * d * g - a * f * g + a * p * v - i * d * v - o * p * E + i * f * E, r[11] = a * u * g - o * l * g - a * h * v + i * l * v + o * h * E - i * u * E, r[15] = o * l * p - a * u * p + a * h * f - i * l * f - o * h * d + i * u * d;
            var T = i * r[0] + h * r[4] + p * r[8] + g * r[12];
            if (0 == T) {
                var x = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (e) throw new Error(x);
                return console.warn(x), this.identity(), this
            }
            return this.multiplyScalar(1 / T), this
        },
        translate: function() {
            console.warn("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.warn("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.warn("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.warn("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        scale: function(t) {
            var e = this.elements,
                r = t.x,
                n = t.y,
                i = t.z;
            return e[0] *= r, e[4] *= n, e[8] *= i, e[1] *= r, e[5] *= n, e[9] *= i, e[2] *= r, e[6] *= n, e[10] *= i, e[3] *= r, e[7] *= n, e[11] *= i, this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, Math.max(r, n)))
        },
        makeTranslation: function(t, e, r) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t),
                r = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t),
                r = Math.sin(t);
            return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t),
                r = Math.sin(t);
            return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            var r = Math.cos(e),
                n = Math.sin(e),
                i = 1 - r,
                o = t.x,
                a = t.y,
                s = t.z,
                h = i * o,
                u = i * a;
            return this.set(h * o + r, h * a - n * s, h * s + n * a, 0, h * a + n * s, u * a + r, u * s - n * o, 0, h * s - n * a, u * s + n * o, i * s * s + r, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, r) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, r) {
            return this.makeRotationFromQuaternion(e), this.scale(r), this.setPosition(t), this
        },
        decompose: function() {
            var t = new THREE.Vector3,
                e = new THREE.Matrix4;
            return function(r, n, i) {
                var o = this.elements,
                    a = t.set(o[0], o[1], o[2]).length(),
                    s = t.set(o[4], o[5], o[6]).length(),
                    h = t.set(o[8], o[9], o[10]).length(),
                    u = this.determinant();
                0 > u && (a = -a), r.x = o[12], r.y = o[13], r.z = o[14], e.elements.set(this.elements);
                var l = 1 / a,
                    c = 1 / s,
                    p = 1 / h;
                return e.elements[0] *= l, e.elements[1] *= l, e.elements[2] *= l, e.elements[4] *= c, e.elements[5] *= c, e.elements[6] *= c, e.elements[8] *= p, e.elements[9] *= p, e.elements[10] *= p, n.setFromRotationMatrix(e), i.x = a, i.y = s, i.z = h, this
            }
        }(),
        makeFrustum: function(t, e, r, n, i, o) {
            var a = this.elements,
                s = 2 * i / (e - t),
                h = 2 * i / (n - r),
                u = (e + t) / (e - t),
                l = (n + r) / (n - r),
                c = -(o + i) / (o - i),
                p = -2 * o * i / (o - i);
            return a[0] = s, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = h, a[9] = l, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = c, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makePerspective: function(t, e, r, n) {
            var i = r * Math.tan(THREE.Math.degToRad(.5 * t)),
                o = -i,
                a = o * e,
                s = i * e;
            return this.makeFrustum(a, s, o, i, r, n)
        },
        makeOrthographic: function(t, e, r, n, i, o) {
            var a = this.elements,
                s = e - t,
                h = r - n,
                u = o - i,
                l = (e + t) / s,
                c = (r + n) / h,
                p = (o + i) / u;
            return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -l, a[1] = 0, a[5] = 2 / h, a[9] = 0, a[13] = -c, a[2] = 0, a[6] = 0, a[10] = -2 / u, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        fromArray: function(t) {
            return this.elements.set(t), this
        },
        toArray: function() {
            var t = this.elements;
            return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]]
        },
        clone: function() {
            var t = this.elements;
            return new THREE.Matrix4(t[0], t[4], t[8], t[12], t[1], t[5], t[9], t[13], t[2], t[6], t[10], t[14], t[3], t[7], t[11], t[15])
        }
    }, THREE.Ray = function(t, e) {
        this.origin = void 0 !== t ? t : new THREE.Vector3, this.direction = void 0 !== e ? e : new THREE.Vector3
    }, THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            var r = e || new THREE.Vector3;
            return r.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        recast: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function(t, e) {
            var r = e || new THREE.Vector3;
            r.subVectors(t, this.origin);
            var n = r.dot(this.direction);
            return 0 > n ? r.copy(this.origin) : r.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var r = t.subVectors(e, this.origin).dot(this.direction);
                return 0 > r ? this.origin.distanceTo(e) : (t.copy(this.direction).multiplyScalar(r).add(this.origin), t.distanceTo(e))
            }
        }(),
        distanceSqToSegment: function(t, e, r, n) {
            var i, o, a, s, h = t.clone().add(e).multiplyScalar(.5),
                u = e.clone().sub(t).normalize(),
                l = .5 * t.distanceTo(e),
                c = this.origin.clone().sub(h),
                p = -this.direction.dot(u),
                f = c.dot(this.direction),
                d = -c.dot(u),
                m = c.lengthSq(),
                g = Math.abs(1 - p * p);
            if (g >= 0)
                if (i = p * d - f, o = p * f - d, s = l * g, i >= 0)
                    if (o >= -s)
                        if (s >= o) {
                            var v = 1 / g;
                            i *= v, o *= v, a = i * (i + p * o + 2 * f) + o * (p * i + o + 2 * d) + m
                        } else o = l, i = Math.max(0, -(p * o + f)), a = -i * i + o * (o + 2 * d) + m;
            else o = -l, i = Math.max(0, -(p * o + f)), a = -i * i + o * (o + 2 * d) + m;
            else -s >= o ? (i = Math.max(0, -(-p * l + f)), o = i > 0 ? -l : Math.min(Math.max(-l, -d), l), a = -i * i + o * (o + 2 * d) + m) : s >= o ? (i = 0, o = Math.min(Math.max(-l, -d), l), a = o * (o + 2 * d) + m) : (i = Math.max(0, -(p * l + f)), o = i > 0 ? l : Math.min(Math.max(-l, -d), l), a = -i * i + o * (o + 2 * d) + m);
            else o = p > 0 ? -l : l, i = Math.max(0, -(p * o + f)), a = -i * i + o * (o + 2 * d) + m;
            return r && r.copy(this.direction.clone().multiplyScalar(i).add(this.origin)), n && n.copy(u.clone().multiplyScalar(o).add(h)), a
        },
        isIntersectionSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        intersectSphere: function() {
            var t = new THREE.Vector3;
            return function(e, r) {
                t.subVectors(e.center, this.origin);
                var n = t.dot(this.direction),
                    i = t.dot(t) - n * n,
                    o = e.radius * e.radius;
                if (i > o) return null;
                var a = Math.sqrt(o - i),
                    s = n - a,
                    h = n + a;
                return 0 > s && 0 > h ? null : 0 > s ? this.at(h, r) : this.at(s, r)
            }
        }(),
        isIntersectionPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            var r = t.normal.dot(this.direction);
            return 0 > r * e ? !0 : !1
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 == e) return 0 == t.distanceToPoint(this.origin) ? 0 : null;
            var r = -(this.origin.dot(t.normal) + t.constant) / e;
            return r >= 0 ? r : null
        },
        intersectPlane: function(t, e) {
            var r = this.distanceToPlane(t);
            return null === r ? null : this.at(r, e)
        },
        isIntersectionBox: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectBox: function(t, e) {
            var r, n, i, o, a, s, h = 1 / this.direction.x,
                u = 1 / this.direction.y,
                l = 1 / this.direction.z,
                c = this.origin;
            return h >= 0 ? (r = (t.min.x - c.x) * h, n = (t.max.x - c.x) * h) : (r = (t.max.x - c.x) * h, n = (t.min.x - c.x) * h), u >= 0 ? (i = (t.min.y - c.y) * u, o = (t.max.y - c.y) * u) : (i = (t.max.y - c.y) * u, o = (t.min.y - c.y) * u), r > o || i > n ? null : ((i > r || r !== r) && (r = i), (n > o || n !== n) && (n = o), l >= 0 ? (a = (t.min.z - c.z) * l, s = (t.max.z - c.z) * l) : (a = (t.max.z - c.z) * l, s = (t.min.z - c.z) * l), r > s || a > n ? null : ((a > r || r !== r) && (r = a), (n > s || n !== n) && (n = s), 0 > n ? null : this.at(r >= 0 ? r : n, e)))
        },
        intersectTriangle: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                r = new THREE.Vector3,
                n = new THREE.Vector3;
            return function(i, o, a, s, h) {
                e.subVectors(o, i), r.subVectors(a, i), n.crossVectors(e, r);
                var u, l = this.direction.dot(n);
                if (l > 0) {
                    if (s) return null;
                    u = 1
                } else {
                    if (!(0 > l)) return null;
                    u = -1, l = -l
                }
                t.subVectors(this.origin, i);
                var c = u * this.direction.dot(r.crossVectors(t, r));
                if (0 > c) return null;
                var p = u * this.direction.dot(e.cross(t));
                if (0 > p) return null;
                if (c + p > l) return null;
                var f = -u * t.dot(n);
                return 0 > f ? null : this.at(f / l, h)
            }
        }(),
        applyMatrix4: function(t) {
            return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        },
        clone: function() {
            return (new THREE.Ray).copy(this)
        }
    }, THREE.Sphere = function(t, e) {
        this.center = void 0 !== t ? t : new THREE.Vector3, this.radius = void 0 !== e ? e : 0
    }, THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function() {
            var t = new THREE.Box3;
            return function(e, r) {
                var n = this.center;
                void 0 !== r ? n.copy(r) : t.setFromPoints(e).center(n);
                for (var i = 0, o = 0, a = e.length; a > o; o++) i = Math.max(i, n.distanceToSquared(e[o]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        clampPoint: function(t, e) {
            var r = this.center.distanceToSquared(t),
                n = e || new THREE.Vector3;
            return n.copy(t), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
        },
        getBoundingBox: function(t) {
            var e = t || new THREE.Box3;
            return e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        },
        clone: function() {
            return (new THREE.Sphere).copy(this)
        }
    }, THREE.Frustum = function(t, e, r, n, i, o) {
        this.planes = [void 0 !== t ? t : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== o ? o : new THREE.Plane]
    }, THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function(t, e, r, n, i, o) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(r), a[3].copy(n), a[4].copy(i), a[5].copy(o), this
        },
        copy: function(t) {
            for (var e = this.planes, r = 0; 6 > r; r++) e[r].copy(t.planes[r]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes,
                r = t.elements,
                n = r[0],
                i = r[1],
                o = r[2],
                a = r[3],
                s = r[4],
                h = r[5],
                u = r[6],
                l = r[7],
                c = r[8],
                p = r[9],
                f = r[10],
                d = r[11],
                m = r[12],
                g = r[13],
                v = r[14],
                E = r[15];
            return e[0].setComponents(a - n, l - s, d - c, E - m).normalize(), e[1].setComponents(a + n, l + s, d + c, E + m).normalize(), e[2].setComponents(a + i, l + h, d + p, E + g).normalize(), e[3].setComponents(a - i, l - h, d - p, E - g).normalize(), e[4].setComponents(a - o, l - u, d - f, E - v).normalize(), e[5].setComponents(a + o, l + u, d + f, E + v).normalize(), this
        },
        intersectsObject: function() {
            var t = new THREE.Sphere;
            return function(e) {
                var r = e.geometry;
                return null === r.boundingSphere && r.computeBoundingSphere(), t.copy(r.boundingSphere), t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            for (var e = this.planes, r = t.center, n = -t.radius, i = 0; 6 > i; i++) {
                var o = e[i].distanceToPoint(r);
                if (n > o) return !1
            }
            return !0
        },
        intersectsBox: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(r) {
                for (var n = this.planes, i = 0; 6 > i; i++) {
                    var o = n[i];
                    t.x = o.normal.x > 0 ? r.min.x : r.max.x, e.x = o.normal.x > 0 ? r.max.x : r.min.x, t.y = o.normal.y > 0 ? r.min.y : r.max.y, e.y = o.normal.y > 0 ? r.max.y : r.min.y, t.z = o.normal.z > 0 ? r.min.z : r.max.z, e.z = o.normal.z > 0 ? r.max.z : r.min.z;
                    var a = o.distanceToPoint(t),
                        s = o.distanceToPoint(e);
                    if (0 > a && 0 > s) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, r = 0; 6 > r; r++)
                if (e[r].distanceToPoint(t) < 0) return !1;
            return !0
        },
        clone: function() {
            return (new THREE.Frustum).copy(this)
        }
    }, THREE.Plane = function(t, e) {
        this.normal = void 0 !== t ? t : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }, THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, r, n) {
            return this.normal.set(t, e, r), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(r, n, i) {
                var o = t.subVectors(i, n).cross(e.subVectors(r, n)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, r), this
            }
        }(),
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return this.orthoPoint(t, e).sub(t).negate()
        },
        orthoPoint: function(t, e) {
            var r = this.distanceToPoint(t),
                n = e || new THREE.Vector3;
            return n.copy(this.normal).multiplyScalar(r)
        },
        isIntersectionLine: function(t) {
            var e = this.distanceToPoint(t.start),
                r = this.distanceToPoint(t.end);
            return 0 > e && r > 0 || 0 > r && e > 0
        },
        intersectLine: function() {
            var t = new THREE.Vector3;
            return function(e, r) {
                var n = r || new THREE.Vector3,
                    i = e.delta(t),
                    o = this.normal.dot(i);
                if (0 == o) return 0 == this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;
                var a = -(e.start.dot(this.normal) + this.constant) / o;
                return 0 > a || a > 1 ? void 0 : n.copy(i).multiplyScalar(a).add(e.start)
            }
        }(),
        coplanarPoint: function(t) {
            var e = t || new THREE.Vector3;
            return e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                r = new THREE.Matrix3;
            return function(n, i) {
                var o = i || r.getNormalMatrix(n),
                    a = t.copy(this.normal).applyMatrix3(o),
                    s = this.coplanarPoint(e);
                return s.applyMatrix4(n), this.setFromNormalAndCoplanarPoint(a, s), this
            }
        }(),
        translate: function(t) {
            return this.constant = this.constant - t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant == this.constant
        },
        clone: function() {
            return (new THREE.Plane).copy(this)
        }
    }, THREE.Math = {
        generateUUID: function() {
            var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                r = new Array(36),
                n = 0;
            return function() {
                for (var i = 0; 36 > i; i++) 8 == i || 13 == i || 18 == i || 23 == i ? r[i] = "-" : 14 == i ? r[i] = "4" : (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), t = 15 & n, n >>= 4, r[i] = e[19 == i ? 3 & t | 8 : t]);
                return r.join("")
            }
        }(),
        clamp: function(t, e, r) {
            return e > t ? e : t > r ? r : t
        },
        clampBottom: function(t, e) {
            return e > t ? e : t
        },
        mapLinear: function(t, e, r, n, i) {
            return n + (t - e) * (i - n) / (r - e)
        },
        smoothstep: function(t, e, r) {
            return e >= t ? 0 : t >= r ? 1 : (t = (t - e) / (r - e), t * t * (3 - 2 * t))
        },
        smootherstep: function(t, e, r) {
            return e >= t ? 0 : t >= r ? 1 : (t = (t - e) / (r - e), t * t * t * (t * (6 * t - 15) + 10))
        },
        random16: function() {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        sign: function(t) {
            return 0 > t ? -1 : t > 0 ? 1 : 0
        },
        degToRad: function() {
            var t = Math.PI / 180;
            return function(e) {
                return e * t
            }
        }(),
        radToDeg: function() {
            var t = 180 / Math.PI;
            return function(e) {
                return e * t
            }
        }(),
        isPowerOfTwo: function(t) {
            return 0 === (t & t - 1) && 0 !== t
        }
    }, THREE.Spline = function(t) {
        function e(t, e, r, n, i, o, a) {
            var s = .5 * (r - t),
                h = .5 * (n - e);
            return (2 * (e - r) + s + h) * a + (-3 * (e - r) - 2 * s - h) * o + s * i + e
        }
        this.points = t;
        var r, n, i, o, a, s, h, u, l, c = [],
            p = {
                x: 0,
                y: 0,
                z: 0
            };
        this.initFromArray = function(t) {
            this.points = [];
            for (var e = 0; e < t.length; e++) this.points[e] = {
                x: t[e][0],
                y: t[e][1],
                z: t[e][2]
            }
        }, this.getPoint = function(t) {
            return r = (this.points.length - 1) * t, n = Math.floor(r), i = r - n, c[0] = 0 === n ? n : n - 1, c[1] = n, c[2] = n > this.points.length - 2 ? this.points.length - 1 : n + 1, c[3] = n > this.points.length - 3 ? this.points.length - 1 : n + 2, s = this.points[c[0]], h = this.points[c[1]], u = this.points[c[2]], l = this.points[c[3]], o = i * i, a = i * o, p.x = e(s.x, h.x, u.x, l.x, i, o, a), p.y = e(s.y, h.y, u.y, l.y, i, o, a), p.z = e(s.z, h.z, u.z, l.z, i, o, a), p
        }, this.getControlPointsArray = function() {
            var t, e, r = this.points.length,
                n = [];
            for (t = 0; r > t; t++) e = this.points[t], n[t] = [e.x, e.y, e.z];
            return n
        }, this.getLength = function(t) {
            var e, r, n, i, o = 0,
                a = 0,
                s = 0,
                h = new THREE.Vector3,
                u = new THREE.Vector3,
                l = [],
                c = 0;
            for (l[0] = 0, t || (t = 100), n = this.points.length * t, h.copy(this.points[0]), e = 1; n > e; e++) r = e / n, i = this.getPoint(r), u.copy(i), c += u.distanceTo(h), h.copy(i), o = (this.points.length - 1) * r, a = Math.floor(o), a != s && (l[a] = c, s = a);
            return l[l.length] = c, {
                chunks: l,
                total: c
            }
        }, this.reparametrizeByArcLength = function(t) {
            var e, r, n, i, o, a, s, h, u = [],
                l = new THREE.Vector3,
                c = this.getLength();
            for (u.push(l.copy(this.points[0]).clone()), e = 1; e < this.points.length; e++) {
                for (a = c.chunks[e] - c.chunks[e - 1], s = Math.ceil(t * a / c.total), i = (e - 1) / (this.points.length - 1), o = e / (this.points.length - 1), r = 1; s - 1 > r; r++) n = i + r * (1 / s) * (o - i), h = this.getPoint(n), u.push(l.copy(h).clone());
                u.push(l.copy(this.points[e]).clone())
            }
            this.points = u
        }
    }, THREE.Triangle = function(t, e, r) {
        this.a = void 0 !== t ? t : new THREE.Vector3, this.b = void 0 !== e ? e : new THREE.Vector3, this.c = void 0 !== r ? r : new THREE.Vector3
    }, THREE.Triangle.normal = function() {
        var t = new THREE.Vector3;
        return function(e, r, n, i) {
            var o = i || new THREE.Vector3;
            o.subVectors(n, r), t.subVectors(e, r), o.cross(t);
            var a = o.lengthSq();
            return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0)
        }
    }(), THREE.Triangle.barycoordFromPoint = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3,
            r = new THREE.Vector3;
        return function(n, i, o, a, s) {
            t.subVectors(a, i), e.subVectors(o, i), r.subVectors(n, i);
            var h = t.dot(t),
                u = t.dot(e),
                l = t.dot(r),
                c = e.dot(e),
                p = e.dot(r),
                f = h * c - u * u,
                d = s || new THREE.Vector3;
            if (0 == f) return d.set(-2, -1, -1);
            var m = 1 / f,
                g = (c * l - u * p) * m,
                v = (h * p - u * l) * m;
            return d.set(1 - g - v, v, g)
        }
    }(), THREE.Triangle.containsPoint = function() {
        var t = new THREE.Vector3;
        return function(e, r, n, i) {
            var o = THREE.Triangle.barycoordFromPoint(e, r, n, i, t);
            return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
        }
    }(), THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function(t, e, r) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(r), this
        },
        setFromPointsAndIndices: function(t, e, r, n) {
            return this.a.copy(t[e]), this.b.copy(t[r]), this.c.copy(t[n]), this
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        area: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function() {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(),
        midpoint: function(t) {
            var e = t || new THREE.Vector3;
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(t) {
            return THREE.Triangle.normal(this.a, this.b, this.c, t)
        },
        plane: function(t) {
            var e = t || new THREE.Plane;
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(t, e) {
            return THREE.Triangle.barycoordFromPoint(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return THREE.Triangle.containsPoint(t, this.a, this.b, this.c)
        },
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        },
        clone: function() {
            return (new THREE.Triangle).copy(this)
        }
    }, THREE.Clock = function(t) {
        this.autoStart = void 0 !== t ? t : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }, THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function() {
            this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.oldTime = this.startTime, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var e = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
                t = .001 * (e - this.oldTime), this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    }, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function(t) {
            t.addEventListener = THREE.EventDispatcher.prototype.addEventListener, t.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, t.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, t.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        },
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var r = this._listeners;
            void 0 === r[t] && (r[t] = []), -1 === r[t].indexOf(e) && r[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var r = this._listeners;
            return void 0 !== r[t] && -1 !== r[t].indexOf(e) ? !0 : !1
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var r = this._listeners,
                    n = r[t];
                if (void 0 !== n) {
                    var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners,
                    r = e[t.type];
                if (void 0 !== r) {
                    t.target = this;
                    for (var n = [], i = r.length, o = 0; i > o; o++) n[o] = r[o];
                    for (var o = 0; i > o; o++) n[o].call(this, t)
                }
            }
        }
    },
    function(t) {
        t.Raycaster = function(e, r, n, i) {
            this.ray = new t.Ray(e, r), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                Sprite: {},
                Mesh: {},
                PointCloud: {
                    threshold: 1
                },
                LOD: {},
                Line: {}
            }
        };
        var e = function(t, e) {
                return t.distance - e.distance
            },
            r = function(t, e, n, i) {
                if (t.raycast(e, n), i === !0)
                    for (var o = t.children, a = 0, s = o.length; s > a; a++) r(o[a], e, n, !0)
            };
        t.Raycaster.prototype = {
            constructor: t.Raycaster,
            precision: 1e-4,
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            intersectObject: function(t, n) {
                var i = [];
                return r(t, this, i, n), i.sort(e), i
            },
            intersectObjects: function(t, n) {
                for (var i = [], o = 0, a = t.length; a > o; o++) r(t[o], this, i, n);
                return i.sort(e), i
            }
        }
    }(THREE), THREE.Object3D = function() {
        this.id = THREE.Object3DIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
        var t = new THREE.Vector3,
            e = new THREE.Euler,
            r = new THREE.Quaternion,
            n = new THREE.Vector3(1, 1, 1);
        e.onChange(function() {
            r.setFromEuler(e, !1)
        }), r.onChange(function() {
            e.setFromQuaternion(r, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: r
            },
            scale: {
                enumerable: !0,
                value: n
            }
        }), this.renderDepth = null, this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.userData = {}
    }, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        get eulerOrder() {
            return console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order
        },
        set eulerOrder(t) {
            console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = t
        },
        get useQuaternion() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set useQuaternion(t) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new THREE.Quaternion;
            return function(e, r) {
                return t.setFromAxisAngle(e, r), this.quaternion.multiply(t), this
            }
        }(),
        rotateX: function() {
            var t = new THREE.Vector3(1, 0, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new THREE.Vector3(0, 1, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new THREE.Vector3(0, 0, 1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new THREE.Vector3;
            return function(e, r) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(r)), this
            }
        }(),
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        translateX: function() {
            var t = new THREE.Vector3(1, 0, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new THREE.Vector3(0, 1, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new THREE.Vector3(0, 0, 1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new THREE.Matrix4;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new THREE.Matrix4;
            return function(e) {
                t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            if (t === this) return console.error("THREE.Object3D.add:", t, "can't be added as a child of itself."), this;
            if (t instanceof THREE.Object3D) {
                void 0 !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), this.children.push(t);
                for (var r = this; void 0 !== r.parent;) r = r.parent;
                void 0 !== r && r instanceof THREE.Scene && r.__addObject(t)
            } else console.error("THREE.Object3D.add:", t, "is not an instance of THREE.Object3D.");
            return this
        },
        remove: function(t) {
            if (arguments.length > 1)
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
            var r = this.children.indexOf(t);
            if (-1 !== r) {
                t.parent = void 0, t.dispatchEvent({
                    type: "removed"
                }), this.children.splice(r, 1);
                for (var n = this; void 0 !== n.parent;) n = n.parent;
                void 0 !== n && n instanceof THREE.Scene && n.__removeObject(t)
            }
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = 0, r = this.children.length; r > e; e++) this.children[e].traverse(t)
        },
        traverseVisible: function(t) {
            if (this.visible !== !1) {
                t(this);
                for (var e = 0, r = this.children.length; r > e; e++) this.children[e].traverseVisible(t)
            }
        },
        getObjectById: function(t, e) {
            for (var r = 0, n = this.children.length; n > r; r++) {
                var i = this.children[r];
                if (i.id === t) return i;
                if (e === !0 && (i = i.getObjectById(t, e), void 0 !== i)) return i
            }
            return void 0
        },
        getObjectByName: function(t, e) {
            for (var r = 0, n = this.children.length; n > r; r++) {
                var i = this.children[r];
                if (i.name === t) return i;
                if (e === !0 && (i = i.getObjectByName(t, e), void 0 !== i)) return i
            }
            return void 0
        },
        getChildByName: function(t, e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t, e)
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate === !0 && this.updateMatrix(), (this.matrixWorldNeedsUpdate === !0 || t === !0) && (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = 0, r = this.children.length; r > e; e++) this.children[e].updateMatrixWorld(t)
        },
        clone: function(t, e) {
            if (void 0 === t && (t = new THREE.Object3D), void 0 === e && (e = !0), t.name = this.name, t.up.copy(this.up), t.position.copy(this.position), t.quaternion.copy(this.quaternion), t.scale.copy(this.scale), t.renderDepth = this.renderDepth, t.rotationAutoUpdate = this.rotationAutoUpdate, t.matrix.copy(this.matrix), t.matrixWorld.copy(this.matrixWorld), t.matrixAutoUpdate = this.matrixAutoUpdate, t.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, t.visible = this.visible, t.castShadow = this.castShadow, t.receiveShadow = this.receiveShadow, t.frustumCulled = this.frustumCulled, t.userData = JSON.parse(JSON.stringify(this.userData)), e === !0)
                for (var r = 0; r < this.children.length; r++) {
                    var n = this.children[r];
                    t.add(n.clone())
                }
            return t
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Projector = function() {
        function t() {
            if (h === y) {
                var t = new THREE.RenderableObject;
                return E.push(t), y++, h++, t
            }
            return E[h++]
        }

        function e() {
            if (l === x) {
                var t = new THREE.RenderableVertex;
                return T.push(t), x++, l++, t
            }
            return T[l++]
        }

        function r() {
            if (p === b) {
                var t = new THREE.RenderableFace;
                return _.push(t), b++, p++, t
            }
            return _[p++]
        }

        function n() {
            if (d === w) {
                var t = new THREE.RenderableLine;
                return R.push(t), w++, d++, t
            }
            return R[d++]
        }

        function i() {
            if (g === M) {
                var t = new THREE.RenderableSprite;
                return H.push(t), M++, g++, t
            }
            return H[g++]
        }

        function o(t, e) {
            return t.z !== e.z ? e.z - t.z : t.id !== e.id ? t.id - e.id : 0
        }

        function a(t, e) {
            var r = 0,
                n = 1,
                i = t.z + t.w,
                o = e.z + e.w,
                a = -t.z + t.w,
                s = -e.z + e.w;
            return i >= 0 && o >= 0 && a >= 0 && s >= 0 ? !0 : 0 > i && 0 > o || 0 > a && 0 > s ? !1 : (0 > i ? r = Math.max(r, i / (i - o)) : 0 > o && (n = Math.min(n, i / (i - o))), 0 > a ? r = Math.max(r, a / (a - s)) : 0 > s && (n = Math.min(n, a / (a - s))), r > n ? !1 : (t.lerp(e, r), e.lerp(t, 1 - n), !0))
        }
        var s, h, u, l, c, p, f, d, m, g, v, E = [],
            y = 0,
            T = [],
            x = 0,
            _ = [],
            b = 0,
            R = [],
            w = 0,
            H = [],
            M = 0,
            S = {
                objects: [],
                lights: [],
                elements: []
            },
            A = new THREE.Vector3,
            C = new THREE.Vector3,
            k = new THREE.Vector3,
            L = new THREE.Vector3,
            z = new THREE.Vector4,
            P = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
            D = new THREE.Box3,
            F = new Array(3),
            U = (new Array(4), new THREE.Matrix4),
            O = new THREE.Matrix4,
            B = new THREE.Matrix4,
            V = new THREE.Matrix3,
            N = new THREE.Frustum,
            j = new THREE.Vector4,
            I = new THREE.Vector4;
        this.projectVector = function(t, e) {
            return e.matrixWorldInverse.getInverse(e.matrixWorld), O.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), t.applyProjection(O)
        }, this.unprojectVector = function() {
            var t = new THREE.Matrix4;
            return function(e, r) {
                return t.getInverse(r.projectionMatrix), O.multiplyMatrices(r.matrixWorld, t), e.applyProjection(O)
            }
        }(), this.pickingRay = function(t, e) {
            t.z = -1;
            var r = new THREE.Vector3(t.x, t.y, 1);
            return this.unprojectVector(t, e), this.unprojectVector(r, e), r.sub(t).normalize(), new THREE.Raycaster(t, r)
        };
        var G = function() {
                var t = [],
                    i = [],
                    o = null,
                    a = null,
                    s = new THREE.Matrix3,
                    h = function(e) {
                        o = e, a = o.material, s.getNormalMatrix(o.matrixWorld), t.length = 0, i.length = 0
                    },
                    l = function(t) {
                        var e = t.position,
                            r = t.positionWorld,
                            n = t.positionScreen;
                        r.copy(e).applyMatrix4(v), n.copy(r).applyMatrix4(O);
                        var i = 1 / n.w;
                        n.x *= i, n.y *= i, n.z *= i, t.visible = n.x >= -1 && n.x <= 1 && n.y >= -1 && n.y <= 1 && n.z >= -1 && n.z <= 1
                    },
                    p = function(t, r, n) {
                        u = e(), u.position.set(t, r, n), l(u)
                    },
                    d = function(e, r, n) {
                        t.push(e, r, n)
                    },
                    m = function(t, e) {
                        i.push(t, e)
                    },
                    g = function(t, e, r) {
                        return t.visible === !0 || e.visible === !0 || r.visible === !0 ? !0 : (F[0] = t.positionScreen, F[1] = e.positionScreen, F[2] = r.positionScreen, P.isIntersectionBox(D.setFromPoints(F)))
                    },
                    E = function(t, e, r) {
                        return (r.positionScreen.x - t.positionScreen.x) * (e.positionScreen.y - t.positionScreen.y) - (r.positionScreen.y - t.positionScreen.y) * (e.positionScreen.x - t.positionScreen.x) < 0
                    },
                    y = function(t, e) {
                        var r = T[t],
                            i = T[e];
                        f = n(), f.id = o.id, f.v1.copy(r), f.v2.copy(i), f.z = (r.positionScreen.z + i.positionScreen.z) / 2, f.material = o.material, S.elements.push(f)
                    },
                    x = function(e, n, h) {
                        var u = T[e],
                            l = T[n],
                            p = T[h];
                        if (g(u, l, p) !== !1 && (a.side === THREE.DoubleSide || E(u, l, p) === !0)) {
                            c = r(), c.id = o.id, c.v1.copy(u), c.v2.copy(l), c.v3.copy(p), c.z = (u.positionScreen.z + l.positionScreen.z + p.positionScreen.z) / 3;
                            for (var f = 0; 3 > f; f++) {
                                var d = 3 * arguments[f],
                                    m = c.vertexNormalsModel[f];
                                m.set(t[d], t[d + 1], t[d + 2]), m.applyMatrix3(s).normalize();
                                var v = 2 * arguments[f],
                                    y = c.uvs[f];
                                y.set(i[v], i[v + 1])
                            }
                            c.vertexNormalsLength = 3, c.material = o.material, S.elements.push(c)
                        }
                    };
                return {
                    setObject: h,
                    projectVertex: l,
                    checkTriangleVisibility: g,
                    checkBackfaceCulling: E,
                    pushVertex: p,
                    pushNormal: d,
                    pushUv: m,
                    pushLine: y,
                    pushTriangle: x
                }
            },
            W = new G;
        this.projectScene = function(u, E, y, x) {
            p = 0, d = 0, g = 0, S.elements.length = 0, u.autoUpdate === !0 && u.updateMatrixWorld(), void 0 === E.parent && E.updateMatrixWorld(), U.copy(E.matrixWorldInverse.getInverse(E.matrixWorld)), O.multiplyMatrices(E.projectionMatrix, U), N.setFromMatrix(O), h = 0, S.objects.length = 0, S.lights.length = 0, u.traverseVisible(function(e) {
                e instanceof THREE.Light ? S.lights.push(e) : (e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Sprite) && (e.frustumCulled === !1 || N.intersectsObject(e) === !0) && (s = t(), s.id = e.id, s.object = e, null !== e.renderDepth ? s.z = e.renderDepth : (L.setFromMatrixPosition(e.matrixWorld), L.applyProjection(O), s.z = L.z), S.objects.push(s))
            }), y === !0 && S.objects.sort(o);
            for (var _ = 0, b = S.objects.length; b > _; _++) {
                var R = S.objects[_].object,
                    w = R.geometry;
                if (W.setObject(R), v = R.matrixWorld, l = 0, R instanceof THREE.Mesh) {
                    if (w instanceof THREE.BufferGeometry) {
                        var H = w.attributes,
                            M = w.offsets;
                        if (void 0 === H.position) continue;
                        for (var P = H.position.array, D = 0, F = P.length; F > D; D += 3) W.pushVertex(P[D], P[D + 1], P[D + 2]);
                        if (void 0 !== H.normal)
                            for (var G = H.normal.array, D = 0, F = G.length; F > D; D += 3) W.pushNormal(G[D], G[D + 1], G[D + 2]);
                        if (void 0 !== H.uv)
                            for (var X = H.uv.array, D = 0, F = X.length; F > D; D += 2) W.pushUv(X[D], X[D + 1]);
                        if (void 0 !== H.index) {
                            var q = H.index.array;
                            if (M.length > 0)
                                for (var _ = 0; _ < M.length; _++)
                                    for (var Y = M[_], K = Y.index, D = Y.start, F = Y.start + Y.count; F > D; D += 3) W.pushTriangle(q[D] + K, q[D + 1] + K, q[D + 2] + K);
                            else
                                for (var D = 0, F = q.length; F > D; D += 3) W.pushTriangle(q[D], q[D + 1], q[D + 2])
                        } else
                            for (var D = 0, F = P.length / 3; F > D; D += 3) W.pushTriangle(D, D + 1, D + 2)
                    } else if (w instanceof THREE.Geometry) {
                        var Z = w.vertices,
                            Q = w.faces,
                            J = w.faceVertexUvs[0];
                        V.getNormalMatrix(v);
                        for (var $ = R.material instanceof THREE.MeshFaceMaterial, te = $ === !0 ? R.material : null, ee = 0, re = Z.length; re > ee; ee++) {
                            var ne = Z[ee];
                            W.pushVertex(ne.x, ne.y, ne.z)
                        }
                        for (var ie = 0, oe = Q.length; oe > ie; ie++) {
                            var ae = Q[ie],
                                se = $ === !0 ? te.materials[ae.materialIndex] : R.material;
                            if (void 0 !== se) {
                                var he = se.side,
                                    ue = T[ae.a],
                                    le = T[ae.b],
                                    ce = T[ae.c];
                                if (se.morphTargets === !0) {
                                    var pe = w.morphTargets,
                                        fe = R.morphTargetInfluences,
                                        de = ue.position,
                                        me = le.position,
                                        ge = ce.position;
                                    A.set(0, 0, 0), C.set(0, 0, 0), k.set(0, 0, 0);
                                    for (var ve = 0, Ee = pe.length; Ee > ve; ve++) {
                                        var ye = fe[ve];
                                        if (0 !== ye) {
                                            var Te = pe[ve].vertices;
                                            A.x += (Te[ae.a].x - de.x) * ye, A.y += (Te[ae.a].y - de.y) * ye, A.z += (Te[ae.a].z - de.z) * ye, C.x += (Te[ae.b].x - me.x) * ye, C.y += (Te[ae.b].y - me.y) * ye, C.z += (Te[ae.b].z - me.z) * ye, k.x += (Te[ae.c].x - ge.x) * ye, k.y += (Te[ae.c].y - ge.y) * ye, k.z += (Te[ae.c].z - ge.z) * ye
                                        }
                                    }
                                    ue.position.add(A), le.position.add(C), ce.position.add(k), W.projectVertex(ue), W.projectVertex(le), W.projectVertex(ce)
                                }
                                if (W.checkTriangleVisibility(ue, le, ce) !== !1) {
                                    var xe = W.checkBackfaceCulling(ue, le, ce);
                                    if (he !== THREE.DoubleSide) {
                                        if (he === THREE.FrontSide && xe === !1) continue;
                                        if (he === THREE.BackSide && xe === !0) continue
                                    }
                                    c = r(), c.id = R.id, c.v1.copy(ue), c.v2.copy(le), c.v3.copy(ce), c.normalModel.copy(ae.normal), xe !== !1 || he !== THREE.BackSide && he !== THREE.DoubleSide || c.normalModel.negate(), c.normalModel.applyMatrix3(V).normalize();
                                    for (var _e = ae.vertexNormals, be = 0, Re = Math.min(_e.length, 3); Re > be; be++) {
                                        var we = c.vertexNormalsModel[be];
                                        we.copy(_e[be]), xe !== !1 || he !== THREE.BackSide && he !== THREE.DoubleSide || we.negate(), we.applyMatrix3(V).normalize()
                                    }
                                    c.vertexNormalsLength = _e.length;
                                    var He = J[ie];
                                    if (void 0 !== He)
                                        for (var Me = 0; 3 > Me; Me++) c.uvs[Me].copy(He[Me]);
                                    c.color = ae.color, c.material = se, c.z = (ue.positionScreen.z + le.positionScreen.z + ce.positionScreen.z) / 3, S.elements.push(c)
                                }
                            }
                        }
                    }
                } else if (R instanceof THREE.Line) {
                    if (w instanceof THREE.BufferGeometry) {
                        var H = w.attributes;
                        if (void 0 !== H.position) {
                            for (var P = H.position.array, D = 0, F = P.length; F > D; D += 3) W.pushVertex(P[D], P[D + 1], P[D + 2]);
                            if (void 0 !== H.index)
                                for (var q = H.index.array, D = 0, F = q.length; F > D; D += 2) W.pushLine(q[D], q[D + 1]);
                            else
                                for (var Se = R.type === THREE.LinePieces ? 2 : 1, D = 0, F = P.length / 3 - 1; F > D; D += Se) W.pushLine(D, D + 1)
                        }
                    } else if (w instanceof THREE.Geometry) {
                        B.multiplyMatrices(O, v);
                        var Z = R.geometry.vertices;
                        if (0 === Z.length) continue;
                        ue = e(), ue.positionScreen.copy(Z[0]).applyMatrix4(B);
                        for (var Se = R.type === THREE.LinePieces ? 2 : 1, ee = 1, re = Z.length; re > ee; ee++) ue = e(), ue.positionScreen.copy(Z[ee]).applyMatrix4(B), (ee + 1) % Se > 0 || (le = T[l - 2], j.copy(ue.positionScreen), I.copy(le.positionScreen), a(j, I) === !0 && (j.multiplyScalar(1 / j.w), I.multiplyScalar(1 / I.w), f = n(), f.id = R.id, f.v1.positionScreen.copy(j), f.v2.positionScreen.copy(I), f.z = Math.max(j.z, I.z), f.material = R.material, R.material.vertexColors === THREE.VertexColors && (f.vertexColors[0].copy(R.geometry.colors[ee]), f.vertexColors[1].copy(R.geometry.colors[ee - 1])), S.elements.push(f)))
                    }
                } else if (R instanceof THREE.Sprite) {
                    z.set(v.elements[12], v.elements[13], v.elements[14], 1), z.applyMatrix4(O);
                    var Ae = 1 / z.w;
                    z.z *= Ae, z.z >= -1 && z.z <= 1 && (m = i(), m.id = R.id, m.x = z.x * Ae, m.y = z.y * Ae, m.z = z.z, m.object = R, m.rotation = R.rotation, m.scale.x = R.scale.x * Math.abs(m.x - (z.x + E.projectionMatrix.elements[0]) / (z.w + E.projectionMatrix.elements[12])), m.scale.y = R.scale.y * Math.abs(m.y - (z.y + E.projectionMatrix.elements[5]) / (z.w + E.projectionMatrix.elements[13])), m.material = R.material, S.elements.push(m))
                }
            }
            return x === !0 && S.elements.sort(o), S
        }
    }, THREE.Face3 = function(t, e, r, n, i, o) {
        this.a = t, this.b = e, this.c = r, this.normal = n instanceof THREE.Vector3 ? n : new THREE.Vector3, this.vertexNormals = n instanceof Array ? n : [], this.color = i instanceof THREE.Color ? i : new THREE.Color, this.vertexColors = i instanceof Array ? i : [], this.vertexTangents = [], this.materialIndex = void 0 !== o ? o : 0
    }, THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function() {
            var t = new THREE.Face3(this.a, this.b, this.c);
            t.normal.copy(this.normal), t.color.copy(this.color), t.materialIndex = this.materialIndex;
            for (var e = 0, r = this.vertexNormals.length; r > e; e++) t.vertexNormals[e] = this.vertexNormals[e].clone();
            for (var e = 0, r = this.vertexColors.length; r > e; e++) t.vertexColors[e] = this.vertexColors[e].clone();
            for (var e = 0, r = this.vertexTangents.length; r > e; e++) t.vertexTangents[e] = this.vertexTangents[e].clone();
            return t
        }
    }, THREE.Face4 = function(t, e, r, n, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(t, e, r, i, o, a)
    }, THREE.BufferAttribute = function(t, e) {
        this.array = t, this.itemSize = e
    }, THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute,
        get length() {
            return this.array.length
        },
        set: function(t) {
            return this.array.set(t), this
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        setXY: function(t, e, r) {
            return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this
        },
        setXYZ: function(t, e, r, n) {
            return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this.array[t + 2] = n, this
        },
        setXYZW: function(t, e, r, n, i) {
            return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this.array[t + 2] = n, this.array[t + 3] = i, this
        }
    }, THREE.Int8Attribute = function(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Uint8Attribute = function(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Uint8ClampedAttribute = function(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Int16Attribute = function(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Uint16Attribute = function(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Int32Attribute = function(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Uint32Attribute = function(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Float32Attribute = function(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.Float64Attribute = function(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e)
    }, THREE.BufferGeometry = function() {
        this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.attributes = {}, this.drawcalls = [], this.offsets = this.drawcalls, this.boundingBox = null, this.boundingSphere = null
    }, THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        addAttribute: function(t, e) {
            return e instanceof THREE.BufferAttribute == !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void(this.attributes[t] = {
                array: arguments[1],
                itemSize: arguments[2]
            })) : void(this.attributes[t] = e)
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        addDrawCall: function(t, e, r) {
            this.drawcalls.push({
                start: t,
                count: e,
                index: void 0 !== r ? r : 0
            })
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToVector3Array(e.array), e.needsUpdate = !0);
            var r = this.attributes.normal;
            if (void 0 !== r) {
                var n = (new THREE.Matrix3).getNormalMatrix(t);
                n.applyToVector3Array(r.array), r.needsUpdate = !0
            }
        },
        fromGeometry: function(t, e) {
            e = e || {
                vertexColors: THREE.NoColors
            };
            var r = t.vertices,
                n = t.faces,
                i = t.faceVertexUvs,
                o = e.vertexColors,
                a = i[0].length > 0,
                s = 3 == n[0].vertexNormals.length,
                h = new Float32Array(3 * n.length * 3);
            this.addAttribute("position", new THREE.BufferAttribute(h, 3));
            var u = new Float32Array(3 * n.length * 3);
            if (this.addAttribute("normal", new THREE.BufferAttribute(u, 3)), o !== THREE.NoColors) {
                var l = new Float32Array(3 * n.length * 3);
                this.addAttribute("color", new THREE.BufferAttribute(l, 3))
            }
            if (a === !0) {
                var c = new Float32Array(3 * n.length * 2);
                this.addAttribute("uvs", new THREE.BufferAttribute(c, 2))
            }
            for (var p = 0, f = 0, d = 0; p < n.length; p++, f += 6, d += 9) {
                var m = n[p],
                    g = r[m.a],
                    v = r[m.b],
                    E = r[m.c];
                if (h[d] = g.x, h[d + 1] = g.y, h[d + 2] = g.z, h[d + 3] = v.x, h[d + 4] = v.y, h[d + 5] = v.z, h[d + 6] = E.x, h[d + 7] = E.y, h[d + 8] = E.z, s === !0) {
                    var y = m.vertexNormals[0],
                        T = m.vertexNormals[1],
                        x = m.vertexNormals[2];
                    u[d] = y.x, u[d + 1] = y.y, u[d + 2] = y.z, u[d + 3] = T.x, u[d + 4] = T.y, u[d + 5] = T.z, u[d + 6] = x.x, u[d + 7] = x.y, u[d + 8] = x.z
                } else {
                    var _ = m.normal;
                    u[d] = _.x, u[d + 1] = _.y, u[d + 2] = _.z, u[d + 3] = _.x, u[d + 4] = _.y, u[d + 5] = _.z, u[d + 6] = _.x, u[d + 7] = _.y, u[d + 8] = _.z
                }
                if (o === THREE.FaceColors) {
                    var b = m.color;
                    l[d] = b.r, l[d + 1] = b.g, l[d + 2] = b.b, l[d + 3] = b.r, l[d + 4] = b.g, l[d + 5] = b.b, l[d + 6] = b.r, l[d + 7] = b.g, l[d + 8] = b.b
                } else if (o === THREE.VertexColors) {
                    var R = m.vertexColors[0],
                        w = m.vertexColors[1],
                        H = m.vertexColors[2];
                    l[d] = R.r, l[d + 1] = R.g, l[d + 2] = R.b, l[d + 3] = w.r, l[d + 4] = w.g, l[d + 5] = w.b, l[d + 6] = H.r, l[d + 7] = H.g, l[d + 8] = H.b
                }
                if (a === !0) {
                    var M = i[0][p][0],
                        S = i[0][p][1],
                        A = i[0][p][2];
                    c[f] = M.x, c[f + 1] = M.y, c[f + 2] = S.x, c[f + 3] = S.y, c[f + 4] = A.x, c[f + 5] = A.y
                }
            }
            return this.computeBoundingSphere(), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3);
            var t = this.attributes.position.array;
            if (t) {
                var e = this.boundingBox;
                t.length >= 3 && (e.min.x = e.max.x = t[0], e.min.y = e.max.y = t[1], e.min.z = e.max.z = t[2]);
                for (var r = 3, n = t.length; n > r; r += 3) {
                    var i = t[r],
                        o = t[r + 1],
                        a = t[r + 2];
                    i < e.min.x ? e.min.x = i : i > e.max.x && (e.max.x = i), o < e.min.y ? e.min.y = o : o > e.max.y && (e.max.y = o), a < e.min.z ? e.min.z = a : a > e.max.z && (e.max.z = a)
                }
            }(void 0 === t || 0 === t.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
        },
        computeBoundingSphere: function() {
            var t = new THREE.Box3,
                e = new THREE.Vector3;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var r = this.attributes.position.array;
                if (r) {
                    t.makeEmpty();
                    for (var n = this.boundingSphere.center, i = 0, o = r.length; o > i; i += 3) e.set(r[i], r[i + 1], r[i + 2]), t.expandByPoint(e);
                    t.center(n);
                    for (var a = 0, i = 0, o = r.length; o > i; i += 3) e.set(r[i], r[i + 1], r[i + 2]), a = Math.max(a, n.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            if (this.attributes.position) {
                var t, e, r, n, i = this.attributes.position.array.length;
                if (void 0 === this.attributes.normal) this.attributes.normal = {
                    itemSize: 3,
                    array: new Float32Array(i)
                };
                else
                    for (t = 0, e = this.attributes.normal.array.length; e > t; t++) this.attributes.normal.array[t] = 0;
                var o, a, s, h, u, l, c = this.attributes.position.array,
                    p = this.attributes.normal.array,
                    f = new THREE.Vector3,
                    d = new THREE.Vector3,
                    m = new THREE.Vector3,
                    g = new THREE.Vector3,
                    v = new THREE.Vector3;
                if (this.attributes.index) {
                    var E = this.attributes.index.array,
                        y = this.offsets.length > 0 ? this.offsets : [{
                            start: 0,
                            count: E.length,
                            index: 0
                        }];
                    for (r = 0, n = y.length; n > r; ++r) {
                        var T = y[r].start,
                            x = y[r].count,
                            _ = y[r].index;
                        for (t = T, e = T + x; e > t; t += 3) o = _ + E[t], a = _ + E[t + 1], s = _ + E[t + 2], h = c[3 * o], u = c[3 * o + 1], l = c[3 * o + 2], f.set(h, u, l), h = c[3 * a], u = c[3 * a + 1], l = c[3 * a + 2], d.set(h, u, l), h = c[3 * s], u = c[3 * s + 1], l = c[3 * s + 2], m.set(h, u, l), g.subVectors(m, d), v.subVectors(f, d), g.cross(v), p[3 * o] += g.x, p[3 * o + 1] += g.y, p[3 * o + 2] += g.z, p[3 * a] += g.x, p[3 * a + 1] += g.y, p[3 * a + 2] += g.z, p[3 * s] += g.x, p[3 * s + 1] += g.y, p[3 * s + 2] += g.z
                    }
                } else
                    for (t = 0, e = c.length; e > t; t += 9) h = c[t], u = c[t + 1], l = c[t + 2], f.set(h, u, l), h = c[t + 3], u = c[t + 4], l = c[t + 5], d.set(h, u, l), h = c[t + 6], u = c[t + 7], l = c[t + 8], m.set(h, u, l), g.subVectors(m, d), v.subVectors(f, d), g.cross(v), p[t] = g.x, p[t + 1] = g.y, p[t + 2] = g.z, p[t + 3] = g.x, p[t + 4] = g.y, p[t + 5] = g.z, p[t + 6] = g.x, p[t + 7] = g.y, p[t + 8] = g.z;
                this.normalizeNormals(), this.normalsNeedUpdate = !0
            }
        },
        computeTangents: function() {
            function t(t, e, r) {
                p = n[3 * t], f = n[3 * t + 1], d = n[3 * t + 2], m = n[3 * e], g = n[3 * e + 1], v = n[3 * e + 2], E = n[3 * r], y = n[3 * r + 1], T = n[3 * r + 2], x = o[2 * t], _ = o[2 * t + 1], b = o[2 * e], R = o[2 * e + 1], w = o[2 * r], H = o[2 * r + 1], M = m - p, S = E - p, A = g - f, C = y - f, k = v - d, L = T - d, z = b - x, P = w - x, D = R - _, F = H - _, U = 1 / (z * F - P * D), W.set((F * M - D * S) * U, (F * A - D * C) * U, (F * k - D * L) * U), X.set((z * S - P * M) * U, (z * C - P * A) * U, (z * L - P * k) * U), u[t].add(W), u[e].add(W), u[r].add(W), l[t].add(X), l[e].add(X), l[r].add(X)
            }

            function e(t) {
                re.x = i[3 * t], re.y = i[3 * t + 1], re.z = i[3 * t + 2], ne.copy(re), J = u[t], te.copy(J), te.sub(re.multiplyScalar(re.dot(J))).normalize(), ee.crossVectors(ne, J), $ = ee.dot(l[t]), Q = 0 > $ ? -1 : 1, h[4 * t] = te.x, h[4 * t + 1] = te.y, h[4 * t + 2] = te.z, h[4 * t + 3] = Q
            }
            if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) return void console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
            var r = this.attributes.index.array,
                n = this.attributes.position.array,
                i = this.attributes.normal.array,
                o = this.attributes.uv.array,
                a = n.length / 3;
            if (void 0 === this.attributes.tangent) {
                var s = 4 * a;
                this.attributes.tangent = {
                    itemSize: 4,
                    array: new Float32Array(s)
                }
            }
            for (var h = this.attributes.tangent.array, u = [], l = [], c = 0; a > c; c++) u[c] = new THREE.Vector3, l[c] = new THREE.Vector3;
            var p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L, z, P, D, F, U, O, B, V, N, j, I, G, W = new THREE.Vector3,
                X = new THREE.Vector3,
                q = this.offsets;
            for (V = 0, N = q.length; N > V; ++V) {
                var Y = q[V].start,
                    K = q[V].count,
                    Z = q[V].index;
                for (O = Y, B = Y + K; B > O; O += 3) j = Z + r[O], I = Z + r[O + 1], G = Z + r[O + 2], t(j, I, G)
            }
            var Q, J, $, te = new THREE.Vector3,
                ee = new THREE.Vector3,
                re = new THREE.Vector3,
                ne = new THREE.Vector3;
            for (V = 0, N = q.length; N > V; ++V) {
                var Y = q[V].start,
                    K = q[V].count,
                    Z = q[V].index;
                for (O = Y, B = Y + K; B > O; O += 3) j = Z + r[O], I = Z + r[O + 1], G = Z + r[O + 2], e(j), e(I), e(G)
            }
        },
        computeOffsets: function(t) {
            var e = t;
            void 0 === t && (e = 65535);
            for (var r = (Date.now(), this.attributes.index.array), n = this.attributes.position.array, i = (n.length / 3, r.length / 3), o = new Uint16Array(r.length), a = 0, s = 0, h = [{
                    start: 0,
                    count: 0,
                    index: 0
                }], u = h[0], l = 0, c = 0, p = new Int32Array(6), f = new Int32Array(n.length), d = new Int32Array(n.length), m = 0; m < n.length; m++) f[m] = -1, d[m] = -1;
            for (var g = 0; i > g; g++) {
                c = 0;
                for (var v = 0; 3 > v; v++) {
                    var E = r[3 * g + v]; - 1 == f[E] ? (p[2 * v] = E, p[2 * v + 1] = -1, c++) : f[E] < u.index ? (p[2 * v] = E, p[2 * v + 1] = -1, l++) : (p[2 * v] = E, p[2 * v + 1] = f[E])
                }
                var y = s + c;
                if (y > u.index + e) {
                    var T = {
                        start: a,
                        count: 0,
                        index: s
                    };
                    h.push(T), u = T;
                    for (var x = 0; 6 > x; x += 2) {
                        var _ = p[x + 1];
                        _ > -1 && _ < u.index && (p[x + 1] = -1)
                    }
                }
                for (var x = 0; 6 > x; x += 2) {
                    var E = p[x],
                        _ = p[x + 1]; - 1 === _ && (_ = s++), f[E] = _, d[_] = E, o[a++] = _ - u.index, u.count++
                }
            }
            return this.reorderBuffers(o, d, s), this.offsets = h, h
        },
        merge: function() {
            console.log("BufferGeometry.merge(): TODO")
        },
        normalizeNormals: function() {
            for (var t, e, r, n, i = this.attributes.normal.array, o = 0, a = i.length; a > o; o += 3) t = i[o], e = i[o + 1], r = i[o + 2], n = 1 / Math.sqrt(t * t + e * e + r * r), i[o] *= n, i[o + 1] *= n, i[o + 2] *= n
        },
        reorderBuffers: function(t, e, r) {
            var n = {},
                i = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            for (var o in this.attributes)
                if ("index" != o)
                    for (var a = this.attributes[o].array, s = 0, h = i.length; h > s; s++) {
                        var u = i[s];
                        if (a instanceof u) {
                            n[o] = new u(this.attributes[o].itemSize * r);
                            break
                        }
                    }
                for (var l = 0; r > l; l++) {
                    var c = e[l];
                    for (var o in this.attributes)
                        if ("index" != o)
                            for (var p = this.attributes[o].array, f = this.attributes[o].itemSize, d = n[o], m = 0; f > m; m++) d[l * f + m] = p[c * f + m]
                }
            this.attributes.index.array = t;
            for (var o in this.attributes) "index" != o && (this.attributes[o].array = n[o], this.attributes[o].numItems = this.attributes[o].itemSize * r)
        },
        clone: function() {
            var t = new THREE.BufferGeometry,
                e = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            for (var r in this.attributes) {
                for (var n = this.attributes[r], i = n.array, o = {
                        itemSize: n.itemSize,
                        array: null
                    }, a = 0, s = e.length; s > a; a++) {
                    var h = e[a];
                    if (i instanceof h) {
                        o.array = new h(i);
                        break
                    }
                }
                t.attributes[r] = o
            }
            for (var a = 0, s = this.offsets.length; s > a; a++) {
                var u = this.offsets[a];
                t.offsets.push({
                    start: u.start,
                    index: u.index,
                    count: u.count
                })
            }
            return t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
        this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.tangentsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.buffersNeedUpdate = !1, this.groupsNeedUpdate = !1
    }, THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function(t) {
            for (var e = (new THREE.Matrix3).getNormalMatrix(t), r = 0, n = this.vertices.length; n > r; r++) {
                var i = this.vertices[r];
                i.applyMatrix4(t)
            }
            for (var r = 0, n = this.faces.length; n > r; r++) {
                var o = this.faces[r];
                o.normal.applyMatrix3(e).normalize();
                for (var a = 0, s = o.vertexNormals.length; s > a; a++) o.vertexNormals[a].applyMatrix3(e).normalize()
            }
            this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
        },
        center: function() {
            this.computeBoundingBox();
            var t = new THREE.Vector3;
            return t.addVectors(this.boundingBox.min, this.boundingBox.max), t.multiplyScalar(-.5), this.applyMatrix((new THREE.Matrix4).makeTranslation(t.x, t.y, t.z)), this.computeBoundingBox(), t
        },
        computeFaceNormals: function() {
            for (var t = new THREE.Vector3, e = new THREE.Vector3, r = 0, n = this.faces.length; n > r; r++) {
                var i = this.faces[r],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b],
                    s = this.vertices[i.c];
                t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, r, n, i, o, a;
            for (a = new Array(this.vertices.length), e = 0, r = this.vertices.length; r > e; e++) a[e] = new THREE.Vector3;
            if (t) {
                {
                    var s, h, u, l = new THREE.Vector3,
                        c = new THREE.Vector3;
                    new THREE.Vector3, new THREE.Vector3, new THREE.Vector3
                }
                for (n = 0, i = this.faces.length; i > n; n++) o = this.faces[n], s = this.vertices[o.a], h = this.vertices[o.b], u = this.vertices[o.c], l.subVectors(u, h), c.subVectors(s, h), l.cross(c), a[o.a].add(l), a[o.b].add(l), a[o.c].add(l)
            } else
                for (n = 0, i = this.faces.length; i > n; n++) o = this.faces[n], a[o.a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (e = 0, r = this.vertices.length; r > e; e++) a[e].normalize();
            for (n = 0, i = this.faces.length; i > n; n++) o = this.faces[n], o.vertexNormals[0] = a[o.a].clone(), o.vertexNormals[1] = a[o.b].clone(), o.vertexNormals[2] = a[o.c].clone()
        },
        computeMorphNormals: function() {
            var t, e, r, n, i;
            for (r = 0, n = this.faces.length; n > r; r++)
                for (i = this.faces[r], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), t = 0, e = i.vertexNormals.length; e > t; t++) i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone();
            var o = new THREE.Geometry;
            for (o.faces = this.faces, t = 0, e = this.morphTargets.length; e > t; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var a, s, h = this.morphNormals[t].faceNormals,
                        u = this.morphNormals[t].vertexNormals;
                    for (r = 0, n = this.faces.length; n > r; r++) a = new THREE.Vector3, s = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, h.push(a), u.push(s)
                }
                var l = this.morphNormals[t];
                o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals();
                var a, s;
                for (r = 0, n = this.faces.length; n > r; r++) i = this.faces[r], a = l.faceNormals[r], s = l.vertexNormals[r], a.copy(i.normal), s.a.copy(i.vertexNormals[0]), s.b.copy(i.vertexNormals[1]), s.c.copy(i.vertexNormals[2])
            }
            for (r = 0, n = this.faces.length; n > r; r++) i = this.faces[r], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeTangents: function() {
            function t(t, e, r, n, i, o, a) {
                u = t.vertices[e], l = t.vertices[r], c = t.vertices[n], p = h[i], f = h[o], d = h[a], m = l.x - u.x, g = c.x - u.x, v = l.y - u.y, E = c.y - u.y, y = l.z - u.z, T = c.z - u.z, x = f.x - p.x, _ = d.x - p.x, b = f.y - p.y, R = d.y - p.y, w = 1 / (x * R - _ * b), k.set((R * m - b * g) * w, (R * v - b * E) * w, (R * y - b * T) * w), L.set((x * g - _ * m) * w, (x * E - _ * v) * w, (x * T - _ * y) * w), A[e].add(k), A[r].add(k), A[n].add(k), C[e].add(L), C[r].add(L), C[n].add(L)
            }
            var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A = [],
                C = [],
                k = new THREE.Vector3,
                L = new THREE.Vector3,
                z = new THREE.Vector3,
                P = new THREE.Vector3,
                D = new THREE.Vector3;
            for (n = 0, i = this.vertices.length; i > n; n++) A[n] = new THREE.Vector3, C[n] = new THREE.Vector3;
            for (e = 0, r = this.faces.length; r > e; e++) s = this.faces[e], h = this.faceVertexUvs[0][e], t(this, s.a, s.b, s.c, 0, 1, 2);
            var F = ["a", "b", "c", "d"];
            for (e = 0, r = this.faces.length; r > e; e++)
                for (s = this.faces[e], o = 0; o < Math.min(s.vertexNormals.length, 3); o++) D.copy(s.vertexNormals[o]), a = s[F[o]], H = A[a], z.copy(H), z.sub(D.multiplyScalar(D.dot(H))).normalize(), P.crossVectors(s.vertexNormals[o], H), M = P.dot(C[a]), S = 0 > M ? -1 : 1, s.vertexTangents[o] = new THREE.Vector4(z.x, z.y, z.z, S);
            this.hasTangents = !0
        },
        computeLineDistances: function() {
            for (var t = 0, e = this.vertices, r = 0, n = e.length; n > r; r++) r > 0 && (t += e[r].distanceTo(e[r - 1])), this.lineDistances[r] = t
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, r) {
            if (t instanceof THREE.Geometry == !1) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
            var n, i = this.vertices.length,
                o = (this.faceVertexUvs[0].length, this.vertices),
                a = t.vertices,
                s = this.faces,
                h = t.faces,
                u = this.faceVertexUvs[0],
                l = t.faceVertexUvs[0];
            void 0 === r && (r = 0), void 0 !== e && (n = (new THREE.Matrix3).getNormalMatrix(e));
            for (var c = 0, p = a.length; p > c; c++) {
                var f = a[c],
                    d = f.clone();
                void 0 !== e && d.applyMatrix4(e), o.push(d)
            }
            for (c = 0, p = h.length; p > c; c++) {
                var m, g, v, E = h[c],
                    y = E.vertexNormals,
                    T = E.vertexColors;
                m = new THREE.Face3(E.a + i, E.b + i, E.c + i), m.normal.copy(E.normal), void 0 !== n && m.normal.applyMatrix3(n).normalize();
                for (var x = 0, _ = y.length; _ > x; x++) g = y[x].clone(), void 0 !== n && g.applyMatrix3(n).normalize(), m.vertexNormals.push(g);
                m.color.copy(E.color);
                for (var x = 0, _ = T.length; _ > x; x++) v = T[x], m.vertexColors.push(v.clone());
                m.materialIndex = E.materialIndex + r, s.push(m)
            }
            for (c = 0, p = l.length; p > c; c++) {
                var b = l[c],
                    R = [];
                if (void 0 !== b) {
                    for (var x = 0, _ = b.length; _ > x; x++) R.push(new THREE.Vector2(b[x].x, b[x].y));
                    u.push(R)
                }
            }
        },
        mergeVertices: function() {
            var t, e, r, n, i, o, a, s, h = {},
                u = [],
                l = [],
                c = 4,
                p = Math.pow(10, c);
            for (r = 0, n = this.vertices.length; n > r; r++) t = this.vertices[r], e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" + Math.round(t.z * p), void 0 === h[e] ? (h[e] = r, u.push(this.vertices[r]), l[r] = u.length - 1) : l[r] = l[h[e]];
            var f = [];
            for (r = 0, n = this.faces.length; n > r; r++) {
                i = this.faces[r], i.a = l[i.a], i.b = l[i.b], i.c = l[i.c], o = [i.a, i.b, i.c];
                for (var d = -1, m = 0; 3 > m; m++)
                    if (o[m] == o[(m + 1) % 3]) {
                        d = m, f.push(r);
                        break
                    }
            }
            for (r = f.length - 1; r >= 0; r--) {
                var g = f[r];
                for (this.faces.splice(g, 1), a = 0, s = this.faceVertexUvs.length; s > a; a++) this.faceVertexUvs[a].splice(g, 1)
            }
            var v = this.vertices.length - u.length;
            return this.vertices = u, v
        },
        makeGroups: function() {
            var t = 0;
            return function(e, r) {
                var n, i, o, a, s, h, u = {},
                    l = this.morphTargets.length,
                    c = this.morphNormals.length;
                for (this.geometryGroups = {}, this.geometryGroupsList = [], n = 0, i = this.faces.length; i > n; n++) o = this.faces[n], a = e ? o.materialIndex : 0, a in u || (u[a] = {
                    hash: a,
                    counter: 0
                }), s = u[a].hash + "_" + u[a].counter, s in this.geometryGroups || (h = {
                    id: t++,
                    faces3: [],
                    materialIndex: a,
                    vertices: 0,
                    numMorphTargets: l,
                    numMorphNormals: c
                }, this.geometryGroups[s] = h, this.geometryGroupsList.push(h)), this.geometryGroups[s].vertices + 3 > r && (u[a].counter += 1, s = u[a].hash + "_" + u[a].counter, s in this.geometryGroups || (h = {
                    id: t++,
                    faces3: [],
                    materialIndex: a,
                    vertices: 0,
                    numMorphTargets: l,
                    numMorphNormals: c
                }, this.geometryGroups[s] = h, this.geometryGroupsList.push(h))), this.geometryGroups[s].faces3.push(n), this.geometryGroups[s].vertices += 3
            }
        }(),
        clone: function() {
            for (var t = new THREE.Geometry, e = this.vertices, r = 0, n = e.length; n > r; r++) t.vertices.push(e[r].clone());
            for (var i = this.faces, r = 0, n = i.length; n > r; r++) t.faces.push(i[r].clone());
            for (var o = this.faceVertexUvs[0], r = 0, n = o.length; n > r; r++) {
                for (var a = o[r], s = [], h = 0, u = a.length; u > h; h++) s.push(new THREE.Vector2(a[h].x, a[h].y));
                t.faceVertexUvs[0].push(s)
            }
            return t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Camera = function() {
        THREE.Object3D.call(this), this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
    }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.lookAt = function() {
        var t = new THREE.Matrix4;
        return function(e) {
            t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t)
        }
    }(), THREE.Camera.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, t), t.matrixWorldInverse.copy(this.matrixWorldInverse), t.projectionMatrix.copy(this.projectionMatrix), t
    }, THREE.CubeCamera = function(t, e, r) {
        THREE.Object3D.call(this);
        var n = 90,
            i = 1,
            o = new THREE.PerspectiveCamera(n, i, t, e);
        o.up.set(0, -1, 0), o.lookAt(new THREE.Vector3(1, 0, 0)), this.add(o);
        var a = new THREE.PerspectiveCamera(n, i, t, e);
        a.up.set(0, -1, 0), a.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(a);
        var s = new THREE.PerspectiveCamera(n, i, t, e);
        s.up.set(0, 0, 1), s.lookAt(new THREE.Vector3(0, 1, 0)), this.add(s);
        var h = new THREE.PerspectiveCamera(n, i, t, e);
        h.up.set(0, 0, -1), h.lookAt(new THREE.Vector3(0, -1, 0)), this.add(h);
        var u = new THREE.PerspectiveCamera(n, i, t, e);
        u.up.set(0, -1, 0), u.lookAt(new THREE.Vector3(0, 0, 1)), this.add(u);
        var l = new THREE.PerspectiveCamera(n, i, t, e);
        l.up.set(0, -1, 0), l.lookAt(new THREE.Vector3(0, 0, -1)), this.add(l), this.renderTarget = new THREE.WebGLRenderTargetCube(r, r, {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        }), this.updateCubeMap = function(t, e) {
            var r = this.renderTarget,
                n = r.generateMipmaps;
            r.generateMipmaps = !1, r.activeCubeFace = 0, t.render(e, o, r), r.activeCubeFace = 1, t.render(e, a, r), r.activeCubeFace = 2, t.render(e, s, r), r.activeCubeFace = 3, t.render(e, h, r), r.activeCubeFace = 4, t.render(e, u, r), r.generateMipmaps = n, r.activeCubeFace = 5, t.render(e, l, r)
        }
    }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.OrthographicCamera = function(t, e, r, n, i, o) {
        THREE.Camera.call(this), this.left = t, this.right = e, this.top = r, this.bottom = n, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
        this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
    }, THREE.OrthographicCamera.prototype.clone = function() {
        var t = new THREE.OrthographicCamera;
        return THREE.Camera.prototype.clone.call(this, t), t.left = this.left, t.right = this.right, t.top = this.top, t.bottom = this.bottom, t.near = this.near, t.far = this.far, t
    }, THREE.PerspectiveCamera = function(t, e, r, n) {
        THREE.Camera.call(this), this.fov = void 0 !== t ? t : 50, this.aspect = void 0 !== e ? e : 1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== n ? n : 2e3, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.setLens = function(t, e) {
        void 0 === e && (e = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(e / (2 * t))), this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.setViewOffset = function(t, e, r, n, i, o) {
        this.fullWidth = t, this.fullHeight = e, this.x = r, this.y = n, this.width = i, this.height = o, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        if (this.fullWidth) {
            var t = this.fullWidth / this.fullHeight,
                e = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near,
                r = -e,
                n = t * r,
                i = t * e,
                o = Math.abs(i - n),
                a = Math.abs(e - r);
            this.projectionMatrix.makeFrustum(n + this.x * o / this.fullWidth, n + (this.x + this.width) * o / this.fullWidth, e - (this.y + this.height) * a / this.fullHeight, e - this.y * a / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
    }, THREE.PerspectiveCamera.prototype.clone = function() {
        var t = new THREE.PerspectiveCamera;
        return THREE.Camera.prototype.clone.call(this, t), t.fov = this.fov, t.aspect = this.aspect, t.near = this.near, t.far = this.far, t
    }, THREE.Light = function(t) {
        THREE.Object3D.call(this), this.color = new THREE.Color(t)
    }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.Light), THREE.Object3D.prototype.clone.call(this, t), t.color.copy(this.color), t
    }, THREE.AmbientLight = function(t) {
        THREE.Light.call(this, t)
    }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.clone = function() {
        var t = new THREE.AmbientLight;
        return THREE.Light.prototype.clone.call(this, t), t
    }, THREE.AreaLight = function(t, e) {
        THREE.Light.call(this, t), this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== e ? e : 1, this.width = 1, this.height = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
    }, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight = function(t, e) {
        THREE.Light.call(this, t), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraRight = 500, this.shadowCameraTop = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null
    }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.clone = function() {
        var t = new THREE.DirectionalLight;
        return THREE.Light.prototype.clone.call(this, t), t.target = this.target.clone(), t.intensity = this.intensity, t.castShadow = this.castShadow, t.onlyShadow = this.onlyShadow, t.shadowCameraNear = this.shadowCameraNear, t.shadowCameraFar = this.shadowCameraFar, t.shadowCameraLeft = this.shadowCameraLeft, t.shadowCameraRight = this.shadowCameraRight, t.shadowCameraTop = this.shadowCameraTop, t.shadowCameraBottom = this.shadowCameraBottom, t.shadowCameraVisible = this.shadowCameraVisible, t.shadowBias = this.shadowBias, t.shadowDarkness = this.shadowDarkness, t.shadowMapWidth = this.shadowMapWidth, t.shadowMapHeight = this.shadowMapHeight, t.shadowCascade = this.shadowCascade, t.shadowCascadeOffset.copy(this.shadowCascadeOffset), t.shadowCascadeCount = this.shadowCascadeCount, t.shadowCascadeBias = this.shadowCascadeBias.slice(0), t.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), t.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), t.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), t.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), t
    }, THREE.HemisphereLight = function(t, e, r) {
        THREE.Light.call(this, t), this.position.set(0, 100, 0), this.groundColor = new THREE.Color(e), this.intensity = void 0 !== r ? r : 1
    }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.clone = function() {
        var t = new THREE.HemisphereLight;
        return THREE.Light.prototype.clone.call(this, t), t.groundColor.copy(this.groundColor), t.intensity = this.intensity, t
    }, THREE.PointLight = function(t, e, r) {
        THREE.Light.call(this, t), this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== r ? r : 0
    }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.clone = function() {
        var t = new THREE.PointLight;
        return THREE.Light.prototype.clone.call(this, t), t.intensity = this.intensity, t.distance = this.distance, t
    }, THREE.SpotLight = function(t, e, r, n, i) {
        THREE.Light.call(this, t), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== r ? r : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.exponent = void 0 !== i ? i : 10, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null
    }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.clone = function() {
        var t = new THREE.SpotLight;
        return THREE.Light.prototype.clone.call(this, t), t.target = this.target.clone(), t.intensity = this.intensity, t.distance = this.distance, t.angle = this.angle, t.exponent = this.exponent, t.castShadow = this.castShadow, t.onlyShadow = this.onlyShadow, t.shadowCameraNear = this.shadowCameraNear, t.shadowCameraFar = this.shadowCameraFar, t.shadowCameraFov = this.shadowCameraFov, t.shadowCameraVisible = this.shadowCameraVisible, t.shadowBias = this.shadowBias, t.shadowDarkness = this.shadowDarkness, t.shadowMapWidth = this.shadowMapWidth, t.shadowMapHeight = this.shadowMapHeight, t
    }, THREE.Cache = function() {
        this.files = {}
    }, THREE.Cache.prototype = {
        constructor: THREE.Cache,
        add: function(t, e) {
            this.files[t] = e
        },
        get: function(t) {
            return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    }, THREE.Loader = function(t) {
        this.showStatus = t, this.statusDomElement = t ? THREE.Loader.prototype.addStatusElement() : null, this.imageLoader = new THREE.ImageLoader, this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }, THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        addStatusElement: function() {
            var t = document.createElement("div");
            return t.style.position = "absolute", t.style.right = "0px", t.style.top = "0px", t.style.fontSize = "0.8em", t.style.textAlign = "left", t.style.background = "rgba(0,0,0,0.25)", t.style.color = "#fff", t.style.width = "120px", t.style.padding = "0.5em 0.5em 0.5em 0.5em", t.style.zIndex = 1e3, t.innerHTML = "Loading ...", t
        },
        updateProgress: function(t) {
            var e = "Loaded ";
            e += t.total ? (100 * t.loaded / t.total).toFixed(0) + "%" : (t.loaded / 1024).toFixed(2) + " KB", this.statusDomElement.innerHTML = e
        },
        extractUrlBase: function(t) {
            var e = t.split("/");
            return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
        },
        initMaterials: function(t, e) {
            for (var r = [], n = 0; n < t.length; ++n) r[n] = this.createMaterial(t[n], e);
            return r
        },
        needsTangents: function(t) {
            for (var e = 0, r = t.length; r > e; e++) {
                var n = t[e];
                if (n instanceof THREE.ShaderMaterial) return !0
            }
            return !1
        },
        createMaterial: function(t, e) {
            function r(t) {
                var e = Math.log(t) / Math.LN2;
                return Math.pow(2, Math.round(e))
            }

            function n(t, n, i, a, s, h, u) {
                var l, c = e + i,
                    p = THREE.Loader.Handlers.get(c);
                if (null !== p ? l = p.load(c) : (l = new THREE.Texture, p = o.imageLoader, p.crossOrigin = o.crossOrigin, p.load(c, function(t) {
                        if (THREE.Math.isPowerOfTwo(t.width) === !1 || THREE.Math.isPowerOfTwo(t.height) === !1) {
                            var e = r(t.width),
                                n = r(t.height),
                                i = document.createElement("canvas");
                            i.width = e, i.height = n;
                            var o = i.getContext("2d");
                            o.drawImage(t, 0, 0, e, n), l.image = i
                        } else l.image = t;
                        l.needsUpdate = !0
                    })), l.sourceFile = i, a && (l.repeat.set(a[0], a[1]), 1 !== a[0] && (l.wrapS = THREE.RepeatWrapping), 1 !== a[1] && (l.wrapT = THREE.RepeatWrapping)), s && l.offset.set(s[0], s[1]), h) {
                    var f = {
                        repeat: THREE.RepeatWrapping,
                        mirror: THREE.MirroredRepeatWrapping
                    };
                    void 0 !== f[h[0]] && (l.wrapS = f[h[0]]), void 0 !== f[h[1]] && (l.wrapT = f[h[1]])
                }
                u && (l.anisotropy = u), t[n] = l
            }

            function i(t) {
                return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
            }
            var o = this,
                a = "MeshLambertMaterial",
                s = {
                    color: 15658734,
                    opacity: 1,
                    map: null,
                    lightMap: null,
                    normalMap: null,
                    bumpMap: null,
                    wireframe: !1
                };
            if (t.shading) {
                var h = t.shading.toLowerCase();
                "phong" === h ? a = "MeshPhongMaterial" : "basic" === h && (a = "MeshBasicMaterial")
            }
            if (void 0 !== t.blending && void 0 !== THREE[t.blending] && (s.blending = THREE[t.blending]), (void 0 !== t.transparent || t.opacity < 1) && (s.transparent = t.transparent), void 0 !== t.depthTest && (s.depthTest = t.depthTest), void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.flipSided && (s.side = THREE.BackSide), void 0 !== t.doubleSided && (s.side = THREE.DoubleSide), void 0 !== t.wireframe && (s.wireframe = t.wireframe), void 0 !== t.vertexColors && ("face" === t.vertexColors ? s.vertexColors = THREE.FaceColors : t.vertexColors && (s.vertexColors = THREE.VertexColors)), t.colorDiffuse ? s.color = i(t.colorDiffuse) : t.DbgColor && (s.color = t.DbgColor), t.colorSpecular && (s.specular = i(t.colorSpecular)), t.colorAmbient && (s.ambient = i(t.colorAmbient)), t.colorEmissive && (s.emissive = i(t.colorEmissive)), t.transparency && (s.opacity = t.transparency), t.specularCoef && (s.shininess = t.specularCoef), t.mapDiffuse && e && n(s, "map", t.mapDiffuse, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy), t.mapLight && e && n(s, "lightMap", t.mapLight, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy), t.mapBump && e && n(s, "bumpMap", t.mapBump, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy), t.mapNormal && e && n(s, "normalMap", t.mapNormal, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy), t.mapSpecular && e && n(s, "specularMap", t.mapSpecular, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy), t.mapAlpha && e && n(s, "alphaMap", t.mapAlpha, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy), t.mapBumpScale && (s.bumpScale = t.mapBumpScale), t.mapNormal) {
                var u = THREE.ShaderLib.normalmap,
                    l = THREE.UniformsUtils.clone(u.uniforms);
                l.tNormal.value = s.normalMap, t.mapNormalFactor && l.uNormalScale.value.set(t.mapNormalFactor, t.mapNormalFactor), s.map && (l.tDiffuse.value = s.map, l.enableDiffuse.value = !0), s.specularMap && (l.tSpecular.value = s.specularMap, l.enableSpecular.value = !0), s.lightMap && (l.tAO.value = s.lightMap, l.enableAO.value = !0), l.diffuse.value.setHex(s.color), l.specular.value.setHex(s.specular), l.ambient.value.setHex(s.ambient), l.shininess.value = s.shininess, void 0 !== s.opacity && (l.opacity.value = s.opacity);
                var c = {
                        fragmentShader: u.fragmentShader,
                        vertexShader: u.vertexShader,
                        uniforms: l,
                        lights: !0,
                        fog: !0
                    },
                    p = new THREE.ShaderMaterial(c);
                s.transparent && (p.transparent = !0)
            } else var p = new THREE[a](s);
            return void 0 !== t.DbgName && (p.name = t.DbgName), p
        }
    }, THREE.Loader.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = 0, r = this.handlers.length; r > e; e += 2) {
                var n = this.handlers[e],
                    i = this.handlers[e + 1];
                if (n.test(t)) return i
            }
            return null
        }
    }, THREE.XHRLoader = function(t) {
        this.cache = new THREE.Cache, this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = i.cache.get(t);
            if (void 0 !== o) return void(e && e(o));
            var a = new XMLHttpRequest;
            a.open("GET", t, !0), a.addEventListener("load", function() {
                i.cache.add(t, this.response), e && e(this.response), i.manager.itemEnd(t)
            }, !1), void 0 !== r && a.addEventListener("progress", function(t) {
                r(t)
            }, !1), void 0 !== n && a.addEventListener("error", function(t) {
                n(t)
            }, !1), void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (a.responseType = this.responseType), a.send(null), i.manager.itemStart(t)
        },
        setResponseType: function(t) {
            this.responseType = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.ImageLoader = function(t) {
        this.cache = new THREE.Cache, this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = i.cache.get(t);
            if (void 0 !== o) return void e(o);
            var a = document.createElement("img");
            return void 0 !== e && a.addEventListener("load", function() {
                i.cache.add(t, this), e(this), i.manager.itemEnd(t)
            }, !1), void 0 !== r && a.addEventListener("progress", function(t) {
                r(t)
            }, !1), void 0 !== n && a.addEventListener("error", function(t) {
                n(t)
            }, !1), void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), a.src = t, i.manager.itemStart(t), a
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.JSONLoader = function(t) {
        THREE.Loader.call(this, t), this.withCredentials = !1
    }, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.load = function(t, e, r) {
        r = r && "string" == typeof r ? r : this.extractUrlBase(t), this.onLoadStart(), this.loadAjaxJSON(this, t, e, r)
    }, THREE.JSONLoader.prototype.loadAjaxJSON = function(t, e, r, n, i) {
        var o = new XMLHttpRequest,
            a = 0;
        o.onreadystatechange = function() {
            if (o.readyState === o.DONE)
                if (200 === o.status || 0 === o.status) {
                    if (o.responseText) {
                        var s = JSON.parse(o.responseText);
                        if (void 0 !== s.metadata && "scene" === s.metadata.type) return void console.error('THREE.JSONLoader: "' + e + '" seems to be a Scene. Use THREE.SceneLoader instead.');
                        var h = t.parse(s, n);
                        r(h.geometry, h.materials)
                    } else console.error('THREE.JSONLoader: "' + e + '" seems to be unreachable or the file is empty.');
                    t.onLoadComplete()
                } else console.error("THREE.JSONLoader: Couldn't load \"" + e + '" (' + o.status + ")");
            else o.readyState === o.LOADING ? i && (0 === a && (a = o.getResponseHeader("Content-Length")), i({
                total: a,
                loaded: o.responseText.length
            })) : o.readyState === o.HEADERS_RECEIVED && void 0 !== i && (a = o.getResponseHeader("Content-Length"))
        }, o.open("GET", e, !0), o.withCredentials = this.withCredentials, o.send(null)
    }, THREE.JSONLoader.prototype.parse = function(t, e) {
        function r(e) {
            function r(t, e) {
                return t & 1 << e
            }
            var n, i, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k = t.faces,
                L = t.vertices,
                z = t.normals,
                P = t.colors,
                D = 0;
            if (void 0 !== t.uvs) {
                for (n = 0; n < t.uvs.length; n++) t.uvs[n].length && D++;
                for (n = 0; D > n; n++) o.faceVertexUvs[n] = []
            }
            for (s = 0, h = L.length; h > s;) x = new THREE.Vector3, x.x = L[s++] * e, x.y = L[s++] * e, x.z = L[s++] * e, o.vertices.push(x);
            for (s = 0, h = k.length; h > s;)
                if (f = k[s++], d = r(f, 0), m = r(f, 1), g = r(f, 3), v = r(f, 4), E = r(f, 5), y = r(f, 6), T = r(f, 7), d) {
                    if (b = new THREE.Face3, b.a = k[s], b.b = k[s + 1], b.c = k[s + 3], R = new THREE.Face3, R.a = k[s + 1], R.b = k[s + 2], R.c = k[s + 3], s += 4, m && (p = k[s++], b.materialIndex = p, R.materialIndex = p), a = o.faces.length, g)
                        for (n = 0; D > n; n++)
                            for (M = t.uvs[n], o.faceVertexUvs[n][a] = [], o.faceVertexUvs[n][a + 1] = [], i = 0; 4 > i; i++) c = k[s++], A = M[2 * c], C = M[2 * c + 1], S = new THREE.Vector2(A, C), 2 !== i && o.faceVertexUvs[n][a].push(S), 0 !== i && o.faceVertexUvs[n][a + 1].push(S);
                    if (v && (l = 3 * k[s++], b.normal.set(z[l++], z[l++], z[l]), R.normal.copy(b.normal)), E)
                        for (n = 0; 4 > n; n++) l = 3 * k[s++], H = new THREE.Vector3(z[l++], z[l++], z[l]), 2 !== n && b.vertexNormals.push(H), 0 !== n && R.vertexNormals.push(H);
                    if (y && (u = k[s++], w = P[u], b.color.setHex(w), R.color.setHex(w)), T)
                        for (n = 0; 4 > n; n++) u = k[s++], w = P[u], 2 !== n && b.vertexColors.push(new THREE.Color(w)), 0 !== n && R.vertexColors.push(new THREE.Color(w));
                    o.faces.push(b), o.faces.push(R)
                } else {
                    if (_ = new THREE.Face3, _.a = k[s++], _.b = k[s++], _.c = k[s++], m && (p = k[s++], _.materialIndex = p), a = o.faces.length, g)
                        for (n = 0; D > n; n++)
                            for (M = t.uvs[n], o.faceVertexUvs[n][a] = [], i = 0; 3 > i; i++) c = k[s++], A = M[2 * c], C = M[2 * c + 1], S = new THREE.Vector2(A, C), o.faceVertexUvs[n][a].push(S);
                    if (v && (l = 3 * k[s++], _.normal.set(z[l++], z[l++], z[l])), E)
                        for (n = 0; 3 > n; n++) l = 3 * k[s++], H = new THREE.Vector3(z[l++], z[l++], z[l]), _.vertexNormals.push(H);
                    if (y && (u = k[s++], _.color.setHex(P[u])), T)
                        for (n = 0; 3 > n; n++) u = k[s++], _.vertexColors.push(new THREE.Color(P[u]));
                    o.faces.push(_)
                }
        }

        function n() {
            var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
            if (t.skinWeights)
                for (var r = 0, n = t.skinWeights.length; n > r; r += e) {
                    var i = t.skinWeights[r],
                        a = e > 1 ? t.skinWeights[r + 1] : 0,
                        s = e > 2 ? t.skinWeights[r + 2] : 0,
                        h = e > 3 ? t.skinWeights[r + 3] : 0;
                    o.skinWeights.push(new THREE.Vector4(i, a, s, h))
                }
            if (t.skinIndices)
                for (var r = 0, n = t.skinIndices.length; n > r; r += e) {
                    var u = t.skinIndices[r],
                        l = e > 1 ? t.skinIndices[r + 1] : 0,
                        c = e > 2 ? t.skinIndices[r + 2] : 0,
                        p = e > 3 ? t.skinIndices[r + 3] : 0;
                    o.skinIndices.push(new THREE.Vector4(u, l, c, p))
                }
            o.bones = t.bones, o.bones && o.bones.length > 0 && (o.skinWeights.length !== o.skinIndices.length || o.skinIndices.length !== o.vertices.length) && console.warn("When skinning, number of vertices (" + o.vertices.length + "), skinIndices (" + o.skinIndices.length + "), and skinWeights (" + o.skinWeights.length + ") should match."), o.animation = t.animation, o.animations = t.animations
        }

        function i(e) {
            if (void 0 !== t.morphTargets) {
                var r, n, i, a, s, h;
                for (r = 0, n = t.morphTargets.length; n > r; r++)
                    for (o.morphTargets[r] = {}, o.morphTargets[r].name = t.morphTargets[r].name, o.morphTargets[r].vertices = [], s = o.morphTargets[r].vertices, h = t.morphTargets[r].vertices, i = 0, a = h.length; a > i; i += 3) {
                        var u = new THREE.Vector3;
                        u.x = h[i] * e, u.y = h[i + 1] * e, u.z = h[i + 2] * e, s.push(u)
                    }
            }
            if (void 0 !== t.morphColors) {
                var r, n, l, c, p, f, d;
                for (r = 0, n = t.morphColors.length; n > r; r++)
                    for (o.morphColors[r] = {}, o.morphColors[r].name = t.morphColors[r].name, o.morphColors[r].colors = [], p = o.morphColors[r].colors, f = t.morphColors[r].colors, l = 0, c = f.length; c > l; l += 3) d = new THREE.Color(16755200), d.setRGB(f[l], f[l + 1], f[l + 2]), p.push(d)
            }
        }
        var o = new THREE.Geometry,
            a = void 0 !== t.scale ? 1 / t.scale : 1;
        if (r(a), n(), i(a), o.computeFaceNormals(), o.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length) return {
            geometry: o
        };
        var s = this.initMaterials(t.materials, e);
        return this.needsTangents(s) && o.computeTangents(), {
            geometry: o,
            materials: s
        }
    }, THREE.LoadingManager = function(t, e, r) {
        var n = this,
            i = 0,
            o = 0;
        this.onLoad = t, this.onProgress = e, this.onError = r, this.itemStart = function() {
            o++
        }, this.itemEnd = function(t) {
            i++, void 0 !== n.onProgress && n.onProgress(t, i, o), i === o && void 0 !== n.onLoad && n.onLoad()
        }
    }, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = new THREE.XHRLoader;
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, r, n)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t) {
            var e = new THREE.BufferGeometry,
                r = t.attributes;
            for (var n in r) {
                var i = r[n];
                e.attributes[n] = {
                    itemSize: i.itemSize,
                    array: new self[i.type](i.array)
                }
            }
            var o = t.offsets;
            void 0 !== o && (e.offsets = JSON.parse(JSON.stringify(o)));
            var a = t.boundingSphere;
            return void 0 !== a && (e.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== a.center ? a.center : [0, 0, 0]), a.radius)), e
        }
    }, THREE.MaterialLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = new THREE.XHRLoader;
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, r, n)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t) {
            var e = new THREE[t.type];
            if (void 0 !== t.color && e.color.setHex(t.color), void 0 !== t.ambient && e.ambient.setHex(t.ambient), void 0 !== t.emissive && e.emissive.setHex(t.emissive), void 0 !== t.specular && e.specular.setHex(t.specular), void 0 !== t.shininess && (e.shininess = t.shininess), void 0 !== t.uniforms && (e.uniforms = t.uniforms), void 0 !== t.vertexShader && (e.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (e.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (e.vertexColors = t.vertexColors), void 0 !== t.blending && (e.blending = t.blending), void 0 !== t.side && (e.side = t.side), void 0 !== t.opacity && (e.opacity = t.opacity), void 0 !== t.transparent && (e.transparent = t.transparent), void 0 !== t.wireframe && (e.wireframe = t.wireframe), void 0 !== t.materials)
                for (var r = 0, n = t.materials.length; n > r; r++) e.materials.push(this.parse(t.materials[r]));
            return e
        }
    }, THREE.ObjectLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = new THREE.XHRLoader(i.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, r, n)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t) {
            var e = this.parseGeometries(t.geometries),
                r = this.parseMaterials(t.materials),
                n = this.parseObject(t.object, e, r);
            return n
        },
        parseGeometries: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var r = new THREE.JSONLoader, n = new THREE.BufferGeometryLoader, i = 0, o = t.length; o > i; i++) {
                    var a, s = t[i];
                    switch (s.type) {
                        case "PlaneGeometry":
                            a = new THREE.PlaneGeometry(s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            a = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                            a = new THREE.CircleGeometry(s.radius, s.segments);
                            break;
                        case "CylinderGeometry":
                            a = new THREE.CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded);
                            break;
                        case "SphereGeometry":
                            a = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "IcosahedronGeometry":
                            a = new THREE.IcosahedronGeometry(s.radius, s.detail);
                            break;
                        case "TorusGeometry":
                            a = new THREE.TorusGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                            a = new THREE.TorusKnotGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.p, s.q, s.heightScale);
                            break;
                        case "BufferGeometry":
                            a = n.parse(s.data);
                            break;
                        case "Geometry":
                            a = r.parse(s.data).geometry
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), e[s.uuid] = a
                }
            return e
        },
        parseMaterials: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var r = new THREE.MaterialLoader, n = 0, i = t.length; i > n; n++) {
                    var o = t[n],
                        a = r.parse(o);
                    a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), e[o.uuid] = a
                }
            return e
        },
        parseObject: function() {
            var t = new THREE.Matrix4;
            return function(e, r, n) {
                var i;
                switch (e.type) {
                    case "Scene":
                        i = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        i = new THREE.PerspectiveCamera(e.fov, e.aspect, e.near, e.far);
                        break;
                    case "OrthographicCamera":
                        i = new THREE.OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far);
                        break;
                    case "AmbientLight":
                        i = new THREE.AmbientLight(e.color);
                        break;
                    case "DirectionalLight":
                        i = new THREE.DirectionalLight(e.color, e.intensity);
                        break;
                    case "PointLight":
                        i = new THREE.PointLight(e.color, e.intensity, e.distance);
                        break;
                    case "SpotLight":
                        i = new THREE.SpotLight(e.color, e.intensity, e.distance, e.angle, e.exponent);
                        break;
                    case "HemisphereLight":
                        i = new THREE.HemisphereLight(e.color, e.groundColor, e.intensity);
                        break;
                    case "Mesh":
                        var o = r[e.geometry],
                            a = n[e.material];
                        void 0 === o && console.error("THREE.ObjectLoader: Undefined geometry " + e.geometry), void 0 === a && console.error("THREE.ObjectLoader: Undefined material " + e.material), i = new THREE.Mesh(o, a);
                        break;
                    case "Sprite":
                        var a = n[e.material];
                        void 0 === a && console.error("THREE.ObjectLoader: Undefined material " + e.material), i = new THREE.Sprite(a);
                        break;
                    default:
                        i = new THREE.Object3D
                }
                if (i.uuid = e.uuid, void 0 !== e.name && (i.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position), void 0 !== e.rotation && i.rotation.fromArray(e.rotation), void 0 !== e.scale && i.scale.fromArray(e.scale)), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.children)
                    for (var s in e.children) i.add(this.parseObject(e.children[s], r, n));
                return i
            }
        }()
    }, THREE.TextureLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function(t, e, r, n) {
            var i = this,
                o = new THREE.ImageLoader(i.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                var r = new THREE.Texture(t);
                r.needsUpdate = !0, void 0 !== e && e(r)
            }, r, n)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.Material = function() {
        this.id = THREE.MaterialIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.depthTest = !0, this.depthWrite = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.overdraw = 0, this.visible = !0, this.needsUpdate = !0
    }, THREE.Material.prototype = {
        constructor: THREE.Material,
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var r = t[e];
                    if (void 0 !== r) {
                        if (e in this) {
                            var n = this[e];
                            n instanceof THREE.Color ? n.set(r) : n instanceof THREE.Vector3 && r instanceof THREE.Vector3 ? n.copy(r) : this[e] = "overdraw" == e ? Number(r) : r
                        }
                    } else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        clone: function(t) {
            return void 0 === t && (t = new THREE.Material), t.name = this.name, t.side = this.side, t.opacity = this.opacity, t.transparent = this.transparent, t.blending = this.blending, t.blendSrc = this.blendSrc, t.blendDst = this.blendDst, t.blendEquation = this.blendEquation, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite, t.polygonOffset = this.polygonOffset, t.polygonOffsetFactor = this.polygonOffsetFactor, t.polygonOffsetUnits = this.polygonOffsetUnits, t.alphaTest = this.alphaTest, t.overdraw = this.overdraw, t.visible = this.visible, t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t)
    }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.clone = function() {
        var t = new THREE.LineBasicMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.linewidth = this.linewidth, t.linecap = this.linecap, t.linejoin = this.linejoin, t.vertexColors = this.vertexColors, t.fog = this.fog, t
    }, THREE.LineDashedMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(t)
    }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.clone = function() {
        var t = new THREE.LineDashedMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.linewidth = this.linewidth, t.scale = this.scale, t.dashSize = this.dashSize, t.gapSize = this.gapSize, t.vertexColors = this.vertexColors, t.fog = this.fog, t
    }, THREE.MeshBasicMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.clone = function() {
        var t = new THREE.MeshBasicMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.lightMap = this.lightMap, t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t
    }, THREE.MeshLambertMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.clone = function() {
        var t = new THREE.MeshLambertMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.ambient.copy(this.ambient), t.emissive.copy(this.emissive), t.wrapAround = this.wrapAround, t.wrapRGB.copy(this.wrapRGB), t.map = this.map, t.lightMap = this.lightMap, t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t
    }, THREE.MeshPhongMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.metal = !1, this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.clone = function() {
        var t = new THREE.MeshPhongMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.ambient.copy(this.ambient), t.emissive.copy(this.emissive), t.specular.copy(this.specular), t.shininess = this.shininess, t.metal = this.metal, t.wrapAround = this.wrapAround, t.wrapRGB.copy(this.wrapRGB), t.map = this.map, t.lightMap = this.lightMap, t.bumpMap = this.bumpMap, t.bumpScale = this.bumpScale, t.normalMap = this.normalMap, t.normalScale.copy(this.normalScale), t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t
    }, THREE.MeshDepthMaterial = function(t) {
        THREE.Material.call(this), this.morphTargets = !1, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
    }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.clone = function() {
        var t = new THREE.MeshDepthMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t
    }, THREE.MeshNormalMaterial = function(t) {
        THREE.Material.call(this, t), this.shading = THREE.FlatShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(t)
    }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.clone = function() {
        var t = new THREE.MeshNormalMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t
    }, THREE.MeshFaceMaterial = function(t) {
        this.materials = t instanceof Array ? t : []
    }, THREE.MeshFaceMaterial.prototype.clone = function() {
        for (var t = new THREE.MeshFaceMaterial, e = 0; e < this.materials.length; e++) t.materials.push(this.materials[e].clone());
        return t
    }, THREE.PointCloudMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t)
    }, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointCloudMaterial.prototype.clone = function() {
        var t = new THREE.PointCloudMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.size = this.size, t.sizeAttenuation = this.sizeAttenuation, t.vertexColors = this.vertexColors, t.fog = this.fog, t
    }, THREE.ParticleBasicMaterial = function(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(t)
    }, THREE.ParticleSystemMaterial = function(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(t)
    }, THREE.ShaderMaterial = function(t) {
        THREE.Material.call(this), this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.setValues(t)
    }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.clone = function() {
        var t = new THREE.ShaderMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.fragmentShader = this.fragmentShader, t.vertexShader = this.vertexShader, t.uniforms = THREE.UniformsUtils.clone(this.uniforms), t.attributes = this.attributes, t.defines = this.defines, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.fog = this.fog, t.lights = this.lights, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t
    }, THREE.RawShaderMaterial = function(t) {
        THREE.ShaderMaterial.call(this, t)
    }, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.clone = function() {
        var t = new THREE.RawShaderMaterial;
        return THREE.ShaderMaterial.prototype.clone.call(this, t), t
    }, THREE.SpriteMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(t)
    }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.clone = function() {
        var t = new THREE.SpriteMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.rotation = this.rotation, t.fog = this.fog, t
    }, THREE.SpriteCanvasMaterial = function(t) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.program = function() {}, this.setValues(t)
    }, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function() {
        var t = new THREE.SpriteCanvasMaterial;
        return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.program = this.program, t
    }, THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial, THREE.Texture = function(t, e, r, n, i, o, a, s, h) {
        this.id = THREE.TextureIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = void 0 !== t ? t : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i ? i : THREE.LinearFilter, this.minFilter = void 0 !== o ? o : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== a ? a : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
    }, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping, THREE.Texture.prototype = {
        constructor: THREE.Texture,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(t) {
            t === !0 && this.update(), this._needsUpdate = t
        },
        clone: function(t) {
            return void 0 === t && (t = new THREE.Texture), t.image = this.image, t.mipmaps = this.mipmaps.slice(0), t.mapping = this.mapping, t.wrapS = this.wrapS, t.wrapT = this.wrapT, t.magFilter = this.magFilter, t.minFilter = this.minFilter, t.anisotropy = this.anisotropy, t.format = this.format, t.type = this.type, t.offset.copy(this.offset), t.repeat.copy(this.repeat), t.generateMipmaps = this.generateMipmaps, t.premultiplyAlpha = this.premultiplyAlpha, t.flipY = this.flipY, t.unpackAlignment = this.unpackAlignment, t
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CubeTexture = function(t, e, r, n, i, o, a, s, h) {
        THREE.Texture.call(this, t, e, r, n, i, o, a, s, h), this.images = t
    }, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.clone = function(t) {
        return void 0 === t && (t = new THREE.CubeTexture), THREE.Texture.prototype.clone.call(this, t), t.images = this.images, t
    }, THREE.CompressedTexture = function(t, e, r, n, i, o, a, s, h, u, l) {
        THREE.Texture.call(this, null, o, a, s, h, u, n, i, l), this.image = {
            width: e,
            height: r
        }, this.mipmaps = t, this.generateMipmaps = !1
    }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.clone = function() {
        var t = new THREE.CompressedTexture;
        return THREE.Texture.prototype.clone.call(this, t), t
    }, THREE.DataTexture = function(t, e, r, n, i, o, a, s, h, u, l) {
        THREE.Texture.call(this, null, o, a, s, h, u, n, i, l), this.image = {
            data: t,
            width: e,
            height: r
        }
    }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.clone = function() {
        var t = new THREE.DataTexture;
        return THREE.Texture.prototype.clone.call(this, t), t
    }, THREE.PointCloud = function(t, e) {
        THREE.Object3D.call(this), this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.PointCloudMaterial({
            color: 16777215 * Math.random()
        }), this.sortParticles = !1
    }, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.raycast = function() {
        var t = new THREE.Matrix4,
            e = new THREE.Ray;
        return function(r, n) {
            var i = this,
                o = i.geometry,
                a = r.params.PointCloud.threshold;
            if (t.getInverse(this.matrixWorld), e.copy(r.ray).applyMatrix4(t), null === o.boundingBox || e.isIntersectionBox(o.boundingBox) !== !1) {
                var s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    h = new THREE.Vector3,
                    u = function(t, o) {
                        var a = e.distanceToPoint(t);
                        if (s > a) {
                            var h = e.closestPointToPoint(t);
                            h.applyMatrix4(i.matrixWorld);
                            var u = r.ray.origin.distanceTo(h);
                            n.push({
                                distance: u,
                                distanceToRay: a,
                                point: h.clone(),
                                index: o,
                                face: null,
                                object: i
                            })
                        }
                    };
                if (o instanceof THREE.BufferGeometry) {
                    var l = o.attributes,
                        c = l.position.array;
                    if (void 0 !== l.index) {
                        var p = l.index.array,
                            f = o.offsets;
                        if (0 === f.length) {
                            var d = {
                                start: 0,
                                count: p.length,
                                index: 0
                            };
                            f = [d]
                        }
                        for (var m = 0, g = f.length; g > m; ++m)
                            for (var v = f[m].start, E = f[m].count, y = f[m].index, T = v, x = v + E; x > T; T++) {
                                var _ = y + p[T];
                                h.set(c[3 * _], c[3 * _ + 1], c[3 * _ + 2]), u(h, _)
                            }
                    } else
                        for (var b = c.length / 3, T = 0; b > T; T++) h.set(c[3 * T], c[3 * T + 1], c[3 * T + 2]), u(h, T)
                } else
                    for (var R = this.geometry.vertices, T = 0; T < R.length; T++) u(R[T], T)
            }
        }
    }(), THREE.PointCloud.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.PointCloud(this.geometry, this.material)), t.sortParticles = this.sortParticles, THREE.Object3D.prototype.clone.call(this, t), t
    }, THREE.ParticleSystem = function(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new THREE.PointCloud(t, e)
    }, THREE.Line = function(t, e, r) {
        THREE.Object3D.call(this), this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.LineBasicMaterial({
            color: 16777215 * Math.random()
        }), this.type = void 0 !== r ? r : THREE.LineStrip
    }, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.raycast = function() {
        var t = new THREE.Matrix4,
            e = new THREE.Ray,
            r = new THREE.Sphere;
        return function(n, i) {
            var o = n.linePrecision,
                a = o * o,
                s = this.geometry;
            if (null === s.boundingSphere && s.computeBoundingSphere(), r.copy(s.boundingSphere), r.applyMatrix4(this.matrixWorld), n.ray.isIntersectionSphere(r) !== !1 && (t.getInverse(this.matrixWorld), e.copy(n.ray).applyMatrix4(t), s instanceof THREE.Geometry))
                for (var h = s.vertices, u = h.length, l = new THREE.Vector3, c = new THREE.Vector3, p = this.type === THREE.LineStrip ? 1 : 2, f = 0; u - 1 > f; f += p) {
                    var d = e.distanceSqToSegment(h[f], h[f + 1], c, l);
                    if (!(d > a)) {
                        var m = e.origin.distanceTo(c);
                        m < n.near || m > n.far || i.push({
                            distance: m,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
        }
    }(), THREE.Line.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, t), t
    }, THREE.Mesh = function(t, e) {
        THREE.Object3D.call(this), this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.updateMorphTargets()
    }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.updateMorphTargets = function() {
        if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
            this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var t = 0, e = this.geometry.morphTargets.length; e > t; t++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t
        }
    }, THREE.Mesh.prototype.getMorphTargetIndexByName = function(t) {
        return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."), 0)
    }, THREE.Mesh.prototype.raycast = function() {
        var t = new THREE.Matrix4,
            e = new THREE.Ray,
            r = new THREE.Sphere,
            n = new THREE.Vector3,
            i = new THREE.Vector3,
            o = new THREE.Vector3;
        return function(a, s) {
            var h = this.geometry;
            if (null === h.boundingSphere && h.computeBoundingSphere(), r.copy(h.boundingSphere), r.applyMatrix4(this.matrixWorld), a.ray.isIntersectionSphere(r) !== !1 && (t.getInverse(this.matrixWorld), e.copy(a.ray).applyMatrix4(t), null === h.boundingBox || e.isIntersectionBox(h.boundingBox) !== !1))
                if (h instanceof THREE.BufferGeometry) {
                    var u = this.material;
                    if (void 0 === u) return;
                    var l, c, p, f = h.attributes,
                        d = a.precision;
                    if (void 0 !== f.index) {
                        var m = f.index.array,
                            g = f.position.array,
                            v = h.offsets;
                        0 === v.length && (v = [{
                            start: 0,
                            count: m.length,
                            index: 0
                        }]);
                        for (var E = 0, y = v.length; y > E; ++E)
                            for (var T = v[E].start, x = v[E].count, _ = v[E].index, b = T, R = T + x; R > b; b += 3) {
                                if (l = _ + m[b], c = _ + m[b + 1], p = _ + m[b + 2], n.set(g[3 * l], g[3 * l + 1], g[3 * l + 2]), i.set(g[3 * c], g[3 * c + 1], g[3 * c + 2]), o.set(g[3 * p], g[3 * p + 1], g[3 * p + 2]), u.side === THREE.BackSide) var w = e.intersectTriangle(o, i, n, !0);
                                else var w = e.intersectTriangle(n, i, o, u.side !== THREE.DoubleSide);
                                if (null !== w) {
                                    w.applyMatrix4(this.matrixWorld);
                                    var H = a.ray.origin.distanceTo(w);
                                    d > H || H < a.near || H > a.far || s.push({
                                        distance: H,
                                        point: w,
                                        indices: [l, c, p],
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    } else
                        for (var g = f.position.array, b = 0, M = 0, R = g.length; R > b; b += 3, M += 9) {
                            if (l = b, c = b + 1, p = b + 2, n.set(g[M], g[M + 1], g[M + 2]), i.set(g[M + 3], g[M + 4], g[M + 5]), o.set(g[M + 6], g[M + 7], g[M + 8]), u.side === THREE.BackSide) var w = e.intersectTriangle(o, i, n, !0);
                            else var w = e.intersectTriangle(n, i, o, u.side !== THREE.DoubleSide);
                            if (null !== w) {
                                w.applyMatrix4(this.matrixWorld);
                                var H = a.ray.origin.distanceTo(w);
                                d > H || H < a.near || H > a.far || s.push({
                                    distance: H,
                                    point: w,
                                    indices: [l, c, p],
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                } else if (h instanceof THREE.Geometry)
                for (var l, c, p, S = this.material instanceof THREE.MeshFaceMaterial, A = S === !0 ? this.material.materials : null, d = a.precision, C = h.vertices, k = 0, L = h.faces.length; L > k; k++) {
                    var z = h.faces[k],
                        u = S === !0 ? A[z.materialIndex] : this.material;
                    if (void 0 !== u) {
                        if (l = C[z.a], c = C[z.b], p = C[z.c], u.morphTargets === !0) {
                            var P = h.morphTargets,
                                D = this.morphTargetInfluences;
                            n.set(0, 0, 0), i.set(0, 0, 0), o.set(0, 0, 0);
                            for (var F = 0, U = P.length; U > F; F++) {
                                var O = D[F];
                                if (0 !== O) {
                                    var B = P[F].vertices;
                                    n.x += (B[z.a].x - l.x) * O, n.y += (B[z.a].y - l.y) * O, n.z += (B[z.a].z - l.z) * O, i.x += (B[z.b].x - c.x) * O, i.y += (B[z.b].y - c.y) * O, i.z += (B[z.b].z - c.z) * O, o.x += (B[z.c].x - p.x) * O, o.y += (B[z.c].y - p.y) * O, o.z += (B[z.c].z - p.z) * O
                                }
                            }
                            n.add(l), i.add(c), o.add(p), l = n, c = i, p = o
                        }
                        if (u.side === THREE.BackSide) var w = e.intersectTriangle(p, c, l, !0);
                        else var w = e.intersectTriangle(l, c, p, u.side !== THREE.DoubleSide);
                        if (null !== w) {
                            w.applyMatrix4(this.matrixWorld);
                            var H = a.ray.origin.distanceTo(w);
                            d > H || H < a.near || H > a.far || s.push({
                                distance: H,
                                point: w,
                                face: z,
                                faceIndex: k,
                                object: this
                            })
                        }
                    }
                }
        }
    }(), THREE.Mesh.prototype.clone = function(t, e) {
        return void 0 === t && (t = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, t, e), t
    }, THREE.Bone = function(t) {
        THREE.Object3D.call(this), this.skin = t, this.accumulatedRotWeight = 0, this.accumulatedPosWeight = 0, this.accumulatedSclWeight = 0
    }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.updateMatrixWorld = function(t) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, t), this.accumulatedRotWeight = 0, this.accumulatedPosWeight = 0, this.accumulatedSclWeight = 0
    }, THREE.Skeleton = function(t, e, r) {
        if (this.useVertexTexture = void 0 !== r ? r : !0, this.identityMatrix = new THREE.Matrix4, t = t || [], this.bones = t.slice(0), this.useVertexTexture) {
            var n;
            n = this.bones.length > 256 ? 64 : this.bones.length > 64 ? 32 : this.bones.length > 16 ? 16 : 8, this.boneTextureWidth = n, this.boneTextureHeight = n, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1
        } else this.boneMatrices = new Float32Array(16 * this.bones.length);
        if (void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, o = this.bones.length; o > i; i++) this.boneInverses.push(new THREE.Matrix4)
        }
    }, THREE.Skeleton.prototype.calculateInverses = function() {
        this.boneInverses = [];
        for (var t = 0, e = this.bones.length; e > t; t++) {
            var r = new THREE.Matrix4;
            this.bones[t] && r.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(r)
        }
    }, THREE.Skeleton.prototype.pose = function() {
        for (var t, e = 0, r = this.bones.length; r > e; e++) t = this.bones[e], t && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (var e = 0, r = this.bones.length; r > e; e++) t = this.bones[e], t && (t.parent ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
    }, THREE.Skeleton.prototype.update = function() {
        for (var t = new THREE.Matrix4, e = 0, r = this.bones.length; r > e; e++) {
            var n = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix;
            t.multiplyMatrices(n, this.boneInverses[e]), t.flattenToArrayOffset(this.boneMatrices, 16 * e)
        }
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
    }, THREE.SkinnedMesh = function(t, e, r) {
        THREE.Mesh.call(this, t, e), this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4;
        var n = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
            for (var i, o, a, s, h, u = 0, l = this.geometry.bones.length; l > u; ++u) o = this.geometry.bones[u], a = o.pos, s = o.rotq, h = o.scl, i = new THREE.Bone(this), n.push(i), i.name = o.name, i.position.set(a[0], a[1], a[2]), i.quaternion.set(s[0], s[1], s[2], s[3]), void 0 !== h ? i.scale.set(h[0], h[1], h[2]) : i.scale.set(1, 1, 1);
            for (var u = 0, l = this.geometry.bones.length; l > u; ++u) o = this.geometry.bones[u], -1 !== o.parent ? n[o.parent].add(n[u]) : this.add(n[u])
        }
        this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(n, void 0, r))
    }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.bind = function(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
    }, THREE.SkinnedMesh.prototype.pose = function() {
        this.skeleton.pose()
    }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
        if (this.geometry instanceof THREE.Geometry)
            for (var t = 0; t < this.geometry.skinIndices.length; t++) {
                var e = this.geometry.skinWeights[t],
                    r = 1 / e.lengthManhattan();
                1 / 0 !== r ? e.multiplyScalar(r) : e.set(1)
            }
    }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function() {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
    }, THREE.SkinnedMesh.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, t), t
    }, THREE.MorphAnimMesh = function(t, e) {
        THREE.Mesh.call(this, t, e), this.duration = 1e3, this.mirroredLoop = !1, this.time = 0, this.lastKeyframe = 0, this.currentKeyframe = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
    }, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.setFrameRange = function(t, e) {
        this.startKeyframe = t, this.endKeyframe = e, this.length = this.endKeyframe - this.startKeyframe + 1
    }, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
        this.direction = 1, this.directionBackwards = !1
    }, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
        this.direction = -1, this.directionBackwards = !0
    }, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
        var t = this.geometry;
        t.animations || (t.animations = {});
        for (var e, r = t.animations, n = /([a-z]+)_?(\d+)/, i = 0, o = t.morphTargets.length; o > i; i++) {
            var a = t.morphTargets[i],
                s = a.name.match(n);
            if (s && s.length > 1) {
                {
                    var h = s[1];
                    s[2]
                }
                r[h] || (r[h] = {
                    start: 1 / 0,
                    end: -1 / 0
                });
                var u = r[h];
                i < u.start && (u.start = i), i > u.end && (u.end = i), e || (e = h)
            }
        }
        t.firstAnimation = e
    }, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(t, e, r) {
        this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[t] = {
            start: e,
            end: r
        }
    }, THREE.MorphAnimMesh.prototype.playAnimation = function(t, e) {
        var r = this.geometry.animations[t];
        r ? (this.setFrameRange(r.start, r.end), this.duration = 1e3 * ((r.end - r.start) / e), this.time = 0) : console.warn("animation[" + t + "] undefined")
    }, THREE.MorphAnimMesh.prototype.updateAnimation = function(t) {
        var e = this.duration / this.length;
        this.time += this.direction * t, this.mirroredLoop ? (this.time > this.duration || this.time < 0) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), this.time < 0 && (this.time = 0, this.directionBackwards = !1)) : (this.time = this.time % this.duration, this.time < 0 && (this.time += this.duration));
        var r = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / e), 0, this.length - 1);
        r !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[r] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = r);
        var n = this.time % e / e;
        this.directionBackwards && (n = 1 - n), this.morphTargetInfluences[this.currentKeyframe] = n, this.morphTargetInfluences[this.lastKeyframe] = 1 - n
    }, THREE.MorphAnimMesh.prototype.interpolateTargets = function(t, e, r) {
        for (var n = this.morphTargetInfluences, i = 0, o = n.length; o > i; i++) n[i] = 0;
        t > -1 && (n[t] = 1 - r), e > -1 && (n[e] = r)
    }, THREE.MorphAnimMesh.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.MorphAnimMesh(this.geometry, this.material)), t.duration = this.duration, t.mirroredLoop = this.mirroredLoop, t.time = this.time, t.lastKeyframe = this.lastKeyframe, t.currentKeyframe = this.currentKeyframe, t.direction = this.direction, t.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, t), t
    }, THREE.LOD = function() {
        THREE.Object3D.call(this), this.objects = []
    }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.addLevel = function(t, e) {
        void 0 === e && (e = 0), e = Math.abs(e);
        for (var r = 0; r < this.objects.length && !(e < this.objects[r].distance); r++);
        this.objects.splice(r, 0, {
            distance: e,
            object: t
        }), this.add(t)
    }, THREE.LOD.prototype.getObjectForDistance = function(t) {
        for (var e = 1, r = this.objects.length; r > e && !(t < this.objects[e].distance); e++);
        return this.objects[e - 1].object
    }, THREE.LOD.prototype.raycast = function() {
        var t = new THREE.Vector3;
        return function(e, r) {
            t.setFromMatrixPosition(this.matrixWorld);
            var n = e.ray.origin.distanceTo(t);
            this.getObjectForDistance(n).raycast(e, r)
        }
    }(), THREE.LOD.prototype.update = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3;
        return function(r) {
            if (this.objects.length > 1) {
                t.setFromMatrixPosition(r.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                var n = t.distanceTo(e);
                this.objects[0].object.visible = !0;
                for (var i = 1, o = this.objects.length; o > i && n >= this.objects[i].distance; i++) this.objects[i - 1].object.visible = !1, this.objects[i].object.visible = !0;
                for (; o > i; i++) this.objects[i].object.visible = !1
            }
        }
    }(), THREE.LOD.prototype.clone = function(t) {
        void 0 === t && (t = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, t);
        for (var e = 0, r = this.objects.length; r > e; e++) {
            var n = this.objects[e].object.clone();
            n.visible = 0 === e, t.addLevel(n, this.objects[e].distance)
        }
        return t
    }, THREE.Sprite = function() {
        var t = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0]),
            e = new THREE.BufferGeometry;
        return e.addAttribute("position", new THREE.BufferAttribute(t, 3)),
            function(t) {
                THREE.Object3D.call(this), this.geometry = e, this.material = void 0 !== t ? t : new THREE.SpriteMaterial
            }
    }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.raycast = function() {
        var t = new THREE.Vector3;
        return function(e, r) {
            t.setFromMatrixPosition(this.matrixWorld);
            var n = e.ray.distanceToPoint(t);
            n > this.scale.x || r.push({
                distance: n,
                point: this.position,
                face: null,
                object: this
            })
        }
    }(), THREE.Sprite.prototype.updateMatrix = function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }, THREE.Sprite.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, t), t
    }, THREE.Particle = THREE.Sprite, THREE.Scene = function() {
        THREE.Object3D.call(this), this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, this.matrixAutoUpdate = !1, this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = []
    }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.__addObject = function(t) {
        if (t instanceof THREE.Light) - 1 === this.__lights.indexOf(t) && this.__lights.push(t), t.target && void 0 === t.target.parent && this.add(t.target);
        else if (!(t instanceof THREE.Camera || t instanceof THREE.Bone)) {
            this.__objectsAdded.push(t);
            var e = this.__objectsRemoved.indexOf(t); - 1 !== e && this.__objectsRemoved.splice(e, 1)
        }
        this.dispatchEvent({
            type: "objectAdded",
            object: t
        }), t.dispatchEvent({
            type: "addedToScene",
            scene: this
        });
        for (var r = 0; r < t.children.length; r++) this.__addObject(t.children[r])
    }, THREE.Scene.prototype.__removeObject = function(t) {
        if (t instanceof THREE.Light) {
            var e = this.__lights.indexOf(t);
            if (-1 !== e && this.__lights.splice(e, 1), t.shadowCascadeArray)
                for (var r = 0; r < t.shadowCascadeArray.length; r++) this.__removeObject(t.shadowCascadeArray[r])
        } else if (!(t instanceof THREE.Camera)) {
            this.__objectsRemoved.push(t);
            var e = this.__objectsAdded.indexOf(t); - 1 !== e && this.__objectsAdded.splice(e, 1)
        }
        this.dispatchEvent({
            type: "objectRemoved",
            object: t
        }), t.dispatchEvent({
            type: "removedFromScene",
            scene: this
        });
        for (var n = 0; n < t.children.length; n++) this.__removeObject(t.children[n])
    }, THREE.Scene.prototype.clone = function(t) {
        return void 0 === t && (t = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, t), null !== this.fog && (t.fog = this.fog.clone()), null !== this.overrideMaterial && (t.overrideMaterial = this.overrideMaterial.clone()), t.autoUpdate = this.autoUpdate, t.matrixAutoUpdate = this.matrixAutoUpdate, t
    }, THREE.Fog = function(t, e, r) {
        this.name = "", this.color = new THREE.Color(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== r ? r : 1e3
    }, THREE.Fog.prototype.clone = function() {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    }, THREE.FogExp2 = function(t, e) {
        this.name = "", this.color = new THREE.Color(t), this.density = void 0 !== e ? e : 25e-5
    }, THREE.FogExp2.prototype.clone = function() {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    }, THREE.CanvasRenderer = function(t) {
        function e() {
            Ee.setRGB(0, 0, 0), ye.setRGB(0, 0, 0), Te.setRGB(0, 0, 0);
            for (var t = 0, e = R.length; e > t; t++) {
                var r = R[t],
                    n = r.color;
                r instanceof THREE.AmbientLight ? Ee.add(n) : r instanceof THREE.DirectionalLight ? ye.add(n) : r instanceof THREE.PointLight && Te.add(n)
            }
        }

        function r(t, e, r) {
            for (var n = 0, i = R.length; i > n; n++) {
                var o = R[n];
                if (fe.copy(o.color), o instanceof THREE.DirectionalLight) {
                    var a = xe.setFromMatrixPosition(o.matrixWorld).normalize(),
                        s = e.dot(a);
                    if (0 >= s) continue;
                    s *= o.intensity, r.add(fe.multiplyScalar(s))
                } else if (o instanceof THREE.PointLight) {
                    var a = xe.setFromMatrixPosition(o.matrixWorld),
                        s = e.dot(xe.subVectors(a, t).normalize());
                    if (0 >= s) continue;
                    if (s *= 0 == o.distance ? 1 : 1 - Math.min(t.distanceTo(a) / o.distance, 1), 0 == s) continue;
                    s *= o.intensity, r.add(fe.multiplyScalar(s))
                }
            }
        }

        function n(t, e, r) {
            f(r.opacity), d(r.blending);
            var n = e.scale.x * q,
                i = e.scale.y * Y,
                o = .5 * Math.sqrt(n * n + i * i);
            if (ve.min.set(t.x - o, t.y - o), ve.max.set(t.x + o, t.y + o), r instanceof THREE.SpriteMaterial) {
                var a = r.map;
                if (null !== a && void 0 !== a.image) {
                    a.hasEventListener("update", u) === !1 && (a.image.width > 0 && l(a), a.addEventListener("update", u));
                    var s = de[a.id];
                    y(void 0 !== s ? s : "rgba( 0, 0, 0, 1 )");
                    var h = a.image,
                        c = h.width * a.offset.x,
                        p = h.height * a.offset.y,
                        m = h.width * a.repeat.x,
                        g = h.height * a.repeat.y,
                        v = n / m,
                        T = i / g;
                    $.save(), $.translate(t.x, t.y), 0 !== r.rotation && $.rotate(r.rotation), $.translate(-n / 2, -i / 2), $.scale(v, T), $.translate(-c, -p), $.fillRect(c, p, m, g), $.restore()
                } else y(r.color.getStyle()), $.save(), $.translate(t.x, t.y), 0 !== r.rotation && $.rotate(r.rotation), $.scale(n, -i), $.fillRect(-.5, -.5, 1, 1), $.restore()
            } else r instanceof THREE.SpriteCanvasMaterial && (E(r.color.getStyle()), y(r.color.getStyle()), $.save(), $.translate(t.x, t.y), 0 !== r.rotation && $.rotate(r.rotation), $.scale(n, i), r.program($), $.restore())
        }

        function i(t, e, r, n) {
            if (f(n.opacity), d(n.blending), $.beginPath(), $.moveTo(t.positionScreen.x, t.positionScreen.y), $.lineTo(e.positionScreen.x, e.positionScreen.y), n instanceof THREE.LineBasicMaterial) {
                if (m(n.linewidth), g(n.linecap), v(n.linejoin), n.vertexColors !== THREE.VertexColors) E(n.color.getStyle());
                else {
                    var i = r.vertexColors[0].getStyle(),
                        o = r.vertexColors[1].getStyle();
                    if (i === o) E(i);
                    else {
                        try {
                            var a = $.createLinearGradient(t.positionScreen.x, t.positionScreen.y, e.positionScreen.x, e.positionScreen.y);
                            a.addColorStop(0, i), a.addColorStop(1, o)
                        } catch (s) {
                            a = i
                        }
                        E(a)
                    }
                }
                $.stroke(), ve.expandByScalar(2 * n.linewidth)
            } else n instanceof THREE.LineDashedMaterial && (m(n.linewidth), g(n.linecap), v(n.linejoin), E(n.color.getStyle()), T([n.dashSize, n.gapSize]), $.stroke(), ve.expandByScalar(2 * n.linewidth), T([]))
        }

        function o(t, e, n, i, o, u, l, p) {
            j.info.render.vertices += 3, j.info.render.faces++, f(p.opacity), d(p.blending), A = t.positionScreen.x, C = t.positionScreen.y, k = e.positionScreen.x, L = e.positionScreen.y, z = n.positionScreen.x, P = n.positionScreen.y, a(A, C, k, L, z, P), (p instanceof THREE.MeshLambertMaterial || p instanceof THREE.MeshPhongMaterial) && null === p.map ? (ce.copy(p.color), pe.copy(p.emissive), p.vertexColors === THREE.FaceColors && ce.multiply(l.color), le.copy(Ee), _e.copy(t.positionWorld).add(e.positionWorld).add(n.positionWorld).divideScalar(3), r(_e, l.normalModel, le), le.multiply(ce).add(pe), p.wireframe === !0 ? s(le, p.wireframeLinewidth, p.wireframeLinecap, p.wireframeLinejoin) : h(le)) : p instanceof THREE.MeshBasicMaterial || p instanceof THREE.MeshLambertMaterial || p instanceof THREE.MeshPhongMaterial ? null !== p.map ? p.map.mapping instanceof THREE.UVMapping && (D = l.uvs, c(A, C, k, L, z, P, D[i].x, D[i].y, D[o].x, D[o].y, D[u].x, D[u].y, p.map)) : null !== p.envMap ? p.envMap.mapping instanceof THREE.SphericalReflectionMapping ? (be.copy(l.vertexNormalsModel[i]).applyMatrix3(Re), F = .5 * be.x + .5, U = .5 * be.y + .5, be.copy(l.vertexNormalsModel[o]).applyMatrix3(Re), O = .5 * be.x + .5, B = .5 * be.y + .5, be.copy(l.vertexNormalsModel[u]).applyMatrix3(Re), V = .5 * be.x + .5, N = .5 * be.y + .5, c(A, C, k, L, z, P, F, U, O, B, V, N, p.envMap)) : p.envMap.mapping instanceof THREE.SphericalRefractionMapping && (be.copy(l.vertexNormalsModel[i]).applyMatrix3(Re), F = -.5 * be.x + .5, U = -.5 * be.y + .5, be.copy(l.vertexNormalsModel[o]).applyMatrix3(Re), O = -.5 * be.x + .5, B = -.5 * be.y + .5, be.copy(l.vertexNormalsModel[u]).applyMatrix3(Re), V = -.5 * be.x + .5, N = -.5 * be.y + .5, c(A, C, k, L, z, P, F, U, O, B, V, N, p.envMap)) : (le.copy(p.color), p.vertexColors === THREE.FaceColors && le.multiply(l.color), p.wireframe === !0 ? s(le, p.wireframeLinewidth, p.wireframeLinecap, p.wireframeLinejoin) : h(le)) : p instanceof THREE.MeshDepthMaterial ? (le.r = le.g = le.b = 1 - x(t.positionScreen.z * t.positionScreen.w, w.near, w.far), p.wireframe === !0 ? s(le, p.wireframeLinewidth, p.wireframeLinecap, p.wireframeLinejoin) : h(le)) : p instanceof THREE.MeshNormalMaterial ? (be.copy(l.normalModel).applyMatrix3(Re), le.setRGB(be.x, be.y, be.z).multiplyScalar(.5).addScalar(.5), p.wireframe === !0 ? s(le, p.wireframeLinewidth, p.wireframeLinecap, p.wireframeLinejoin) : h(le)) : (le.setRGB(1, 1, 1), p.wireframe === !0 ? s(le, p.wireframeLinewidth, p.wireframeLinecap, p.wireframeLinejoin) : h(le))
        }

        function a(t, e, r, n, i, o) {
            $.beginPath(), $.moveTo(t, e), $.lineTo(r, n), $.lineTo(i, o), $.closePath()
        }

        function s(t, e, r, n) {
            m(e), g(r), v(n), E(t.getStyle()), $.stroke(), ve.expandByScalar(2 * e)
        }

        function h(t) {
            y(t.getStyle()), $.fill()
        }

        function u(t) {
            l(t.target)
        }

        function l(t) {
            if (!(t instanceof THREE.CompressedTexture)) {
                var e = t.wrapS === THREE.RepeatWrapping,
                    r = t.wrapT === THREE.RepeatWrapping,
                    n = t.image,
                    i = document.createElement("canvas");
                i.width = n.width, i.height = n.height;
                var o = i.getContext("2d");
                o.setTransform(1, 0, 0, -1, 0, n.height), o.drawImage(n, 0, 0), de[t.id] = $.createPattern(i, e === !0 && r === !0 ? "repeat" : e === !0 && r === !1 ? "repeat-x" : e === !1 && r === !0 ? "repeat-y" : "no-repeat")
            }
        }

        function c(t, e, r, n, i, o, a, s, h, c, p, f, d) {
            if (!(d instanceof THREE.DataTexture)) {
                d.hasEventListener("update", u) === !1 && (void 0 !== d.image && d.image.width > 0 && l(d), d.addEventListener("update", u));
                var m = de[d.id];
                if (void 0 === m) return y("rgba(0,0,0,1)"), void $.fill();
                y(m);
                var g, v, E, T, x, _, b, R, w = d.offset.x / d.repeat.x,
                    H = d.offset.y / d.repeat.y,
                    M = d.image.width * d.repeat.x,
                    S = d.image.height * d.repeat.y;
                a = (a + w) * M, s = (s + H) * S, h = (h + w) * M, c = (c + H) * S, p = (p + w) * M, f = (f + H) * S, r -= t, n -= e, i -= t, o -= e, h -= a, c -= s, p -= a, f -= s, b = h * f - p * c, 0 !== b && (R = 1 / b, g = (f * r - c * i) * R, v = (f * n - c * o) * R, E = (h * i - p * r) * R, T = (h * o - p * n) * R, x = t - g * a - E * s, _ = e - v * a - T * s, $.save(), $.transform(g, v, E, T, x, _), $.fill(), $.restore())
            }
        }

        function p(t, e, r) {
            var n, i = e.x - t.x,
                o = e.y - t.y,
                a = i * i + o * o;
            0 !== a && (n = r / Math.sqrt(a), i *= n, o *= n, e.x += i, e.y += o, t.x -= i, t.y -= o)
        }

        function f(t) {
            re !== t && ($.globalAlpha = t, re = t)
        }

        function d(t) {
            ne !== t && (t === THREE.NormalBlending ? $.globalCompositeOperation = "source-over" : t === THREE.AdditiveBlending ? $.globalCompositeOperation = "lighter" : t === THREE.SubtractiveBlending && ($.globalCompositeOperation = "darker"), ne = t)
        }

        function m(t) {
            ae !== t && ($.lineWidth = t, ae = t)
        }

        function g(t) {
            se !== t && ($.lineCap = t, se = t)
        }

        function v(t) {
            he !== t && ($.lineJoin = t, he = t)
        }

        function E(t) {
            ie !== t && ($.strokeStyle = t, ie = t)
        }

        function y(t) {
            oe !== t && ($.fillStyle = t, oe = t)
        }

        function T(t) {
            ue.length !== t.length && ($.setLineDash(t), ue = t)
        }
        console.log("THREE.CanvasRenderer", THREE.REVISION);
        var x = THREE.Math.smoothstep;
        t = t || {};
        var _, b, R, w, H, M, S, A, C, k, L, z, P, D, F, U, O, B, V, N, j = this,
            I = new THREE.Projector,
            G = void 0 !== t.canvas ? t.canvas : document.createElement("canvas"),
            W = G.width,
            X = G.height,
            q = Math.floor(W / 2),
            Y = Math.floor(X / 2),
            K = 0,
            Z = 0,
            Q = W,
            J = X,
            $ = G.getContext("2d", {
                alpha: t.alpha === !0
            }),
            te = new THREE.Color(0),
            ee = 0,
            re = 1,
            ne = 0,
            ie = null,
            oe = null,
            ae = null,
            se = null,
            he = null,
            ue = [],
            le = (new THREE.RenderableVertex, new THREE.RenderableVertex, new THREE.Color),
            ce = (new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color),
            pe = new THREE.Color,
            fe = new THREE.Color,
            de = {},
            me = new THREE.Box2,
            ge = new THREE.Box2,
            ve = new THREE.Box2,
            Ee = new THREE.Color,
            ye = new THREE.Color,
            Te = new THREE.Color,
            xe = new THREE.Vector3,
            _e = new THREE.Vector3,
            be = new THREE.Vector3,
            Re = new THREE.Matrix3;
        void 0 === $.setLineDash && ($.setLineDash = function() {}), this.domElement = G, this.devicePixelRatio = void 0 !== t.devicePixelRatio ? t.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.autoClear = !0, this.sortObjects = !0, this.sortElements = !0, this.info = {
            render: {
                vertices: 0,
                faces: 0
            }
        }, this.supportsVertexTextures = function() {}, this.setFaceCulling = function() {}, this.setSize = function(t, e, r) {
            W = t * this.devicePixelRatio, X = e * this.devicePixelRatio, G.width = W, G.height = X, q = Math.floor(W / 2), Y = Math.floor(X / 2), r !== !1 && (G.style.width = t + "px", G.style.height = e + "px"), me.min.set(-q, -Y), me.max.set(q, Y), ge.min.set(-q, -Y), ge.max.set(q, Y), re = 1, ne = 0, ie = null, oe = null, ae = null, se = null, he = null, this.setViewport(0, 0, t, e)
        }, this.setViewport = function(t, e, r, n) {
            K = t * this.devicePixelRatio, Z = e * this.devicePixelRatio, Q = r * this.devicePixelRatio, J = n * this.devicePixelRatio
        }, this.setScissor = function() {}, this.enableScissorTest = function() {}, this.setClearColor = function(t, e) {
            te.set(t), ee = void 0 !== e ? e : 1, ge.min.set(-q, -Y), ge.max.set(q, Y)
        }, this.setClearColorHex = function(t, e) {
            console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(t, e)
        }, this.getClearColor = function() {
            return te
        }, this.getClearAlpha = function() {
            return ee
        }, this.getMaxAnisotropy = function() {
            return 0
        }, this.clear = function() {
            ge.empty() === !1 && (ge.intersect(me), ge.expandByScalar(2), ge.min.x = ge.min.x + q, ge.min.y = -ge.min.y + Y, ge.max.x = ge.max.x + q, ge.max.y = -ge.max.y + Y, 1 > ee && $.clearRect(0 | ge.min.x, 0 | ge.min.y, ge.max.x - ge.min.x | 0, ge.max.y - ge.min.y | 0), ee > 0 && (d(THREE.NormalBlending), f(1), y("rgba(" + Math.floor(255 * te.r) + "," + Math.floor(255 * te.g) + "," + Math.floor(255 * te.b) + "," + ee + ")"), $.fillRect(0 | ge.min.x, 0 | ge.min.y, ge.max.x - ge.min.x | 0, ge.max.y - ge.min.y | 0)), ge.makeEmpty())
        }, this.clearColor = function() {}, this.clearDepth = function() {}, this.clearStencil = function() {}, this.render = function(t, r) {
            if (r instanceof THREE.Camera == !1) return void console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
            this.autoClear === !0 && this.clear(), j.info.render.vertices = 0, j.info.render.faces = 0, $.setTransform(Q / W, 0, 0, -J / X, K, X - Z), $.translate(q, Y), _ = I.projectScene(t, r, this.sortObjects, this.sortElements), b = _.elements, R = _.lights, w = r, Re.getNormalMatrix(r.matrixWorldInverse), e();
            for (var a = 0, s = b.length; s > a; a++) {
                var h = b[a],
                    u = h.material;
                if (void 0 !== u && 0 !== u.opacity) {
                    if (ve.makeEmpty(), h instanceof THREE.RenderableSprite) H = h, H.x *= q, H.y *= Y, n(H, h, u);
                    else if (h instanceof THREE.RenderableLine) H = h.v1, M = h.v2, H.positionScreen.x *= q, H.positionScreen.y *= Y, M.positionScreen.x *= q, M.positionScreen.y *= Y, ve.setFromPoints([H.positionScreen, M.positionScreen]), me.isIntersectionBox(ve) === !0 && i(H, M, h, u);
                    else if (h instanceof THREE.RenderableFace) {
                        if (H = h.v1, M = h.v2, S = h.v3, H.positionScreen.z < -1 || H.positionScreen.z > 1) continue;
                        if (M.positionScreen.z < -1 || M.positionScreen.z > 1) continue;
                        if (S.positionScreen.z < -1 || S.positionScreen.z > 1) continue;
                        H.positionScreen.x *= q, H.positionScreen.y *= Y, M.positionScreen.x *= q, M.positionScreen.y *= Y, S.positionScreen.x *= q, S.positionScreen.y *= Y, u.overdraw > 0 && (p(H.positionScreen, M.positionScreen, u.overdraw), p(M.positionScreen, S.positionScreen, u.overdraw), p(S.positionScreen, H.positionScreen, u.overdraw)), ve.setFromPoints([H.positionScreen, M.positionScreen, S.positionScreen]), me.isIntersectionBox(ve) === !0 && o(H, M, S, 0, 1, 2, h, u)
                    }
                    ge.union(ve)
                }
            }
            $.setTransform(1, 0, 0, 1, 0, 0)
        }
    }, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.default_vertex = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif", THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif", THREE.ShaderChunk.defaultnormal_vertex = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", THREE.UniformsUtils = {
        merge: function(t) {
            var e, r, n, i = {};
            for (e = 0; e < t.length; e++) {
                n = this.clone(t[e]);
                for (r in n) i[r] = n[r]
            }
            return i
        },
        clone: function(t) {
            var e, r, n, i = {};
            for (e in t) {
                i[e] = {};
                for (r in t[e]) n = t[e][r], i[e][r] = n instanceof THREE.Color || n instanceof THREE.Vector2 || n instanceof THREE.Vector3 || n instanceof THREE.Vector4 || n instanceof THREE.Matrix4 || n instanceof THREE.Texture ? n.clone() : n instanceof Array ? n.slice() : n
            }
            return i
        }
    }, THREE.UniformsLib = {
        common: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            lightMap: {
                type: "t",
                value: null
            },
            specularMap: {
                type: "t",
                value: null
            },
            alphaMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            useRefract: {
                type: "i",
                value: 0
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            },
            combine: {
                type: "i",
                value: 0
            },
            morphTargetInfluences: {
                type: "f",
                value: 0
            }
        },
        bump: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                type: "fv",
                value: []
            },
            directionalLightDirection: {
                type: "fv",
                value: []
            },
            directionalLightColor: {
                type: "fv",
                value: []
            },
            hemisphereLightDirection: {
                type: "fv",
                value: []
            },
            hemisphereLightSkyColor: {
                type: "fv",
                value: []
            },
            hemisphereLightGroundColor: {
                type: "fv",
                value: []
            },
            pointLightColor: {
                type: "fv",
                value: []
            },
            pointLightPosition: {
                type: "fv",
                value: []
            },
            pointLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightColor: {
                type: "fv",
                value: []
            },
            spotLightPosition: {
                type: "fv",
                value: []
            },
            spotLightDirection: {
                type: "fv",
                value: []
            },
            spotLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightAngleCos: {
                type: "fv1",
                value: []
            },
            spotLightExponent: {
                type: "fv1",
                value: []
            }
        },
        particle: {
            psColor: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        shadowmap: {
            shadowMap: {
                type: "tv",
                value: []
            },
            shadowMapSize: {
                type: "v2v",
                value: []
            },
            shadowBias: {
                type: "fv1",
                value: []
            },
            shadowDarkness: {
                type: "fv1",
                value: []
            },
            shadowMatrix: {
                type: "m4v",
                value: []
            }
        }
    }, THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
            vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			gl_FragColor.xyz *= vLightFront;", "		else", "			gl_FragColor.xyz *= vLightBack;", "	#else", "		gl_FragColor.xyz *= vLightFront;", "	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "varying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 ambient;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        particle_basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        normalmap: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                enableAO: {
                    type: "i",
                    value: 0
                },
                enableDiffuse: {
                    type: "i",
                    value: 0
                },
                enableSpecular: {
                    type: "i",
                    value: 0
                },
                enableReflection: {
                    type: "i",
                    value: 0
                },
                enableDisplacement: {
                    type: "i",
                    value: 0
                },
                tDisplacement: {
                    type: "t",
                    value: null
                },
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tCube: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                tSpecular: {
                    type: "t",
                    value: null
                },
                tAO: {
                    type: "t",
                    value: null
                },
                uNormalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                uDisplacementBias: {
                    type: "f",
                    value: 0
                },
                uDisplacementScale: {
                    type: "f",
                    value: 1
                },
                diffuse: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                useRefract: {
                    type: "i",
                    value: 0
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                },
                reflectivity: {
                    type: "f",
                    value: .5
                },
                uOffset: {
                    type: "v2",
                    value: new THREE.Vector2(0, 0)
                },
                uRepeat: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            fragmentShader: ["uniform vec3 ambient;", "uniform vec3 diffuse;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", "uniform bool enableDiffuse;", "uniform bool enableSpecular;", "uniform bool enableAO;", "uniform bool enableReflection;", "uniform sampler2D tDiffuse;", "uniform sampler2D tNormal;", "uniform sampler2D tSpecular;", "uniform sampler2D tAO;", "uniform samplerCube tCube;", "uniform vec2 uNormalScale;", "uniform bool useRefract;", "uniform float refractionRatio;", "uniform float reflectivity;", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "#endif", "#ifdef WRAP_AROUND", "	uniform vec3 wrapRGB;", "#endif", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	gl_FragColor = vec4( vec3( 1.0 ), opacity );", "	vec3 specularTex = vec3( 1.0 );", "	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;", "	normalTex.xy *= uNormalScale;", "	normalTex = normalize( normalTex );", "	if( enableDiffuse ) {", "		#ifdef GAMMA_INPUT", "			vec4 texelColor = texture2D( tDiffuse, vUv );", "			texelColor.xyz *= texelColor.xyz;", "			gl_FragColor = gl_FragColor * texelColor;", "		#else", "			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );", "		#endif", "	}", "	if( enableAO ) {", "		#ifdef GAMMA_INPUT", "			vec4 aoColor = texture2D( tAO, vUv );", "			aoColor.xyz *= aoColor.xyz;", "			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;", "		#else", "			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;", "		#endif", "	}", THREE.ShaderChunk.alphatest_fragment, "	if( enableSpecular )", "		specularTex = texture2D( tSpecular, vUv ).xyz;", "	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );", "	vec3 finalNormal = tsb * normalTex;", "	#ifdef FLIP_SIDED", "		finalNormal = -finalNormal;", "	#endif", "	vec3 normal = normalize( finalNormal );", "	vec3 viewPosition = normalize( vViewPosition );", "	#if MAX_POINT_LIGHTS > 0", "		vec3 pointDiffuse = vec3( 0.0 );", "		vec3 pointSpecular = vec3( 0.0 );", "		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;", "			float pointDistance = 1.0;", "			if ( pointLightDistance[ i ] > 0.0 )", "				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );", "			pointVector = normalize( pointVector );", "			#ifdef WRAP_AROUND", "				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );", "				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );", "				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );", "			#else", "				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );", "			#endif", "			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;", "			vec3 pointHalfVector = normalize( pointVector + viewPosition );", "			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );", "			float specularNormalization = ( shininess + 2.0 ) / 8.0;", "			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );", "			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;", "		}", "	#endif", "	#if MAX_SPOT_LIGHTS > 0", "		vec3 spotDiffuse = vec3( 0.0 );", "		vec3 spotSpecular = vec3( 0.0 );", "		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;", "			float spotDistance = 1.0;", "			if ( spotLightDistance[ i ] > 0.0 )", "				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );", "			spotVector = normalize( spotVector );", "			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );", "			if ( spotEffect > spotLightAngleCos[ i ] ) {", "				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );", "				#ifdef WRAP_AROUND", "					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );", "					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );", "					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );", "				#else", "					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );", "				#endif", "				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;", "				vec3 spotHalfVector = normalize( spotVector + viewPosition );", "				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );", "				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );", "				float specularNormalization = ( shininess + 2.0 ) / 8.0;", "				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );", "				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;", "			}", "		}", "	#endif", "	#if MAX_DIR_LIGHTS > 0", "		vec3 dirDiffuse = vec3( 0.0 );", "		vec3 dirSpecular = vec3( 0.0 );", "		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {", "			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "			vec3 dirVector = normalize( lDirection.xyz );", "			#ifdef WRAP_AROUND", "				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );", "				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );", "				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );", "			#else", "				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );", "			#endif", "			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;", "			vec3 dirHalfVector = normalize( dirVector + viewPosition );", "			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );", "			float specularNormalization = ( shininess + 2.0 ) / 8.0;", "			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );", "			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;", "		}", "	#endif", "	#if MAX_HEMI_LIGHTS > 0", "		vec3 hemiDiffuse = vec3( 0.0 );", "		vec3 hemiSpecular = vec3( 0.0 );", "		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "			vec3 lVector = normalize( lDirection.xyz );", "			float dotProduct = dot( normal, lVector );", "			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "			hemiDiffuse += diffuse * hemiColor;", "			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );", "			vec3 lVectorGround = -lVector;", "			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );", "			float dotProductGround = dot( normal, lVectorGround );", "			float specularNormalization = ( shininess + 2.0 ) / 8.0;", "			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );", "			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );", "			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );", "		}", "	#endif", "	vec3 totalDiffuse = vec3( 0.0 );", "	vec3 totalSpecular = vec3( 0.0 );", "	#if MAX_DIR_LIGHTS > 0", "		totalDiffuse += dirDiffuse;", "		totalSpecular += dirSpecular;", "	#endif", "	#if MAX_HEMI_LIGHTS > 0", "		totalDiffuse += hemiDiffuse;", "		totalSpecular += hemiSpecular;", "	#endif", "	#if MAX_POINT_LIGHTS > 0", "		totalDiffuse += pointDiffuse;", "		totalSpecular += pointSpecular;", "	#endif", "	#if MAX_SPOT_LIGHTS > 0", "		totalDiffuse += spotDiffuse;", "		totalSpecular += spotSpecular;", "	#endif", "	#ifdef METAL", "		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );", "	#else", "		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;", "	#endif", "	if ( enableReflection ) {", "		vec3 vReflect;", "		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "		if ( useRefract ) {", "			vReflect = refract( cameraToVertex, normal, refractionRatio );", "		} else {", "			vReflect = reflect( cameraToVertex, normal );", "		}", "		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "		#ifdef GAMMA_INPUT", "			cubeColor.xyz *= cubeColor.xyz;", "		#endif", "		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );", "	}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
            vertexShader: ["attribute vec4 tangent;", "uniform vec2 uOffset;", "uniform vec2 uRepeat;", "uniform bool enableDisplacement;", "#ifdef VERTEX_TEXTURES", "	uniform sampler2D tDisplacement;", "	uniform float uDisplacementScale;", "	uniform float uDisplacementBias;", "#endif", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "	#ifdef USE_SKINNING", "		vNormal = normalize( normalMatrix * skinnedNormal.xyz );", "		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );", "		vTangent = normalize( normalMatrix * skinnedTangent.xyz );", "	#else", "		vNormal = normalize( normalMatrix * normal );", "		vTangent = normalize( normalMatrix * tangent.xyz );", "	#endif", "	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );", "	vUv = uv * uRepeat + uOffset;", "	vec3 displacedPosition;", "	#ifdef VERTEX_TEXTURES", "		if ( enableDisplacement ) {", "			vec3 dv = texture2D( tDisplacement, uv ).xyz;", "			float df = uDisplacementScale * dv.x + uDisplacementBias;", "			displacedPosition = position + normalize( normal ) * df;", "		} else {", "			#ifdef USE_SKINNING", "				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );", "				vec4 skinned = vec4( 0.0 );", "				skinned += boneMatX * skinVertex * skinWeight.x;", "				skinned += boneMatY * skinVertex * skinWeight.y;", "				skinned += boneMatZ * skinVertex * skinWeight.z;", "				skinned += boneMatW * skinVertex * skinWeight.w;", "				skinned  = bindMatrixInverse * skinned;", "				displacedPosition = skinned.xyz;", "			#else", "				displacedPosition = position;", "			#endif", "		}", "	#else", "		#ifdef USE_SKINNING", "			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );", "			vec4 skinned = vec4( 0.0 );", "			skinned += boneMatX * skinVertex * skinWeight.x;", "			skinned += boneMatY * skinVertex * skinWeight.y;", "			skinned += boneMatZ * skinVertex * skinWeight.z;", "			skinned += boneMatW * skinVertex * skinWeight.w;", "			skinned  = bindMatrixInverse * skinned;", "			displacedPosition = skinned.xyz;", "		#else", "			displacedPosition = position;", "		#endif", "	#endif", "	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );", "	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "	vWorldPosition = worldPosition.xyz;", "	vViewPosition = -mvPosition.xyz;", "	#ifdef USE_SHADOWMAP", "		for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "		}", "	#endif", "}"].join("\n")
        },
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vWorldPosition = worldPosition.xyz;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: [THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
        }
    }, THREE.WebGLRenderer = function(t) {
        function e(t) {
            t.__webglVertexBuffer = Fe.createBuffer(), t.__webglColorBuffer = Fe.createBuffer(), Ge.info.memory.geometries++
        }

        function r(t) {
            t.__webglVertexBuffer = Fe.createBuffer(), t.__webglColorBuffer = Fe.createBuffer(), t.__webglLineDistanceBuffer = Fe.createBuffer(), Ge.info.memory.geometries++
        }

        function n(t) {
            t.__webglVertexBuffer = Fe.createBuffer(), t.__webglNormalBuffer = Fe.createBuffer(), t.__webglTangentBuffer = Fe.createBuffer(), t.__webglColorBuffer = Fe.createBuffer(), t.__webglUVBuffer = Fe.createBuffer(), t.__webglUV2Buffer = Fe.createBuffer(), t.__webglSkinIndicesBuffer = Fe.createBuffer(), t.__webglSkinWeightsBuffer = Fe.createBuffer(), t.__webglFaceBuffer = Fe.createBuffer(), t.__webglLineBuffer = Fe.createBuffer();
            var e, r;
            if (t.numMorphTargets)
                for (t.__webglMorphTargetsBuffers = [], e = 0, r = t.numMorphTargets; r > e; e++) t.__webglMorphTargetsBuffers.push(Fe.createBuffer());
            if (t.numMorphNormals)
                for (t.__webglMorphNormalsBuffers = [], e = 0, r = t.numMorphNormals; r > e; e++) t.__webglMorphNormalsBuffers.push(Fe.createBuffer());
            Ge.info.memory.geometries++
        }

        function i(t, e) {
            var r = t.vertices.length,
                n = e.material;
            if (n.attributes) {
                void 0 === t.__webglCustomAttributesList && (t.__webglCustomAttributesList = []);
                for (var i in n.attributes) {
                    var o = n.attributes[i];
                    if (!o.__webglInitialized || o.createUniqueBuffers) {
                        o.__webglInitialized = !0;
                        var a = 1;
                        "v2" === o.type ? a = 2 : "v3" === o.type ? a = 3 : "v4" === o.type ? a = 4 : "c" === o.type && (a = 3), o.size = a, o.array = new Float32Array(r * a), o.buffer = Fe.createBuffer(), o.buffer.belongsToAttribute = i, o.needsUpdate = !0
                    }
                    t.__webglCustomAttributesList.push(o)
                }
            }
        }

        function o(t, e) {
            var r = t.vertices.length;
            t.__vertexArray = new Float32Array(3 * r), t.__colorArray = new Float32Array(3 * r), t.__sortArray = [], t.__webglParticleCount = r, i(t, e)
        }

        function a(t, e) {
            var r = t.vertices.length;
            t.__vertexArray = new Float32Array(3 * r), t.__colorArray = new Float32Array(3 * r), t.__lineDistanceArray = new Float32Array(1 * r), t.__webglLineCount = r, i(t, e)
        }

        function s(t, e) {
            var r = e.geometry,
                n = t.faces3,
                i = 3 * n.length,
                o = 1 * n.length,
                a = 3 * n.length,
                s = h(e, t),
                u = p(s),
                f = l(s),
                d = c(s);
            t.__vertexArray = new Float32Array(3 * i), f && (t.__normalArray = new Float32Array(3 * i)), r.hasTangents && (t.__tangentArray = new Float32Array(4 * i)), d && (t.__colorArray = new Float32Array(3 * i)), u && (r.faceVertexUvs.length > 0 && (t.__uvArray = new Float32Array(2 * i)), r.faceVertexUvs.length > 1 && (t.__uv2Array = new Float32Array(2 * i))), e.geometry.skinWeights.length && e.geometry.skinIndices.length && (t.__skinIndexArray = new Float32Array(4 * i), t.__skinWeightArray = new Float32Array(4 * i));
            var m = null !== je && o > 21845 ? Uint32Array : Uint16Array;
            t.__typeArray = m, t.__faceArray = new m(3 * o), t.__lineArray = new m(2 * a);
            var g, v;
            if (t.numMorphTargets)
                for (t.__morphTargetsArrays = [], g = 0, v = t.numMorphTargets; v > g; g++) t.__morphTargetsArrays.push(new Float32Array(3 * i));
            if (t.numMorphNormals)
                for (t.__morphNormalsArrays = [], g = 0, v = t.numMorphNormals; v > g; g++) t.__morphNormalsArrays.push(new Float32Array(3 * i));
            if (t.__webglFaceCount = 3 * o, t.__webglLineCount = 2 * a, s.attributes) {
                void 0 === t.__webglCustomAttributesList && (t.__webglCustomAttributesList = []);
                for (var E in s.attributes) {
                    var y = s.attributes[E],
                        T = {};
                    for (var x in y) T[x] = y[x];
                    if (!T.__webglInitialized || T.createUniqueBuffers) {
                        T.__webglInitialized = !0;
                        var _ = 1;
                        "v2" === T.type ? _ = 2 : "v3" === T.type ? _ = 3 : "v4" === T.type ? _ = 4 : "c" === T.type && (_ = 3), T.size = _, T.array = new Float32Array(i * _), T.buffer = Fe.createBuffer(), T.buffer.belongsToAttribute = E, y.needsUpdate = !0, T.__original = y
                    }
                    t.__webglCustomAttributesList.push(T)
                }
            }
            t.__inittedArrays = !0
        }

        function h(t, e) {
            return t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[e.materialIndex] : t.material
        }

        function u(t) {
            return t && void 0 !== t.shading && t.shading === THREE.SmoothShading
        }

        function l(t) {
            return t instanceof THREE.MeshBasicMaterial && !t.envMap || t instanceof THREE.MeshDepthMaterial ? !1 : u(t) ? THREE.SmoothShading : THREE.FlatShading
        }

        function c(t) {
            return t.vertexColors ? t.vertexColors : !1
        }

        function p(t) {
            return t.map || t.lightMap || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t instanceof THREE.ShaderMaterial ? !0 : !1
        }

        function f(t) {
            for (var e in t.attributes) {
                var r = "index" === e ? Fe.ELEMENT_ARRAY_BUFFER : Fe.ARRAY_BUFFER,
                    n = t.attributes[e];
                n.buffer = Fe.createBuffer(), Fe.bindBuffer(r, n.buffer), Fe.bufferData(r, n.array, Fe.STATIC_DRAW)
            }
        }

        function d(t, e, r) {
            var n, i, o, a, s, h, u, l, c, p, f, d, m = t.vertices,
                g = m.length,
                v = t.colors,
                E = v.length,
                y = t.__vertexArray,
                T = t.__colorArray,
                x = t.__sortArray,
                _ = t.verticesNeedUpdate,
                b = (t.elementsNeedUpdate, t.colorsNeedUpdate),
                R = t.__webglCustomAttributesList;
            if (r.sortParticles) {
                for (Tr.copy(yr), Tr.multiply(r.matrixWorld), n = 0; g > n; n++) o = m[n], xr.copy(o), xr.applyProjection(Tr), x[n] = [xr.z, n];
                for (x.sort(w), n = 0; g > n; n++) o = m[x[n][1]], a = 3 * n, y[a] = o.x, y[a + 1] = o.y, y[a + 2] = o.z;
                for (i = 0; E > i; i++) a = 3 * i, h = v[x[i][1]], T[a] = h.r, T[a + 1] = h.g, T[a + 2] = h.b;
                if (R)
                    for (u = 0, l = R.length; l > u; u++)
                        if (d = R[u], void 0 === d.boundTo || "vertices" === d.boundTo)
                            if (a = 0, p = d.value.length, 1 === d.size)
                                for (c = 0; p > c; c++) s = x[c][1], d.array[c] = d.value[s];
                            else if (2 === d.size)
                    for (c = 0; p > c; c++) s = x[c][1], f = d.value[s], d.array[a] = f.x, d.array[a + 1] = f.y, a += 2;
                else if (3 === d.size)
                    if ("c" === d.type)
                        for (c = 0; p > c; c++) s = x[c][1], f = d.value[s], d.array[a] = f.r, d.array[a + 1] = f.g, d.array[a + 2] = f.b, a += 3;
                    else
                        for (c = 0; p > c; c++) s = x[c][1], f = d.value[s], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, a += 3;
                else if (4 === d.size)
                    for (c = 0; p > c; c++) s = x[c][1], f = d.value[s], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, d.array[a + 3] = f.w, a += 4
            } else {
                if (_)
                    for (n = 0; g > n; n++) o = m[n], a = 3 * n, y[a] = o.x, y[a + 1] = o.y, y[a + 2] = o.z;
                if (b)
                    for (i = 0; E > i; i++) h = v[i], a = 3 * i, T[a] = h.r, T[a + 1] = h.g, T[a + 2] = h.b;
                if (R)
                    for (u = 0, l = R.length; l > u; u++)
                        if (d = R[u], d.needsUpdate && (void 0 === d.boundTo || "vertices" === d.boundTo))
                            if (p = d.value.length, a = 0, 1 === d.size)
                                for (c = 0; p > c; c++) d.array[c] = d.value[c];
                            else if (2 === d.size)
                    for (c = 0; p > c; c++) f = d.value[c], d.array[a] = f.x, d.array[a + 1] = f.y, a += 2;
                else if (3 === d.size)
                    if ("c" === d.type)
                        for (c = 0; p > c; c++) f = d.value[c], d.array[a] = f.r, d.array[a + 1] = f.g, d.array[a + 2] = f.b, a += 3;
                    else
                        for (c = 0; p > c; c++) f = d.value[c], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, a += 3;
                else if (4 === d.size)
                    for (c = 0; p > c; c++) f = d.value[c], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, d.array[a + 3] = f.w, a += 4
            }
            if ((_ || r.sortParticles) && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglVertexBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, y, e)), (b || r.sortParticles) && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglColorBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, T, e)), R)
                for (u = 0, l = R.length; l > u; u++) d = R[u], (d.needsUpdate || r.sortParticles) && (Fe.bindBuffer(Fe.ARRAY_BUFFER, d.buffer), Fe.bufferData(Fe.ARRAY_BUFFER, d.array, e))
        }

        function m(t, e) {
            var r, n, i, o, a, s, h, u, l, c, p, f, d = t.vertices,
                m = t.colors,
                g = t.lineDistances,
                v = d.length,
                E = m.length,
                y = g.length,
                T = t.__vertexArray,
                x = t.__colorArray,
                _ = t.__lineDistanceArray,
                b = t.verticesNeedUpdate,
                R = t.colorsNeedUpdate,
                w = t.lineDistancesNeedUpdate,
                H = t.__webglCustomAttributesList;
            if (b) {
                for (r = 0; v > r; r++) o = d[r], a = 3 * r, T[a] = o.x, T[a + 1] = o.y, T[a + 2] = o.z;
                Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglVertexBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, T, e)
            }
            if (R) {
                for (n = 0; E > n; n++) s = m[n], a = 3 * n, x[a] = s.r, x[a + 1] = s.g, x[a + 2] = s.b;
                Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglColorBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, x, e)
            }
            if (w) {
                for (i = 0; y > i; i++) _[i] = g[i];
                Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglLineDistanceBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, _, e)
            }
            if (H)
                for (h = 0, u = H.length; u > h; h++)
                    if (f = H[h], f.needsUpdate && (void 0 === f.boundTo || "vertices" === f.boundTo)) {
                        if (a = 0, c = f.value.length, 1 === f.size)
                            for (l = 0; c > l; l++) f.array[l] = f.value[l];
                        else if (2 === f.size)
                            for (l = 0; c > l; l++) p = f.value[l], f.array[a] = p.x, f.array[a + 1] = p.y, a += 2;
                        else if (3 === f.size)
                            if ("c" === f.type)
                                for (l = 0; c > l; l++) p = f.value[l], f.array[a] = p.r, f.array[a + 1] = p.g, f.array[a + 2] = p.b, a += 3;
                            else
                                for (l = 0; c > l; l++) p = f.value[l], f.array[a] = p.x, f.array[a + 1] = p.y, f.array[a + 2] = p.z, a += 3;
                        else if (4 === f.size)
                            for (l = 0; c > l; l++) p = f.value[l], f.array[a] = p.x, f.array[a + 1] = p.y, f.array[a + 2] = p.z, f.array[a + 3] = p.w, a += 4;
                        Fe.bindBuffer(Fe.ARRAY_BUFFER, f.buffer), Fe.bufferData(Fe.ARRAY_BUFFER, f.array, e)
                    }
        }

        function g(t, e, r, n, i) {
            if (t.__inittedArrays) {
                var o, a, s, h, u, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L, z, P, D, F, U, O, B, V, N, j, I, G, W, X, q, Y, K, Z = l(i),
                    Q = c(i),
                    J = p(i),
                    $ = Z === THREE.SmoothShading,
                    te = 0,
                    ee = 0,
                    re = 0,
                    ne = 0,
                    ie = 0,
                    oe = 0,
                    ae = 0,
                    se = 0,
                    he = 0,
                    ue = 0,
                    le = 0,
                    ce = 0,
                    pe = 0,
                    fe = t.__vertexArray,
                    de = t.__uvArray,
                    me = t.__uv2Array,
                    ge = t.__normalArray,
                    ve = t.__tangentArray,
                    Ee = t.__colorArray,
                    ye = t.__skinIndexArray,
                    Te = t.__skinWeightArray,
                    xe = t.__morphTargetsArrays,
                    _e = t.__morphNormalsArrays,
                    be = t.__webglCustomAttributesList,
                    Re = t.__faceArray,
                    we = t.__lineArray,
                    He = e.geometry,
                    Me = He.verticesNeedUpdate,
                    Se = He.elementsNeedUpdate,
                    Ae = He.uvsNeedUpdate,
                    Ce = He.normalsNeedUpdate,
                    ke = He.tangentsNeedUpdate,
                    Le = He.colorsNeedUpdate,
                    ze = He.morphTargetsNeedUpdate,
                    Pe = He.vertices,
                    De = t.faces3,
                    Ue = He.faces,
                    Oe = He.faceVertexUvs[0],
                    Be = He.faceVertexUvs[1],
                    Ve = (He.colors, He.skinIndices),
                    Ne = He.skinWeights,
                    je = He.morphTargets,
                    Ie = He.morphNormals;
                if (Me) {
                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], y = Pe[h.a], T = Pe[h.b], x = Pe[h.c], fe[ee] = y.x, fe[ee + 1] = y.y, fe[ee + 2] = y.z, fe[ee + 3] = T.x, fe[ee + 4] = T.y, fe[ee + 5] = T.z, fe[ee + 6] = x.x, fe[ee + 7] = x.y, fe[ee + 8] = x.z, ee += 9;
                    Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglVertexBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, fe, r)
                }
                if (ze)
                    for (j = 0, I = je.length; I > j; j++) {
                        for (le = 0, o = 0, a = De.length; a > o; o++) X = De[o], h = Ue[X], y = je[j].vertices[h.a], T = je[j].vertices[h.b], x = je[j].vertices[h.c], G = xe[j], G[le] = y.x, G[le + 1] = y.y, G[le + 2] = y.z, G[le + 3] = T.x, G[le + 4] = T.y, G[le + 5] = T.z, G[le + 6] = x.x, G[le + 7] = x.y, G[le + 8] = x.z, i.morphNormals && ($ ? (q = Ie[j].vertexNormals[X], w = q.a, H = q.b, M = q.c) : (w = Ie[j].faceNormals[X], H = w, M = w), W = _e[j], W[le] = w.x, W[le + 1] = w.y, W[le + 2] = w.z, W[le + 3] = H.x, W[le + 4] = H.y, W[le + 5] = H.z, W[le + 6] = M.x, W[le + 7] = M.y, W[le + 8] = M.z), le += 9;
                        Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[j]), Fe.bufferData(Fe.ARRAY_BUFFER, xe[j], r), i.morphNormals && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[j]), Fe.bufferData(Fe.ARRAY_BUFFER, _e[j], r))
                    }
                if (Ne.length) {
                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], k = Ne[h.a], L = Ne[h.b], z = Ne[h.c], Te[ue] = k.x, Te[ue + 1] = k.y, Te[ue + 2] = k.z, Te[ue + 3] = k.w, Te[ue + 4] = L.x, Te[ue + 5] = L.y, Te[ue + 6] = L.z, Te[ue + 7] = L.w, Te[ue + 8] = z.x, Te[ue + 9] = z.y, Te[ue + 10] = z.z, Te[ue + 11] = z.w, P = Ve[h.a], D = Ve[h.b], F = Ve[h.c], ye[ue] = P.x, ye[ue + 1] = P.y, ye[ue + 2] = P.z, ye[ue + 3] = P.w, ye[ue + 4] = D.x, ye[ue + 5] = D.y, ye[ue + 6] = D.z, ye[ue + 7] = D.w, ye[ue + 8] = F.x, ye[ue + 9] = F.y, ye[ue + 10] = F.z, ye[ue + 11] = F.w, ue += 12;
                    ue > 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglSkinIndicesBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, ye, r), Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglSkinWeightsBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, Te, r))
                }
                if (Le && Q) {
                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], d = h.vertexColors, m = h.color, 3 === d.length && Q === THREE.VertexColors ? (S = d[0], A = d[1], C = d[2]) : (S = m, A = m, C = m), Ee[he] = S.r, Ee[he + 1] = S.g, Ee[he + 2] = S.b, Ee[he + 3] = A.r, Ee[he + 4] = A.g, Ee[he + 5] = A.b, Ee[he + 6] = C.r, Ee[he + 7] = C.g, Ee[he + 8] = C.b, he += 9;
                    he > 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglColorBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, Ee, r))
                }
                if (ke && He.hasTangents) {
                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], g = h.vertexTangents, _ = g[0], b = g[1], R = g[2], ve[ae] = _.x, ve[ae + 1] = _.y, ve[ae + 2] = _.z, ve[ae + 3] = _.w, ve[ae + 4] = b.x, ve[ae + 5] = b.y, ve[ae + 6] = b.z, ve[ae + 7] = b.w, ve[ae + 8] = R.x, ve[ae + 9] = R.y, ve[ae + 10] = R.z, ve[ae + 11] = R.w, ae += 12;
                    Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglTangentBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, ve, r)
                }
                if (Ce && Z) {
                    for (o = 0, a = De.length; a > o; o++)
                        if (h = Ue[De[o]], u = h.vertexNormals, f = h.normal, 3 === u.length && $)
                            for (U = 0; 3 > U; U++) B = u[U], ge[oe] = B.x, ge[oe + 1] = B.y, ge[oe + 2] = B.z, oe += 3;
                        else
                            for (U = 0; 3 > U; U++) ge[oe] = f.x, ge[oe + 1] = f.y, ge[oe + 2] = f.z, oe += 3;
                    Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglNormalBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, ge, r)
                }
                if (Ae && Oe && J) {
                    for (o = 0, a = De.length; a > o; o++)
                        if (s = De[o], v = Oe[s], void 0 !== v)
                            for (U = 0; 3 > U; U++) V = v[U], de[re] = V.x, de[re + 1] = V.y, re += 2;
                    re > 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglUVBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, de, r))
                }
                if (Ae && Be && J) {
                    for (o = 0, a = De.length; a > o; o++)
                        if (s = De[o], E = Be[s], void 0 !== E)
                            for (U = 0; 3 > U; U++) N = E[U], me[ne] = N.x, me[ne + 1] = N.y, ne += 2;
                    ne > 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglUV2Buffer), Fe.bufferData(Fe.ARRAY_BUFFER, me, r))
                }
                if (Se) {
                    for (o = 0, a = De.length; a > o; o++) Re[ie] = te, Re[ie + 1] = te + 1, Re[ie + 2] = te + 2, ie += 3, we[se] = te, we[se + 1] = te + 1, we[se + 2] = te, we[se + 3] = te + 2, we[se + 4] = te + 1, we[se + 5] = te + 2, se += 6, te += 3;
                    Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, t.__webglFaceBuffer), Fe.bufferData(Fe.ELEMENT_ARRAY_BUFFER, Re, r), Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, t.__webglLineBuffer), Fe.bufferData(Fe.ELEMENT_ARRAY_BUFFER, we, r)
                }
                if (be)
                    for (U = 0, O = be.length; O > U; U++)
                        if (K = be[U], K.__original.needsUpdate) {
                            if (ce = 0, pe = 0, 1 === K.size) {
                                if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], K.array[ce] = K.value[h.a], K.array[ce + 1] = K.value[h.b], K.array[ce + 2] = K.value[h.c], ce += 3;
                                else if ("faces" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], K.array[ce] = Y, K.array[ce + 1] = Y, K.array[ce + 2] = Y, ce += 3
                            } else if (2 === K.size) {
                                if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], y = K.value[h.a], T = K.value[h.b], x = K.value[h.c], K.array[ce] = y.x, K.array[ce + 1] = y.y, K.array[ce + 2] = T.x, K.array[ce + 3] = T.y, K.array[ce + 4] = x.x, K.array[ce + 5] = x.y, ce += 6;
                                else if ("faces" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], y = Y, T = Y, x = Y, K.array[ce] = y.x, K.array[ce + 1] = y.y, K.array[ce + 2] = T.x, K.array[ce + 3] = T.y, K.array[ce + 4] = x.x, K.array[ce + 5] = x.y, ce += 6
                            } else if (3 === K.size) {
                                var Ge;
                                if (Ge = "c" === K.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === K.boundTo || "vertices" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], y = K.value[h.a], T = K.value[h.b], x = K.value[h.c], K.array[ce] = y[Ge[0]], K.array[ce + 1] = y[Ge[1]], K.array[ce + 2] = y[Ge[2]], K.array[ce + 3] = T[Ge[0]], K.array[ce + 4] = T[Ge[1]], K.array[ce + 5] = T[Ge[2]], K.array[ce + 6] = x[Ge[0]], K.array[ce + 7] = x[Ge[1]], K.array[ce + 8] = x[Ge[2]], ce += 9;
                                else if ("faces" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], y = Y, T = Y, x = Y, K.array[ce] = y[Ge[0]], K.array[ce + 1] = y[Ge[1]], K.array[ce + 2] = y[Ge[2]], K.array[ce + 3] = T[Ge[0]], K.array[ce + 4] = T[Ge[1]], K.array[ce + 5] = T[Ge[2]], K.array[ce + 6] = x[Ge[0]], K.array[ce + 7] = x[Ge[1]], K.array[ce + 8] = x[Ge[2]], ce += 9;
                                else if ("faceVertices" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], y = Y[0], T = Y[1], x = Y[2], K.array[ce] = y[Ge[0]], K.array[ce + 1] = y[Ge[1]], K.array[ce + 2] = y[Ge[2]], K.array[ce + 3] = T[Ge[0]], K.array[ce + 4] = T[Ge[1]], K.array[ce + 5] = T[Ge[2]], K.array[ce + 6] = x[Ge[0]], K.array[ce + 7] = x[Ge[1]], K.array[ce + 8] = x[Ge[2]], ce += 9
                            } else if (4 === K.size)
                                if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                    for (o = 0, a = De.length; a > o; o++) h = Ue[De[o]], y = K.value[h.a], T = K.value[h.b], x = K.value[h.c], K.array[ce] = y.x, K.array[ce + 1] = y.y, K.array[ce + 2] = y.z, K.array[ce + 3] = y.w, K.array[ce + 4] = T.x, K.array[ce + 5] = T.y, K.array[ce + 6] = T.z, K.array[ce + 7] = T.w, K.array[ce + 8] = x.x, K.array[ce + 9] = x.y, K.array[ce + 10] = x.z, K.array[ce + 11] = x.w, ce += 12;
                                else if ("faces" === K.boundTo)
                                for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], y = Y, T = Y, x = Y, K.array[ce] = y.x, K.array[ce + 1] = y.y, K.array[ce + 2] = y.z, K.array[ce + 3] = y.w, K.array[ce + 4] = T.x, K.array[ce + 5] = T.y, K.array[ce + 6] = T.z, K.array[ce + 7] = T.w, K.array[ce + 8] = x.x, K.array[ce + 9] = x.y, K.array[ce + 10] = x.z, K.array[ce + 11] = x.w, ce += 12;
                            else if ("faceVertices" === K.boundTo)
                                for (o = 0, a = De.length; a > o; o++) Y = K.value[De[o]], y = Y[0], T = Y[1], x = Y[2], K.array[ce] = y.x, K.array[ce + 1] = y.y, K.array[ce + 2] = y.z, K.array[ce + 3] = y.w, K.array[ce + 4] = T.x, K.array[ce + 5] = T.y, K.array[ce + 6] = T.z, K.array[ce + 7] = T.w, K.array[ce + 8] = x.x, K.array[ce + 9] = x.y, K.array[ce + 10] = x.z, K.array[ce + 11] = x.w, ce += 12;
                            Fe.bindBuffer(Fe.ARRAY_BUFFER, K.buffer), Fe.bufferData(Fe.ARRAY_BUFFER, K.array, r)
                        }
                n && (delete t.__inittedArrays, delete t.__colorArray, delete t.__normalArray, delete t.__tangentArray, delete t.__uvArray, delete t.__uv2Array, delete t.__faceArray, delete t.__vertexArray, delete t.__lineArray, delete t.__skinIndexArray, delete t.__skinWeightArray)
            }
        }

        function v(t, e) {
            var r, n, i = t.attributes;
            for (r in i) n = i[r], n.needsUpdate && ("index" === r ? (Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, n.buffer), Fe.bufferData(Fe.ELEMENT_ARRAY_BUFFER, n.array, e)) : (Fe.bindBuffer(Fe.ARRAY_BUFFER, n.buffer), Fe.bufferData(Fe.ARRAY_BUFFER, n.array, e)), n.needsUpdate = !1)
        }

        function E(t, e, r, n) {
            for (var i in e) {
                var o = e[i],
                    a = r[i];
                if (o >= 0)
                    if (a) {
                        var s = a.itemSize;
                        Fe.bindBuffer(Fe.ARRAY_BUFFER, a.buffer), T(o), Fe.vertexAttribPointer(o, s, Fe.FLOAT, !1, 0, n * s * 4)
                    } else t.defaultAttributeValues && (2 === t.defaultAttributeValues[i].length ? Fe.vertexAttrib2fv(o, t.defaultAttributeValues[i]) : 3 === t.defaultAttributeValues[i].length && Fe.vertexAttrib3fv(o, t.defaultAttributeValues[i]))
            }
            x()
        }

        function y() {
            for (var t = 0, e = gr.length; e > t; t++) gr[t] = 0
        }

        function T(t) {
            gr[t] = 1, 0 === vr[t] && (Fe.enableVertexAttribArray(t), vr[t] = 1)
        }

        function x() {
            for (var t = 0, e = vr.length; e > t; t++) vr[t] !== gr[t] && (Fe.disableVertexAttribArray(t), vr[t] = 0)
        }

        function _(t, e, r) {
            var n = t.program.attributes;
            if (-1 !== r.morphTargetBase && n.position >= 0 ? (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[r.morphTargetBase]), T(n.position), Fe.vertexAttribPointer(n.position, 3, Fe.FLOAT, !1, 0, 0)) : n.position >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglVertexBuffer), T(n.position), Fe.vertexAttribPointer(n.position, 3, Fe.FLOAT, !1, 0, 0)), r.morphTargetForcedOrder.length)
                for (var i = 0, o = r.morphTargetForcedOrder, a = r.morphTargetInfluences; i < t.numSupportedMorphTargets && i < o.length;) n["morphTarget" + i] >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[o[i]]), T(n["morphTarget" + i]), Fe.vertexAttribPointer(n["morphTarget" + i], 3, Fe.FLOAT, !1, 0, 0)), n["morphNormal" + i] >= 0 && t.morphNormals && (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[o[i]]), T(n["morphNormal" + i]), Fe.vertexAttribPointer(n["morphNormal" + i], 3, Fe.FLOAT, !1, 0, 0)), r.__webglMorphTargetInfluences[i] = a[o[i]], i++;
            else {
                var s, h, u = [],
                    a = r.morphTargetInfluences,
                    l = a.length;
                for (h = 0; l > h; h++) s = a[h], s > 0 && u.push([s, h]);
                u.length > t.numSupportedMorphTargets ? (u.sort(w), u.length = t.numSupportedMorphTargets) : u.length > t.numSupportedMorphNormals ? u.sort(w) : 0 === u.length && u.push([0, 0]);
                for (var c, i = 0; i < t.numSupportedMorphTargets;) u[i] ? (c = u[i][1], n["morphTarget" + i] >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[c]), T(n["morphTarget" + i]), Fe.vertexAttribPointer(n["morphTarget" + i], 3, Fe.FLOAT, !1, 0, 0)), n["morphNormal" + i] >= 0 && t.morphNormals && (Fe.bindBuffer(Fe.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[c]), T(n["morphNormal" + i]), Fe.vertexAttribPointer(n["morphNormal" + i], 3, Fe.FLOAT, !1, 0, 0)), r.__webglMorphTargetInfluences[i] = a[c]) : r.__webglMorphTargetInfluences[i] = 0, i++
            }
            null !== t.program.uniforms.morphTargetInfluences && Fe.uniform1fv(t.program.uniforms.morphTargetInfluences, r.__webglMorphTargetInfluences)
        }

        function b(t, e) {
            return t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function R(t, e) {
            return t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function w(t, e) {
            return e[0] - t[0]
        }

        function H(t, e, r) {
            if (e.visible !== !1) {
                var n = t.__webglObjects[e.id];
                if (n && (e.frustumCulled === !1 || Er.intersectsObject(e) === !0)) {
                    F(t, e);
                    for (var i = 0, o = n.length; o > i; i++) {
                        var a = n[i];
                        k(a), a.render = !0, Ge.sortObjects === !0 && (null !== e.renderDepth ? a.z = e.renderDepth : (xr.setFromMatrixPosition(e.matrixWorld), xr.applyProjection(yr), a.z = xr.z))
                    }
                }
                for (var i = 0, o = e.children.length; o > i; i++) H(t, e.children[i], r)
            }
        }

        function M(t, e, r) {
            if (0 !== t.length)
                for (var n = 0, i = t.length; i > n; n++) Xe = null, Ze = null, tr = -1, ir = -1, or = -1, Je = -1, $e = -1, Ke = -1, Ye = -1, br = !0, t[n].render(e, r, dr, mr), Xe = null, Ze = null, tr = -1, ir = -1, or = -1, Je = -1, $e = -1, Ke = -1, Ye = -1, br = !0
        }

        function S(t, e, r, n, i, o) {
            for (var a, s, h, u, l = t.length - 1; - 1 !== l; l--) {
                if (a = t[l], s = a.object, h = a.buffer, re(s, e), o) u = o;
                else {
                    if (u = a.material, !u) continue;
                    i && Ge.setBlending(u.blending, u.blendEquation, u.blendSrc, u.blendDst), Ge.setDepthTest(u.depthTest), Ge.setDepthWrite(u.depthWrite), se(u.polygonOffset, u.polygonOffsetFactor, u.polygonOffsetUnits)
                }
                Ge.setMaterialFaces(u), h instanceof THREE.BufferGeometry ? Ge.renderBufferDirect(e, r, n, u, h, s) : Ge.renderBuffer(e, r, n, u, h, s)
            }
        }

        function A(t, e, r, n, i, o, a) {
            for (var s, h, u, l = 0, c = t.length; c > l; l++)
                if (s = t[l], h = s.object, h.visible) {
                    if (a) u = a;
                    else {
                        if (u = s[e], !u) continue;
                        o && Ge.setBlending(u.blending, u.blendEquation, u.blendSrc, u.blendDst), Ge.setDepthTest(u.depthTest), Ge.setDepthWrite(u.depthWrite), se(u.polygonOffset, u.polygonOffsetFactor, u.polygonOffsetUnits)
                    }
                    Ge.renderImmediateObject(r, n, i, u, h)
                }
        }

        function C(t) {
            var e = t.object,
                r = e.material;
            r.transparent ? (t.transparent = r, t.opaque = null) : (t.opaque = r, t.transparent = null)
        }

        function k(t) {
            var e = t.object,
                r = t.buffer,
                n = e.geometry,
                i = e.material;
            if (i instanceof THREE.MeshFaceMaterial) {
                var o = n instanceof THREE.BufferGeometry ? 0 : r.materialIndex;
                i = i.materials[o], i.transparent ? (t.material = i, De.push(t)) : (t.material = i, Pe.push(t))
            } else i && (i.transparent ? (t.material = i, De.push(t)) : (t.material = i, Pe.push(t)))
        }

        function L(t, n) {
            var i, s;
            if (void 0 === t.__webglInit && (t.__webglInit = !0, t._modelViewMatrix = new THREE.Matrix4, t._normalMatrix = new THREE.Matrix3), i = t.geometry, void 0 === i || void 0 === i.__webglInit && (i.__webglInit = !0, i.addEventListener("dispose", Ur), i instanceof THREE.BufferGeometry ? f(i) : t instanceof THREE.Mesh ? (void 0 !== t.__webglActive && B(t, n), z(n, t, i)) : t instanceof THREE.Line ? i.__webglVertexBuffer || (r(i), a(i, t), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0, i.lineDistancesNeedUpdate = !0) : t instanceof THREE.PointCloud && (i.__webglVertexBuffer || (e(i), o(i, t), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0))), void 0 === t.__webglActive) {
                if (t instanceof THREE.Mesh) {
                    if (i = t.geometry, i instanceof THREE.BufferGeometry) P(n.__webglObjects, i, t);
                    else if (i instanceof THREE.Geometry)
                        for (var h = 0, u = i.geometryGroupsList.length; u > h; h++) s = i.geometryGroupsList[h], P(n.__webglObjects, s, t)
                } else t instanceof THREE.Line || t instanceof THREE.PointCloud ? (i = t.geometry, P(n.__webglObjects, i, t)) : (t instanceof THREE.ImmediateRenderObject || t.immediateRenderCallback) && D(n.__webglObjectsImmediate, t);
                t.__webglActive = !0
            }
        }

        function z(t, e, r) {
            var i, o, a = !1;
            o = e.material, (void 0 === r.geometryGroups || r.groupsNeedUpdate) && (delete t.__webglObjects[e.id], r.makeGroups(o instanceof THREE.MeshFaceMaterial, je ? 4294967296 : 65535), r.groupsNeedUpdate = !1);
            for (var h = 0, u = r.geometryGroupsList.length; u > h; h++) i = r.geometryGroupsList[h], i.__webglVertexBuffer ? a = !1 : (n(i), s(i, e), r.verticesNeedUpdate = !0, r.morphTargetsNeedUpdate = !0, r.elementsNeedUpdate = !0, r.uvsNeedUpdate = !0, r.normalsNeedUpdate = !0, r.tangentsNeedUpdate = !0, r.colorsNeedUpdate = !0, a = !0), (a || void 0 === e.__webglActive) && P(t.__webglObjects, i, e);
            e.__webglActive = !0
        }

        function P(t, e, r) {
            var n = r.id;
            t[n] = t[n] || [], t[n].push({
                id: n,
                buffer: e,
                object: r,
                material: null,
                z: 0
            })
        }

        function D(t, e) {
            t.push({
                id: null,
                object: e,
                opaque: null,
                transparent: null,
                z: 0
            })
        }

        function F(t, e) {
            var r, n, i, o = e.geometry;
            if (o instanceof THREE.BufferGeometry) v(o, Fe.DYNAMIC_DRAW);
            else if (e instanceof THREE.Mesh) {
                (o.buffersNeedUpdate || o.groupsNeedUpdate) && (o instanceof THREE.BufferGeometry ? f(o) : e instanceof THREE.Mesh && z(t, e, o));
                for (var a = 0, u = o.geometryGroupsList.length; u > a; a++) r = o.geometryGroupsList[a], i = h(e, r), (o.buffersNeedUpdate || o.groupsNeedUpdate) && s(r, e), n = i.attributes && U(i), (o.verticesNeedUpdate || o.morphTargetsNeedUpdate || o.elementsNeedUpdate || o.uvsNeedUpdate || o.normalsNeedUpdate || o.colorsNeedUpdate || o.tangentsNeedUpdate || n) && g(r, e, Fe.DYNAMIC_DRAW, !o.dynamic, i);
                o.verticesNeedUpdate = !1, o.morphTargetsNeedUpdate = !1, o.elementsNeedUpdate = !1, o.uvsNeedUpdate = !1, o.normalsNeedUpdate = !1, o.colorsNeedUpdate = !1, o.tangentsNeedUpdate = !1, o.buffersNeedUpdate = !1, i.attributes && O(i)
            } else e instanceof THREE.Line ? (i = h(e, o), n = i.attributes && U(i), (o.verticesNeedUpdate || o.colorsNeedUpdate || o.lineDistancesNeedUpdate || n) && m(o, Fe.DYNAMIC_DRAW), o.verticesNeedUpdate = !1, o.colorsNeedUpdate = !1, o.lineDistancesNeedUpdate = !1, i.attributes && O(i)) : e instanceof THREE.PointCloud && (i = h(e, o), n = i.attributes && U(i), (o.verticesNeedUpdate || o.colorsNeedUpdate || e.sortParticles || n) && d(o, Fe.DYNAMIC_DRAW, e), o.verticesNeedUpdate = !1, o.colorsNeedUpdate = !1, i.attributes && O(i))
        }

        function U(t) {
            for (var e in t.attributes)
                if (t.attributes[e].needsUpdate) return !0;
            return !1
        }

        function O(t) {
            for (var e in t.attributes) t.attributes[e].needsUpdate = !1
        }

        function B(t, e) {
            t instanceof THREE.Mesh || t instanceof THREE.PointCloud || t instanceof THREE.Line ? V(e.__webglObjects, t) : (t instanceof THREE.ImmediateRenderObject || t.immediateRenderCallback) && N(e.__webglObjectsImmediate, t), delete t.__webglActive
        }

        function V(t, e) {
            delete t[e.id]
        }

        function N(t, e) {
            for (var r = t.length - 1; r >= 0; r--) t[r].object === e && t.splice(r, 1)
        }

        function j(t, e, r, n, i) {
            Qe = 0, n.needsUpdate && (n.program && Wr(n), Ge.initMaterial(n, e, r, i), n.needsUpdate = !1), n.morphTargets && (i.__webglMorphTargetInfluences || (i.__webglMorphTargetInfluences = new Float32Array(Ge.maxMorphTargets)));
            var o = !1,
                a = !1,
                s = !1,
                h = n.program,
                u = h.uniforms,
                l = n.__webglShader.uniforms;
            if (h.id !== Xe && (Fe.useProgram(h.program), Xe = h.id, o = !0, a = !0, s = !0), n.id !== Ye && (-1 === Ye && (s = !0), Ye = n.id, a = !0), (o || t !== Ze) && (Fe.uniformMatrix4fv(u.projectionMatrix, !1, t.projectionMatrix.elements), ke && Fe.uniform1f(u.logDepthBufFC, 2 / (Math.log(t.far + 1) / Math.LN2)), t !== Ze && (Ze = t), (n instanceof THREE.ShaderMaterial || n instanceof THREE.MeshPhongMaterial || n.envMap) && null !== u.cameraPosition && (xr.setFromMatrixPosition(t.matrixWorld), Fe.uniform3f(u.cameraPosition, xr.x, xr.y, xr.z)), (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.ShaderMaterial || n.skinning) && null !== u.viewMatrix && Fe.uniformMatrix4fv(u.viewMatrix, !1, t.matrixWorldInverse.elements)), n.skinning)
                if (i.bindMatrix && null !== u.bindMatrix && Fe.uniformMatrix4fv(u.bindMatrix, !1, i.bindMatrix.elements), i.bindMatrixInverse && null !== u.bindMatrixInverse && Fe.uniformMatrix4fv(u.bindMatrixInverse, !1, i.bindMatrixInverse.elements), Cr && i.skeleton && i.skeleton.useVertexTexture) {
                    if (null !== u.boneTexture) {
                        var c = te();
                        Fe.uniform1i(u.boneTexture, c), Ge.setTexture(i.skeleton.boneTexture, c)
                    }
                    null !== u.boneTextureWidth && Fe.uniform1i(u.boneTextureWidth, i.skeleton.boneTextureWidth), null !== u.boneTextureHeight && Fe.uniform1i(u.boneTextureHeight, i.skeleton.boneTextureHeight)
                } else i.skeleton && i.skeleton.boneMatrices && null !== u.boneGlobalMatrices && Fe.uniformMatrix4fv(u.boneGlobalMatrices, !1, i.skeleton.boneMatrices);
            return a && (r && n.fog && q(l, r), (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n.lights) && (br && (s = !0, oe(e), br = !1), s ? (Z(l, Rr), Q(l, !0)) : Q(l, !1)), (n instanceof THREE.MeshBasicMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshPhongMaterial) && I(l, n), n instanceof THREE.LineBasicMaterial ? G(l, n) : n instanceof THREE.LineDashedMaterial ? (G(l, n), W(l, n)) : n instanceof THREE.PointCloudMaterial ? X(l, n) : n instanceof THREE.MeshPhongMaterial ? Y(l, n) : n instanceof THREE.MeshLambertMaterial ? K(l, n) : n instanceof THREE.MeshDepthMaterial ? (l.mNear.value = t.near, l.mFar.value = t.far, l.opacity.value = n.opacity) : n instanceof THREE.MeshNormalMaterial && (l.opacity.value = n.opacity), i.receiveShadow && !n._shadowPass && J(l, e), ee(n.uniformsList)), $(u, i), null !== u.modelMatrix && Fe.uniformMatrix4fv(u.modelMatrix, !1, i.matrixWorld.elements), h
        }

        function I(t, e) {
            t.opacity.value = e.opacity, Ge.gammaInput ? t.diffuse.value.copyGammaToLinear(e.color) : t.diffuse.value = e.color, t.map.value = e.map, t.lightMap.value = e.lightMap, t.specularMap.value = e.specularMap, t.alphaMap.value = e.alphaMap, e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale));
            var r;
            if (e.map ? r = e.map : e.specularMap ? r = e.specularMap : e.normalMap ? r = e.normalMap : e.bumpMap ? r = e.bumpMap : e.alphaMap && (r = e.alphaMap), void 0 !== r) {
                var n = r.offset,
                    i = r.repeat;
                t.offsetRepeat.value.set(n.x, n.y, i.x, i.y)
            }
            t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, t.reflectivity.value = Ge.gammaInput ? e.reflectivity : e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.combine.value = e.combine, t.useRefract.value = e.envMap && e.envMap.mapping instanceof THREE.CubeRefractionMapping
        }

        function G(t, e) {
            t.diffuse.value = e.color, t.opacity.value = e.opacity
        }

        function W(t, e) {
            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
        }

        function X(t, e) {
            t.psColor.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size, t.scale.value = _e.height / 2, t.map.value = e.map
        }

        function q(t, e) {
            t.fogColor.value = e.color, e instanceof THREE.Fog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e instanceof THREE.FogExp2 && (t.fogDensity.value = e.density)
        }

        function Y(t, e) {
            t.shininess.value = e.shininess, Ge.gammaInput ? (t.ambient.value.copyGammaToLinear(e.ambient), t.emissive.value.copyGammaToLinear(e.emissive), t.specular.value.copyGammaToLinear(e.specular)) : (t.ambient.value = e.ambient, t.emissive.value = e.emissive, t.specular.value = e.specular), e.wrapAround && t.wrapRGB.value.copy(e.wrapRGB)
        }

        function K(t, e) {
            Ge.gammaInput ? (t.ambient.value.copyGammaToLinear(e.ambient), t.emissive.value.copyGammaToLinear(e.emissive)) : (t.ambient.value = e.ambient, t.emissive.value = e.emissive), e.wrapAround && t.wrapRGB.value.copy(e.wrapRGB)
        }

        function Z(t, e) {
            t.ambientLightColor.value = e.ambient, t.directionalLightColor.value = e.directional.colors, t.directionalLightDirection.value = e.directional.positions, t.pointLightColor.value = e.point.colors, t.pointLightPosition.value = e.point.positions, t.pointLightDistance.value = e.point.distances, t.spotLightColor.value = e.spot.colors, t.spotLightPosition.value = e.spot.positions, t.spotLightDistance.value = e.spot.distances, t.spotLightDirection.value = e.spot.directions, t.spotLightAngleCos.value = e.spot.anglesCos, t.spotLightExponent.value = e.spot.exponents, t.hemisphereLightSkyColor.value = e.hemi.skyColors, t.hemisphereLightGroundColor.value = e.hemi.groundColors, t.hemisphereLightDirection.value = e.hemi.positions
        }

        function Q(t, e) {
            t.ambientLightColor.needsUpdate = e, t.directionalLightColor.needsUpdate = e, t.directionalLightDirection.needsUpdate = e, t.pointLightColor.needsUpdate = e, t.pointLightPosition.needsUpdate = e, t.pointLightDistance.needsUpdate = e, t.spotLightColor.needsUpdate = e, t.spotLightPosition.needsUpdate = e, t.spotLightDistance.needsUpdate = e, t.spotLightDirection.needsUpdate = e, t.spotLightAngleCos.needsUpdate = e, t.spotLightExponent.needsUpdate = e, t.hemisphereLightSkyColor.needsUpdate = e, t.hemisphereLightGroundColor.needsUpdate = e, t.hemisphereLightDirection.needsUpdate = e
        }

        function J(t, e) {
            if (t.shadowMatrix)
                for (var r = 0, n = 0, i = e.length; i > n; n++) {
                    var o = e[n];
                    o.castShadow && (o instanceof THREE.SpotLight || o instanceof THREE.DirectionalLight && !o.shadowCascade) && (t.shadowMap.value[r] = o.shadowMap, t.shadowMapSize.value[r] = o.shadowMapSize, t.shadowMatrix.value[r] = o.shadowMatrix, t.shadowDarkness.value[r] = o.shadowDarkness, t.shadowBias.value[r] = o.shadowBias, r++)
                }
        }

        function $(t, e) {
            Fe.uniformMatrix4fv(t.modelViewMatrix, !1, e._modelViewMatrix.elements), t.normalMatrix && Fe.uniformMatrix3fv(t.normalMatrix, !1, e._normalMatrix.elements)
        }

        function te() {
            var t = Qe;
            return t >= wr && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + wr), Qe += 1, t
        }

        function ee(t) {
            for (var e, r, n, i = 0, o = t.length; o > i; i++) {
                var a = t[i][0];
                if (a.needsUpdate !== !1) {
                    var s = a.type,
                        h = a.value,
                        u = t[i][1];
                    switch (s) {
                        case "1i":
                            Fe.uniform1i(u, h);
                            break;
                        case "1f":
                            Fe.uniform1f(u, h);
                            break;
                        case "2f":
                            Fe.uniform2f(u, h[0], h[1]);
                            break;
                        case "3f":
                            Fe.uniform3f(u, h[0], h[1], h[2]);
                            break;
                        case "4f":
                            Fe.uniform4f(u, h[0], h[1], h[2], h[3]);
                            break;
                        case "1iv":
                            Fe.uniform1iv(u, h);
                            break;
                        case "3iv":
                            Fe.uniform3iv(u, h);
                            break;
                        case "1fv":
                            Fe.uniform1fv(u, h);
                            break;
                        case "2fv":
                            Fe.uniform2fv(u, h);
                            break;
                        case "3fv":
                            Fe.uniform3fv(u, h);
                            break;
                        case "4fv":
                            Fe.uniform4fv(u, h);
                            break;
                        case "Matrix3fv":
                            Fe.uniformMatrix3fv(u, !1, h);
                            break;
                        case "Matrix4fv":
                            Fe.uniformMatrix4fv(u, !1, h);
                            break;
                        case "i":
                            Fe.uniform1i(u, h);
                            break;
                        case "f":
                            Fe.uniform1f(u, h);
                            break;
                        case "v2":
                            Fe.uniform2f(u, h.x, h.y);
                            break;
                        case "v3":
                            Fe.uniform3f(u, h.x, h.y, h.z);
                            break;
                        case "v4":
                            Fe.uniform4f(u, h.x, h.y, h.z, h.w);
                            break;
                        case "c":
                            Fe.uniform3f(u, h.r, h.g, h.b);
                            break;
                        case "iv1":
                            Fe.uniform1iv(u, h);
                            break;
                        case "iv":
                            Fe.uniform3iv(u, h);
                            break;
                        case "fv1":
                            Fe.uniform1fv(u, h);
                            break;
                        case "fv":
                            Fe.uniform3fv(u, h);
                            break;
                        case "v2v":
                            void 0 === a._array && (a._array = new Float32Array(2 * h.length));
                            for (var l = 0, c = h.length; c > l; l++) n = 2 * l, a._array[n] = h[l].x, a._array[n + 1] = h[l].y;
                            Fe.uniform2fv(u, a._array);
                            break;
                        case "v3v":
                            void 0 === a._array && (a._array = new Float32Array(3 * h.length));
                            for (var l = 0, c = h.length; c > l; l++) n = 3 * l, a._array[n] = h[l].x, a._array[n + 1] = h[l].y, a._array[n + 2] = h[l].z;
                            Fe.uniform3fv(u, a._array);
                            break;
                        case "v4v":
                            void 0 === a._array && (a._array = new Float32Array(4 * h.length));
                            for (var l = 0, c = h.length; c > l; l++) n = 4 * l, a._array[n] = h[l].x, a._array[n + 1] = h[l].y, a._array[n + 2] = h[l].z, a._array[n + 3] = h[l].w;
                            Fe.uniform4fv(u, a._array);
                            break;
                        case "m3":
                            Fe.uniformMatrix3fv(u, !1, h.elements);
                            break;
                        case "m3v":
                            void 0 === a._array && (a._array = new Float32Array(9 * h.length));
                            for (var l = 0, c = h.length; c > l; l++) h[l].flattenToArrayOffset(a._array, 9 * l);
                            Fe.uniformMatrix3fv(u, !1, a._array);
                            break;
                        case "m4":
                            Fe.uniformMatrix4fv(u, !1, h.elements);
                            break;
                        case "m4v":
                            void 0 === a._array && (a._array = new Float32Array(16 * h.length));
                            for (var l = 0, c = h.length; c > l; l++) h[l].flattenToArrayOffset(a._array, 16 * l);
                            Fe.uniformMatrix4fv(u, !1, a._array);
                            break;
                        case "t":
                            if (e = h, r = te(), Fe.uniform1i(u, r), !e) continue;
                            e instanceof THREE.CubeTexture || e.image instanceof Array && 6 === e.image.length ? le(e, r) : e instanceof THREE.WebGLRenderTargetCube ? ce(e, r) : Ge.setTexture(e, r);
                            break;
                        case "tv":
                            void 0 === a._array && (a._array = []);
                            for (var l = 0, c = a.value.length; c > l; l++) a._array[l] = te();
                            Fe.uniform1iv(u, a._array);
                            for (var l = 0, c = a.value.length; c > l; l++) e = a.value[l], r = a._array[l], e && Ge.setTexture(e, r);
                            break;
                        default:
                            console.warn("THREE.WebGLRenderer: Unknown uniform type: " + s)
                    }
                }
            }
        }

        function re(t, e) {
            t._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, t.matrixWorld), t._normalMatrix.getNormalMatrix(t._modelViewMatrix)
        }

        function ne(t, e, r, n) {
            t[e] = r.r * r.r * n, t[e + 1] = r.g * r.g * n, t[e + 2] = r.b * r.b * n
        }

        function ie(t, e, r, n) {
            t[e] = r.r * n, t[e + 1] = r.g * n, t[e + 2] = r.b * n
        }

        function oe(t) {
            var e, r, n, i, o, a, s, h, u, l = 0,
                c = 0,
                p = 0,
                f = Rr,
                d = f.directional.colors,
                m = f.directional.positions,
                g = f.point.colors,
                v = f.point.positions,
                E = f.point.distances,
                y = f.spot.colors,
                T = f.spot.positions,
                x = f.spot.distances,
                _ = f.spot.directions,
                b = f.spot.anglesCos,
                R = f.spot.exponents,
                w = f.hemi.skyColors,
                H = f.hemi.groundColors,
                M = f.hemi.positions,
                S = 0,
                A = 0,
                C = 0,
                k = 0,
                L = 0,
                z = 0,
                P = 0,
                D = 0,
                F = 0,
                U = 0,
                O = 0,
                B = 0;
            for (e = 0, r = t.length; r > e; e++)
                if (n = t[e], !n.onlyShadow)
                    if (i = n.color, s = n.intensity, u = n.distance, n instanceof THREE.AmbientLight) {
                        if (!n.visible) continue;
                        Ge.gammaInput ? (l += i.r * i.r, c += i.g * i.g, p += i.b * i.b) : (l += i.r, c += i.g, p += i.b)
                    } else if (n instanceof THREE.DirectionalLight) {
                if (L += 1, !n.visible) continue;
                _r.setFromMatrixPosition(n.matrixWorld), xr.setFromMatrixPosition(n.target.matrixWorld), _r.sub(xr), _r.normalize(), F = 3 * S, m[F] = _r.x, m[F + 1] = _r.y, m[F + 2] = _r.z, Ge.gammaInput ? ne(d, F, i, s * s) : ie(d, F, i, s), S += 1
            } else if (n instanceof THREE.PointLight) {
                if (z += 1, !n.visible) continue;
                U = 3 * A, Ge.gammaInput ? ne(g, U, i, s * s) : ie(g, U, i, s), xr.setFromMatrixPosition(n.matrixWorld), v[U] = xr.x, v[U + 1] = xr.y, v[U + 2] = xr.z, E[A] = u, A += 1
            } else if (n instanceof THREE.SpotLight) {
                if (P += 1, !n.visible) continue;
                O = 3 * C, Ge.gammaInput ? ne(y, O, i, s * s) : ie(y, O, i, s), xr.setFromMatrixPosition(n.matrixWorld), T[O] = xr.x, T[O + 1] = xr.y, T[O + 2] = xr.z, x[C] = u, _r.copy(xr), xr.setFromMatrixPosition(n.target.matrixWorld), _r.sub(xr), _r.normalize(), _[O] = _r.x, _[O + 1] = _r.y, _[O + 2] = _r.z, b[C] = Math.cos(n.angle), R[C] = n.exponent, C += 1
            } else if (n instanceof THREE.HemisphereLight) {
                if (D += 1, !n.visible) continue;
                _r.setFromMatrixPosition(n.matrixWorld), _r.normalize(), B = 3 * k, M[B] = _r.x, M[B + 1] = _r.y, M[B + 2] = _r.z, o = n.color, a = n.groundColor, Ge.gammaInput ? (h = s * s, ne(w, B, o, h), ne(H, B, a, h)) : (ie(w, B, o, s), ie(H, B, a, s)), k += 1
            }
            for (e = 3 * S, r = Math.max(d.length, 3 * L); r > e; e++) d[e] = 0;
            for (e = 3 * A, r = Math.max(g.length, 3 * z); r > e; e++) g[e] = 0;
            for (e = 3 * C, r = Math.max(y.length, 3 * P); r > e; e++) y[e] = 0;
            for (e = 3 * k, r = Math.max(w.length, 3 * D); r > e; e++) w[e] = 0;
            for (e = 3 * k, r = Math.max(H.length, 3 * D); r > e; e++) H[e] = 0;
            f.directional.length = S, f.point.length = A, f.spot.length = C, f.hemi.length = k, f.ambient[0] = l, f.ambient[1] = c, f.ambient[2] = p
        }

        function ae(t) {
            t !== ur && (Fe.lineWidth(t), ur = t)
        }

        function se(t, e, r) {
            ar !== t && (t ? Fe.enable(Fe.POLYGON_OFFSET_FILL) : Fe.disable(Fe.POLYGON_OFFSET_FILL), ar = t), !t || sr === e && hr === r || (Fe.polygonOffset(e, r), sr = e, hr = r)
        }

        function he(t, e, r) {
            r ? (Fe.texParameteri(t, Fe.TEXTURE_WRAP_S, ge(e.wrapS)), Fe.texParameteri(t, Fe.TEXTURE_WRAP_T, ge(e.wrapT)), Fe.texParameteri(t, Fe.TEXTURE_MAG_FILTER, ge(e.magFilter)), Fe.texParameteri(t, Fe.TEXTURE_MIN_FILTER, ge(e.minFilter))) : (Fe.texParameteri(t, Fe.TEXTURE_WRAP_S, Fe.CLAMP_TO_EDGE), Fe.texParameteri(t, Fe.TEXTURE_WRAP_T, Fe.CLAMP_TO_EDGE), Fe.texParameteri(t, Fe.TEXTURE_MAG_FILTER, me(e.magFilter)), Fe.texParameteri(t, Fe.TEXTURE_MIN_FILTER, me(e.minFilter))), Ve && e.type !== THREE.FloatType && (e.anisotropy > 1 || e.__oldAnisotropy) && (Fe.texParameterf(t, Ve.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, Sr)), e.__oldAnisotropy = e.anisotropy)
        }

        function ue(t, e) {
            if (t.width <= e && t.height <= e) return t;
            var r = Math.max(t.width, t.height),
                n = Math.floor(t.width * e / r),
                i = Math.floor(t.height * e / r),
                o = document.createElement("canvas");
            o.width = n, o.height = i;
            var a = o.getContext("2d");
            return a.drawImage(t, 0, 0, t.width, t.height, 0, 0, n, i), o
        }

        function le(t, e) {
            if (6 === t.image.length)
                if (t.needsUpdate) {
                    t.image.__webglTextureCube || (t.addEventListener("dispose", Or), t.image.__webglTextureCube = Fe.createTexture(), Ge.info.memory.textures++), Fe.activeTexture(Fe.TEXTURE0 + e), Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, t.image.__webglTextureCube), Fe.pixelStorei(Fe.UNPACK_FLIP_Y_WEBGL, t.flipY);
                    for (var r = t instanceof THREE.CompressedTexture, n = [], i = 0; 6 > i; i++) n[i] = Ge.autoScaleCubemaps && !r ? ue(t.image[i], Mr) : t.image[i];
                    var o = n[0],
                        a = THREE.Math.isPowerOfTwo(o.width) && THREE.Math.isPowerOfTwo(o.height),
                        s = ge(t.format),
                        h = ge(t.type);
                    he(Fe.TEXTURE_CUBE_MAP, t, a);
                    for (var i = 0; 6 > i; i++)
                        if (r)
                            for (var u, l = n[i].mipmaps, c = 0, p = l.length; p > c; c++) u = l[c], t.format !== THREE.RGBAFormat ? Fe.compressedTexImage2D(Fe.TEXTURE_CUBE_MAP_POSITIVE_X + i, c, s, u.width, u.height, 0, u.data) : Fe.texImage2D(Fe.TEXTURE_CUBE_MAP_POSITIVE_X + i, c, s, u.width, u.height, 0, s, h, u.data);
                        else Fe.texImage2D(Fe.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, s, s, h, n[i]);
                    t.generateMipmaps && a && Fe.generateMipmap(Fe.TEXTURE_CUBE_MAP), t.needsUpdate = !1, t.onUpdate && t.onUpdate()
                } else Fe.activeTexture(Fe.TEXTURE0 + e), Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, t.image.__webglTextureCube)
        }

        function ce(t, e) {
            Fe.activeTexture(Fe.TEXTURE0 + e), Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, t.__webglTexture)
        }

        function pe(t, e, r) {
            Fe.bindFramebuffer(Fe.FRAMEBUFFER, t), Fe.framebufferTexture2D(Fe.FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, r, e.__webglTexture, 0)
        }

        function fe(t, e) {
            Fe.bindRenderbuffer(Fe.RENDERBUFFER, t), e.depthBuffer && !e.stencilBuffer ? (Fe.renderbufferStorage(Fe.RENDERBUFFER, Fe.DEPTH_COMPONENT16, e.width, e.height), Fe.framebufferRenderbuffer(Fe.FRAMEBUFFER, Fe.DEPTH_ATTACHMENT, Fe.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (Fe.renderbufferStorage(Fe.RENDERBUFFER, Fe.DEPTH_STENCIL, e.width, e.height), Fe.framebufferRenderbuffer(Fe.FRAMEBUFFER, Fe.DEPTH_STENCIL_ATTACHMENT, Fe.RENDERBUFFER, t)) : Fe.renderbufferStorage(Fe.RENDERBUFFER, Fe.RGBA4, e.width, e.height)
        }

        function de(t) {
            t instanceof THREE.WebGLRenderTargetCube ? (Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, t.__webglTexture), Fe.generateMipmap(Fe.TEXTURE_CUBE_MAP), Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, null)) : (Fe.bindTexture(Fe.TEXTURE_2D, t.__webglTexture), Fe.generateMipmap(Fe.TEXTURE_2D), Fe.bindTexture(Fe.TEXTURE_2D, null))
        }

        function me(t) {
            return t === THREE.NearestFilter || t === THREE.NearestMipMapNearestFilter || t === THREE.NearestMipMapLinearFilter ? Fe.NEAREST : Fe.LINEAR
        }

        function ge(t) {
            if (t === THREE.RepeatWrapping) return Fe.REPEAT;
            if (t === THREE.ClampToEdgeWrapping) return Fe.CLAMP_TO_EDGE;
            if (t === THREE.MirroredRepeatWrapping) return Fe.MIRRORED_REPEAT;
            if (t === THREE.NearestFilter) return Fe.NEAREST;
            if (t === THREE.NearestMipMapNearestFilter) return Fe.NEAREST_MIPMAP_NEAREST;
            if (t === THREE.NearestMipMapLinearFilter) return Fe.NEAREST_MIPMAP_LINEAR;
            if (t === THREE.LinearFilter) return Fe.LINEAR;
            if (t === THREE.LinearMipMapNearestFilter) return Fe.LINEAR_MIPMAP_NEAREST;
            if (t === THREE.LinearMipMapLinearFilter) return Fe.LINEAR_MIPMAP_LINEAR;
            if (t === THREE.UnsignedByteType) return Fe.UNSIGNED_BYTE;
            if (t === THREE.UnsignedShort4444Type) return Fe.UNSIGNED_SHORT_4_4_4_4;
            if (t === THREE.UnsignedShort5551Type) return Fe.UNSIGNED_SHORT_5_5_5_1;
            if (t === THREE.UnsignedShort565Type) return Fe.UNSIGNED_SHORT_5_6_5;
            if (t === THREE.ByteType) return Fe.BYTE;
            if (t === THREE.ShortType) return Fe.SHORT;
            if (t === THREE.UnsignedShortType) return Fe.UNSIGNED_SHORT;
            if (t === THREE.IntType) return Fe.INT;
            if (t === THREE.UnsignedIntType) return Fe.UNSIGNED_INT;
            if (t === THREE.FloatType) return Fe.FLOAT;
            if (t === THREE.AlphaFormat) return Fe.ALPHA;
            if (t === THREE.RGBFormat) return Fe.RGB;
            if (t === THREE.RGBAFormat) return Fe.RGBA;
            if (t === THREE.LuminanceFormat) return Fe.LUMINANCE;
            if (t === THREE.LuminanceAlphaFormat) return Fe.LUMINANCE_ALPHA;
            if (t === THREE.AddEquation) return Fe.FUNC_ADD;
            if (t === THREE.SubtractEquation) return Fe.FUNC_SUBTRACT;
            if (t === THREE.ReverseSubtractEquation) return Fe.FUNC_REVERSE_SUBTRACT;
            if (t === THREE.ZeroFactor) return Fe.ZERO;
            if (t === THREE.OneFactor) return Fe.ONE;
            if (t === THREE.SrcColorFactor) return Fe.SRC_COLOR;
            if (t === THREE.OneMinusSrcColorFactor) return Fe.ONE_MINUS_SRC_COLOR;
            if (t === THREE.SrcAlphaFactor) return Fe.SRC_ALPHA;
            if (t === THREE.OneMinusSrcAlphaFactor) return Fe.ONE_MINUS_SRC_ALPHA;
            if (t === THREE.DstAlphaFactor) return Fe.DST_ALPHA;
            if (t === THREE.OneMinusDstAlphaFactor) return Fe.ONE_MINUS_DST_ALPHA;
            if (t === THREE.DstColorFactor) return Fe.DST_COLOR;
            if (t === THREE.OneMinusDstColorFactor) return Fe.ONE_MINUS_DST_COLOR;
            if (t === THREE.SrcAlphaSaturateFactor) return Fe.SRC_ALPHA_SATURATE;
            if (void 0 !== Ne) {
                if (t === THREE.RGB_S3TC_DXT1_Format) return Ne.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === THREE.RGBA_S3TC_DXT1_Format) return Ne.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === THREE.RGBA_S3TC_DXT3_Format) return Ne.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === THREE.RGBA_S3TC_DXT5_Format) return Ne.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            return 0
        }

        function ve(t) {
            if (Cr && t && t.skeleton && t.skeleton.useVertexTexture) return 1024;
            var e = Fe.getParameter(Fe.MAX_VERTEX_UNIFORM_VECTORS),
                r = Math.floor((e - 20) / 4),
                n = r;
            return void 0 !== t && t instanceof THREE.SkinnedMesh && (n = Math.min(t.skeleton.bones.length, n), n < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + n + " (try OpenGL instead of ANGLE)")), n
        }

        function Ee(t) {
            for (var e = 0, r = 0, n = 0, i = 0, o = 0, a = t.length; a > o; o++) {
                var s = t[o];
                s.onlyShadow || s.visible === !1 || (s instanceof THREE.DirectionalLight && e++, s instanceof THREE.PointLight && r++, s instanceof THREE.SpotLight && n++, s instanceof THREE.HemisphereLight && i++)
            }
            return {
                directional: e,
                point: r,
                spot: n,
                hemi: i
            }
        }

        function ye(t) {
            for (var e = 0, r = 0, n = t.length; n > r; r++) {
                var i = t[r];
                i.castShadow && (i instanceof THREE.SpotLight && e++, i instanceof THREE.DirectionalLight && !i.shadowCascade && e++)
            }
            return e
        }

        function Te() {
            try {
                var t = {
                    alpha: we,
                    depth: He,
                    stencil: Me,
                    antialias: Se,
                    premultipliedAlpha: Ae,
                    preserveDrawingBuffer: Ce
                };
                if (Fe = be || _e.getContext("webgl", t) || _e.getContext("experimental-webgl", t), null === Fe) throw "Error creating WebGL context."
            } catch (e) {
                console.error(e)
            }
            Ue = Fe.getExtension("OES_texture_float"), Oe = Fe.getExtension("OES_texture_float_linear"), Be = Fe.getExtension("OES_standard_derivatives"), Ve = Fe.getExtension("EXT_texture_filter_anisotropic") || Fe.getExtension("MOZ_EXT_texture_filter_anisotropic") || Fe.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), Ne = Fe.getExtension("WEBGL_compressed_texture_s3tc") || Fe.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || Fe.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), je = Fe.getExtension("OES_element_index_uint"), null === Ue && console.log("THREE.WebGLRenderer: Float textures not supported."), null === Be && console.log("THREE.WebGLRenderer: Standard derivatives not supported."), null === Ve && console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."), null === Ne && console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."), null === je && console.log("THREE.WebGLRenderer: elementindex as unsigned integer not supported."), void 0 === Fe.getShaderPrecisionFormat && (Fe.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }), ke && (Ie = Fe.getExtension("EXT_frag_depth"))
        }

        function xe() {
            Fe.clearColor(0, 0, 0, 1), Fe.clearDepth(1), Fe.clearStencil(0), Fe.enable(Fe.DEPTH_TEST), Fe.depthFunc(Fe.LEQUAL), Fe.frontFace(Fe.CCW), Fe.cullFace(Fe.BACK), Fe.enable(Fe.CULL_FACE), Fe.enable(Fe.BLEND), Fe.blendEquation(Fe.FUNC_ADD), Fe.blendFunc(Fe.SRC_ALPHA, Fe.ONE_MINUS_SRC_ALPHA), Fe.viewport(lr, cr, pr, fr), Fe.clearColor(Le.r, Le.g, Le.b, ze)
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION), t = t || {};
        var _e = void 0 !== t.canvas ? t.canvas : document.createElement("canvas"),
            be = void 0 !== t.context ? t.context : null,
            Re = void 0 !== t.precision ? t.precision : "highp",
            we = void 0 !== t.alpha ? t.alpha : !1,
            He = void 0 !== t.depth ? t.depth : !0,
            Me = void 0 !== t.stencil ? t.stencil : !0,
            Se = void 0 !== t.antialias ? t.antialias : !1,
            Ae = void 0 !== t.premultipliedAlpha ? t.premultipliedAlpha : !0,
            Ce = void 0 !== t.preserveDrawingBuffer ? t.preserveDrawingBuffer : !1,
            ke = void 0 !== t.logarithmicDepthBuffer ? t.logarithmicDepthBuffer : !1,
            Le = new THREE.Color(0),
            ze = 0,
            Pe = [],
            De = [];
        this.domElement = _e, this.context = null, this.devicePixelRatio = void 0 !== t.devicePixelRatio ? t.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.gammaInput = !1, this.gammaOutput = !1, this.shadowMapEnabled = !1, this.shadowMapAutoUpdate = !0, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapDebug = !1, this.shadowMapCascade = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.renderPluginsPre = [], this.renderPluginsPost = [], this.info = {
            memory: {
                programs: 0,
                geometries: 0,
                textures: 0
            },
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            }
        };
        var Fe, Ue, Oe, Be, Ve, Ne, je, Ie, Ge = this,
            We = [],
            Xe = null,
            qe = null,
            Ye = -1,
            Ke = null,
            Ze = null,
            Qe = 0,
            Je = -1,
            $e = -1,
            tr = -1,
            er = -1,
            rr = -1,
            nr = -1,
            ir = -1,
            or = -1,
            ar = null,
            sr = null,
            hr = null,
            ur = null,
            lr = 0,
            cr = 0,
            pr = _e.width,
            fr = _e.height,
            dr = 0,
            mr = 0,
            gr = new Uint8Array(16),
            vr = new Uint8Array(16),
            Er = new THREE.Frustum,
            yr = new THREE.Matrix4,
            Tr = new THREE.Matrix4,
            xr = new THREE.Vector3,
            _r = new THREE.Vector3,
            br = !0,
            Rr = {
                ambient: [0, 0, 0],
                directional: {
                    length: 0,
                    colors: [],
                    positions: []
                },
                point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: []
                },
                spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: []
                },
                hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                }
            };
        Te(), xe(), this.context = Fe;
        var wr = Fe.getParameter(Fe.MAX_TEXTURE_IMAGE_UNITS),
            Hr = Fe.getParameter(Fe.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            Mr = (Fe.getParameter(Fe.MAX_TEXTURE_SIZE), Fe.getParameter(Fe.MAX_CUBE_MAP_TEXTURE_SIZE)),
            Sr = Ve ? Fe.getParameter(Ve.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
            Ar = Hr > 0,
            Cr = Ar && Ue,
            kr = (Ne ? Fe.getParameter(Fe.COMPRESSED_TEXTURE_FORMATS) : [], Fe.getShaderPrecisionFormat(Fe.VERTEX_SHADER, Fe.HIGH_FLOAT)),
            Lr = Fe.getShaderPrecisionFormat(Fe.VERTEX_SHADER, Fe.MEDIUM_FLOAT),
            zr = (Fe.getShaderPrecisionFormat(Fe.VERTEX_SHADER, Fe.LOW_FLOAT), Fe.getShaderPrecisionFormat(Fe.FRAGMENT_SHADER, Fe.HIGH_FLOAT)),
            Pr = Fe.getShaderPrecisionFormat(Fe.FRAGMENT_SHADER, Fe.MEDIUM_FLOAT),
            Dr = (Fe.getShaderPrecisionFormat(Fe.FRAGMENT_SHADER, Fe.LOW_FLOAT), kr.precision > 0 && zr.precision > 0),
            Fr = Lr.precision > 0 && Pr.precision > 0;
        "highp" !== Re || Dr || (Fr ? (Re = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (Re = "lowp", console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== Re || Fr || (Re = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp.")), this.getContext = function() {
            return Fe
        }, this.supportsVertexTextures = function() {
            return Ar
        }, this.supportsFloatTextures = function() {
            return Ue
        }, this.supportsStandardDerivatives = function() {
            return Be
        }, this.supportsCompressedTextureS3TC = function() {
            return Ne
        }, this.getMaxAnisotropy = function() {
            return Sr
        }, this.getPrecision = function() {
            return Re
        }, this.setSize = function(t, e, r) {
            _e.width = t * this.devicePixelRatio, _e.height = e * this.devicePixelRatio, r !== !1 && (_e.style.width = t + "px", _e.style.height = e + "px"), this.setViewport(0, 0, t, e)
        }, this.setViewport = function(t, e, r, n) {
            lr = t * this.devicePixelRatio, cr = e * this.devicePixelRatio, pr = r * this.devicePixelRatio, fr = n * this.devicePixelRatio, Fe.viewport(lr, cr, pr, fr)
        }, this.setScissor = function(t, e, r, n) {
            Fe.scissor(t * this.devicePixelRatio, e * this.devicePixelRatio, r * this.devicePixelRatio, n * this.devicePixelRatio)
        }, this.enableScissorTest = function(t) {
            t ? Fe.enable(Fe.SCISSOR_TEST) : Fe.disable(Fe.SCISSOR_TEST)
        }, this.setClearColor = function(t, e) {
            Le.set(t), ze = void 0 !== e ? e : 1, Fe.clearColor(Le.r, Le.g, Le.b, ze)
        }, this.setClearColorHex = function(t, e) {
            console.warn("THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(t, e)
        }, this.getClearColor = function() {
            return Le
        }, this.getClearAlpha = function() {
            return ze
        }, this.clear = function(t, e, r) {
            var n = 0;
            (void 0 === t || t) && (n |= Fe.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= Fe.DEPTH_BUFFER_BIT), (void 0 === r || r) && (n |= Fe.STENCIL_BUFFER_BIT), Fe.clear(n)
        }, this.clearColor = function() {
            Fe.clear(Fe.COLOR_BUFFER_BIT)
        }, this.clearDepth = function() {
            Fe.clear(Fe.DEPTH_BUFFER_BIT)
        }, this.clearStencil = function() {
            Fe.clear(Fe.STENCIL_BUFFER_BIT)
        }, this.clearTarget = function(t, e, r, n) {
            this.setRenderTarget(t), this.clear(e, r, n)
        }, this.addPostPlugin = function(t) {
            t.init(this), this.renderPluginsPost.push(t)
        }, this.addPrePlugin = function(t) {
            t.init(this), this.renderPluginsPre.push(t)
        }, this.updateShadowMap = function(t, e) {
            Xe = null, tr = -1, ir = -1, or = -1, Ke = -1, Ye = -1, br = !0, Je = -1, $e = -1, Xr(t), this.shadowMapPlugin.update(t, e)
        };
        var Ur = function(t) {
                var e = t.target;
                e.removeEventListener("dispose", Ur), jr(e)
            },
            Or = function(t) {
                var e = t.target;
                e.removeEventListener("dispose", Or), Ir(e), Ge.info.memory.textures--
            },
            Br = function(t) {
                var e = t.target;
                e.removeEventListener("dispose", Br), Gr(e), Ge.info.memory.textures--
            },
            Vr = function(t) {
                var e = t.target;
                e.removeEventListener("dispose", Vr), Wr(e)
            },
            Nr = function(t) {
                if (void 0 !== t.__webglVertexBuffer && Fe.deleteBuffer(t.__webglVertexBuffer), void 0 !== t.__webglNormalBuffer && Fe.deleteBuffer(t.__webglNormalBuffer), void 0 !== t.__webglTangentBuffer && Fe.deleteBuffer(t.__webglTangentBuffer), void 0 !== t.__webglColorBuffer && Fe.deleteBuffer(t.__webglColorBuffer), void 0 !== t.__webglUVBuffer && Fe.deleteBuffer(t.__webglUVBuffer), void 0 !== t.__webglUV2Buffer && Fe.deleteBuffer(t.__webglUV2Buffer), void 0 !== t.__webglSkinIndicesBuffer && Fe.deleteBuffer(t.__webglSkinIndicesBuffer), void 0 !== t.__webglSkinWeightsBuffer && Fe.deleteBuffer(t.__webglSkinWeightsBuffer), void 0 !== t.__webglFaceBuffer && Fe.deleteBuffer(t.__webglFaceBuffer), void 0 !== t.__webglLineBuffer && Fe.deleteBuffer(t.__webglLineBuffer), void 0 !== t.__webglLineDistanceBuffer && Fe.deleteBuffer(t.__webglLineDistanceBuffer), void 0 !== t.__webglCustomAttributesList)
                    for (var e in t.__webglCustomAttributesList) Fe.deleteBuffer(t.__webglCustomAttributesList[e].buffer);
                Ge.info.memory.geometries--
            },
            jr = function(t) {
                if (t.__webglInit = void 0, t instanceof THREE.BufferGeometry) {
                    var e = t.attributes;
                    for (var r in e) void 0 !== e[r].buffer && Fe.deleteBuffer(e[r].buffer);
                    Ge.info.memory.geometries--
                } else if (void 0 !== t.geometryGroups)
                    for (var n = 0, i = t.geometryGroupsList.length; i > n; n++) {
                        var o = t.geometryGroupsList[n];
                        if (void 0 !== o.numMorphTargets)
                            for (var a = 0, s = o.numMorphTargets; s > a; a++) Fe.deleteBuffer(o.__webglMorphTargetsBuffers[a]);
                        if (void 0 !== o.numMorphNormals)
                            for (var a = 0, s = o.numMorphNormals; s > a; a++) Fe.deleteBuffer(o.__webglMorphNormalsBuffers[a]);
                        Nr(o)
                    } else Nr(t)
            },
            Ir = function(t) {
                if (t.image && t.image.__webglTextureCube) Fe.deleteTexture(t.image.__webglTextureCube);
                else {
                    if (!t.__webglInit) return;
                    t.__webglInit = !1, Fe.deleteTexture(t.__webglTexture)
                }
            },
            Gr = function(t) {
                if (t && t.__webglTexture)
                    if (Fe.deleteTexture(t.__webglTexture), t instanceof THREE.WebGLRenderTargetCube)
                        for (var e = 0; 6 > e; e++) Fe.deleteFramebuffer(t.__webglFramebuffer[e]), Fe.deleteRenderbuffer(t.__webglRenderbuffer[e]);
                    else Fe.deleteFramebuffer(t.__webglFramebuffer), Fe.deleteRenderbuffer(t.__webglRenderbuffer)
            },
            Wr = function(t) {
                var e = t.program.program;
                if (void 0 !== e) {
                    t.program = void 0;
                    var r, n, i, o = !1;
                    for (r = 0, n = We.length; n > r; r++)
                        if (i = We[r], i.program === e) {
                            i.usedTimes--, 0 === i.usedTimes && (o = !0);
                            break
                        }
                    if (o === !0) {
                        var a = [];
                        for (r = 0, n = We.length; n > r; r++) i = We[r], i.program !== e && a.push(i);
                        We = a, Fe.deleteProgram(e), Ge.info.memory.programs--
                    }
                }
            };
        this.renderBufferImmediate = function(t, e, r) {
            if (y(), t.hasPositions && !t.__webglVertexBuffer && (t.__webglVertexBuffer = Fe.createBuffer()), t.hasNormals && !t.__webglNormalBuffer && (t.__webglNormalBuffer = Fe.createBuffer()), t.hasUvs && !t.__webglUvBuffer && (t.__webglUvBuffer = Fe.createBuffer()), t.hasColors && !t.__webglColorBuffer && (t.__webglColorBuffer = Fe.createBuffer()), t.hasPositions && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglVertexBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, t.positionArray, Fe.DYNAMIC_DRAW), T(e.attributes.position), Fe.vertexAttribPointer(e.attributes.position, 3, Fe.FLOAT, !1, 0, 0)), t.hasNormals) {
                if (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglNormalBuffer), r.shading === THREE.FlatShading) {
                    var n, i, o, a, s, h, u, l, c, p, f, d, m, g, v = 3 * t.count;
                    for (g = 0; v > g; g += 9) m = t.normalArray, a = m[g], u = m[g + 1], p = m[g + 2], s = m[g + 3], l = m[g + 4], f = m[g + 5], h = m[g + 6], c = m[g + 7], d = m[g + 8], n = (a + s + h) / 3, i = (u + l + c) / 3, o = (p + f + d) / 3, m[g] = n, m[g + 1] = i, m[g + 2] = o, m[g + 3] = n, m[g + 4] = i, m[g + 5] = o, m[g + 6] = n, m[g + 7] = i, m[g + 8] = o
                }
                Fe.bufferData(Fe.ARRAY_BUFFER, t.normalArray, Fe.DYNAMIC_DRAW), T(e.attributes.normal), Fe.vertexAttribPointer(e.attributes.normal, 3, Fe.FLOAT, !1, 0, 0)
            }
            t.hasUvs && r.map && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglUvBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, t.uvArray, Fe.DYNAMIC_DRAW), T(e.attributes.uv), Fe.vertexAttribPointer(e.attributes.uv, 2, Fe.FLOAT, !1, 0, 0)), t.hasColors && r.vertexColors !== THREE.NoColors && (Fe.bindBuffer(Fe.ARRAY_BUFFER, t.__webglColorBuffer), Fe.bufferData(Fe.ARRAY_BUFFER, t.colorArray, Fe.DYNAMIC_DRAW), T(e.attributes.color), Fe.vertexAttribPointer(e.attributes.color, 3, Fe.FLOAT, !1, 0, 0)), x(), Fe.drawArrays(Fe.TRIANGLES, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, r, n, i, o) {
            if (n.visible !== !1) {
                var a = j(t, e, r, n, o),
                    s = a.attributes,
                    h = i.attributes,
                    u = !1,
                    l = n.wireframe ? 1 : 0,
                    c = 16777215 * i.id + 2 * a.id + l;
                if (c !== Ke && (Ke = c, u = !0), u && y(), o instanceof THREE.Mesh) {
                    var p = h.index;
                    if (p) {
                        var f, d;
                        p.array instanceof Uint32Array ? (f = Fe.UNSIGNED_INT, d = 4) : (f = Fe.UNSIGNED_SHORT, d = 2);
                        var m = i.offsets;
                        if (0 === m.length) u && (E(n, s, h, 0), Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, p.buffer)), Fe.drawElements(Fe.TRIANGLES, p.array.length, f, 0), Ge.info.render.calls++, Ge.info.render.vertices += p.array.length, Ge.info.render.faces += p.array.length / 3;
                        else {
                            u = !0;
                            for (var g = 0, v = m.length; v > g; g++) {
                                var T = m[g].index;
                                u && (E(n, s, h, T), Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, p.buffer)), Fe.drawElements(Fe.TRIANGLES, m[g].count, f, m[g].start * d), Ge.info.render.calls++, Ge.info.render.vertices += m[g].count, Ge.info.render.faces += m[g].count / 3
                            }
                        }
                    } else {
                        u && E(n, s, h, 0);
                        var x = i.attributes.position;
                        Fe.drawArrays(Fe.TRIANGLES, 0, x.array.length / 3), Ge.info.render.calls++, Ge.info.render.vertices += x.array.length / 3, Ge.info.render.faces += x.array.length / 9
                    }
                } else if (o instanceof THREE.PointCloud) {
                    u && E(n, s, h, 0);
                    var x = h.position;
                    Fe.drawArrays(Fe.POINTS, 0, x.array.length / 3), Ge.info.render.calls++, Ge.info.render.points += x.array.length / 3
                } else if (o instanceof THREE.Line) {
                    var _ = o.type === THREE.LineStrip ? Fe.LINE_STRIP : Fe.LINES;
                    ae(n.linewidth);
                    var p = h.index;
                    if (p) {
                        var f, d;
                        p.array instanceof Uint32Array ? (f = Fe.UNSIGNED_INT, d = 4) : (f = Fe.UNSIGNED_SHORT, d = 2);
                        var m = i.offsets;
                        if (0 === m.length) u && (E(n, s, h, 0), Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, p.buffer)), Fe.drawElements(_, p.array.length, f, 0), Ge.info.render.calls++, Ge.info.render.vertices += p.array.length;
                        else {
                            m.length > 1 && (u = !0);
                            for (var g = 0, v = m.length; v > g; g++) {
                                var T = m[g].index;
                                u && (E(n, s, h, T), Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, p.buffer)), Fe.drawElements(_, m[g].count, f, m[g].start * d), Ge.info.render.calls++, Ge.info.render.vertices += m[g].count
                            }
                        }
                    } else {
                        u && E(n, s, h, 0);
                        var x = h.position;
                        Fe.drawArrays(_, 0, x.array.length / 3), Ge.info.render.calls++, Ge.info.render.points += x.array.length / 3
                    }
                }
            }
        }, this.renderBuffer = function(t, e, r, n, i, o) {
            if (n.visible !== !1) {
                var a, s, h, u = j(t, e, r, n, o),
                    l = u.attributes,
                    c = !1,
                    p = n.wireframe ? 1 : 0,
                    f = 16777215 * i.id + 2 * u.id + p;
                if (f !== Ke && (Ke = f, c = !0), c && y(), !n.morphTargets && l.position >= 0 ? c && (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglVertexBuffer), T(l.position), Fe.vertexAttribPointer(l.position, 3, Fe.FLOAT, !1, 0, 0)) : o.morphTargetBase && _(n, i, o), c) {
                    if (i.__webglCustomAttributesList)
                        for (s = 0, h = i.__webglCustomAttributesList.length; h > s; s++) a = i.__webglCustomAttributesList[s], l[a.buffer.belongsToAttribute] >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, a.buffer), T(l[a.buffer.belongsToAttribute]), Fe.vertexAttribPointer(l[a.buffer.belongsToAttribute], a.size, Fe.FLOAT, !1, 0, 0));
                    l.color >= 0 && (o.geometry.colors.length > 0 || o.geometry.faces.length > 0 ? (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglColorBuffer), T(l.color), Fe.vertexAttribPointer(l.color, 3, Fe.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && Fe.vertexAttrib3fv(l.color, n.defaultAttributeValues.color)), l.normal >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglNormalBuffer), T(l.normal), Fe.vertexAttribPointer(l.normal, 3, Fe.FLOAT, !1, 0, 0)), l.tangent >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglTangentBuffer), T(l.tangent), Fe.vertexAttribPointer(l.tangent, 4, Fe.FLOAT, !1, 0, 0)), l.uv >= 0 && (o.geometry.faceVertexUvs[0] ? (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglUVBuffer), T(l.uv), Fe.vertexAttribPointer(l.uv, 2, Fe.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && Fe.vertexAttrib2fv(l.uv, n.defaultAttributeValues.uv)), l.uv2 >= 0 && (o.geometry.faceVertexUvs[1] ? (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglUV2Buffer), T(l.uv2), Fe.vertexAttribPointer(l.uv2, 2, Fe.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && Fe.vertexAttrib2fv(l.uv2, n.defaultAttributeValues.uv2)), n.skinning && l.skinIndex >= 0 && l.skinWeight >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglSkinIndicesBuffer), T(l.skinIndex), Fe.vertexAttribPointer(l.skinIndex, 4, Fe.FLOAT, !1, 0, 0), Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglSkinWeightsBuffer), T(l.skinWeight), Fe.vertexAttribPointer(l.skinWeight, 4, Fe.FLOAT, !1, 0, 0)), l.lineDistance >= 0 && (Fe.bindBuffer(Fe.ARRAY_BUFFER, i.__webglLineDistanceBuffer), T(l.lineDistance), Fe.vertexAttribPointer(l.lineDistance, 1, Fe.FLOAT, !1, 0, 0))
                }
                if (x(), o instanceof THREE.Mesh) {
                    var d = i.__typeArray === Uint32Array ? Fe.UNSIGNED_INT : Fe.UNSIGNED_SHORT;
                    n.wireframe ? (ae(n.wireframeLinewidth), c && Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), Fe.drawElements(Fe.LINES, i.__webglLineCount, d, 0)) : (c && Fe.bindBuffer(Fe.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), Fe.drawElements(Fe.TRIANGLES, i.__webglFaceCount, d, 0)), Ge.info.render.calls++, Ge.info.render.vertices += i.__webglFaceCount, Ge.info.render.faces += i.__webglFaceCount / 3
                } else if (o instanceof THREE.Line) {
                    var m = o.type === THREE.LineStrip ? Fe.LINE_STRIP : Fe.LINES;
                    ae(n.linewidth), Fe.drawArrays(m, 0, i.__webglLineCount), Ge.info.render.calls++
                } else o instanceof THREE.PointCloud && (Fe.drawArrays(Fe.POINTS, 0, i.__webglParticleCount), Ge.info.render.calls++, Ge.info.render.points += i.__webglParticleCount)
            }
        }, this.render = function(t, e, r, n) {
            function i(t) {
                t instanceof THREE.SkinnedMesh && t.skeleton.update();
                for (var e = 0, r = t.children.length; r > e; e++) i(t.children[e])
            }
            if (e instanceof THREE.Camera == !1) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            var o, a, s, h, u, l = t.__lights,
                c = t.fog;
            for (Ye = -1, Ze = null, br = !0, t.autoUpdate === !0 && t.updateMatrixWorld(), void 0 === e.parent && e.updateMatrixWorld(), i(t), e.matrixWorldInverse.getInverse(e.matrixWorld), yr.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Er.setFromMatrix(yr), Xr(t), Pe.length = 0, De.length = 0, H(t, t, e), Ge.sortObjects === !0 && (Pe.sort(b), De.sort(R)), M(this.renderPluginsPre, t, e), Ge.info.render.calls = 0, Ge.info.render.vertices = 0, Ge.info.render.faces = 0, Ge.info.render.points = 0, this.setRenderTarget(r), (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), u = t.__webglObjectsImmediate, o = 0, a = u.length; a > o; o++) s = u[o], h = s.object, h.visible && (re(h, e), C(s));
            if (t.overrideMaterial) {
                var p = t.overrideMaterial;
                this.setBlending(p.blending, p.blendEquation, p.blendSrc, p.blendDst), this.setDepthTest(p.depthTest), this.setDepthWrite(p.depthWrite), se(p.polygonOffset, p.polygonOffsetFactor, p.polygonOffsetUnits), S(Pe, e, l, c, !0, p), S(De, e, l, c, !0, p), A(t.__webglObjectsImmediate, "", e, l, c, !1, p)
            } else {
                var p = null;
                this.setBlending(THREE.NoBlending), S(Pe, e, l, c, !1, p), A(t.__webglObjectsImmediate, "opaque", e, l, c, !1, p), S(De, e, l, c, !0, p), A(t.__webglObjectsImmediate, "transparent", e, l, c, !0, p)
            }
            M(this.renderPluginsPost, t, e), r && r.generateMipmaps && r.minFilter !== THREE.NearestFilter && r.minFilter !== THREE.LinearFilter && de(r), this.setDepthTest(!0), this.setDepthWrite(!0)
        }, this.renderImmediateObject = function(t, e, r, n, i) {
            var o = j(t, e, r, n, i);
            Ke = -1, Ge.setMaterialFaces(n), i.immediateRenderCallback ? i.immediateRenderCallback(o, Fe, Er) : i.render(function(t) {
                Ge.renderBufferImmediate(t, o, n)
            })
        };
        var Xr = function(t) {
            for (t.__webglObjects || (t.__webglObjects = {}, t.__webglObjectsImmediate = []); t.__objectsAdded.length;) L(t.__objectsAdded[0], t), t.__objectsAdded.splice(0, 1);
            for (; t.__objectsRemoved.length;) B(t.__objectsRemoved[0], t), t.__objectsRemoved.splice(0, 1)
        };
        this.initMaterial = function(t, e, r, n) {
            t.addEventListener("dispose", Vr);
            var i, o, a, s, h, u, l;
            if (t instanceof THREE.MeshDepthMaterial ? l = "depth" : t instanceof THREE.MeshNormalMaterial ? l = "normal" : t instanceof THREE.MeshBasicMaterial ? l = "basic" : t instanceof THREE.MeshLambertMaterial ? l = "lambert" : t instanceof THREE.MeshPhongMaterial ? l = "phong" : t instanceof THREE.LineBasicMaterial ? l = "basic" : t instanceof THREE.LineDashedMaterial ? l = "dashed" : t instanceof THREE.PointCloudMaterial && (l = "particle_basic"), l) {
                var c = THREE.ShaderLib[l];
                t.__webglShader = {
                    uniforms: THREE.UniformsUtils.clone(c.uniforms),
                    vertexShader: c.vertexShader,
                    fragmentShader: c.fragmentShader
                }
            } else t.__webglShader = {
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            };
            s = Ee(e), u = ye(e), h = ve(n), a = {
                precision: Re,
                supportsVertexTextures: Ar,
                map: !!t.map,
                envMap: !!t.envMap,
                lightMap: !!t.lightMap,
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                vertexColors: t.vertexColors,
                fog: r,
                useFog: t.fog,
                fogExp: r instanceof THREE.FogExp2,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: ke,
                skinning: t.skinning,
                maxBones: h,
                useVertexTexture: Cr && n && n.skeleton && n.skeleton.useVertexTexture,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: this.maxMorphTargets,
                maxMorphNormals: this.maxMorphNormals,
                maxDirLights: s.directional,
                maxPointLights: s.point,
                maxSpotLights: s.spot,
                maxHemiLights: s.hemi,
                maxShadows: u,
                shadowMapEnabled: this.shadowMapEnabled && n.receiveShadow && u > 0,
                shadowMapType: this.shadowMapType,
                shadowMapDebug: this.shadowMapDebug,
                shadowMapCascade: this.shadowMapCascade,
                alphaTest: t.alphaTest,
                metal: t.metal,
                wrapAround: t.wrapAround,
                doubleSided: t.side === THREE.DoubleSide,
                flipSided: t.side === THREE.BackSide
            };
            var p = [];
            l ? p.push(l) : (p.push(t.fragmentShader), p.push(t.vertexShader));
            for (var f in t.defines) p.push(f), p.push(t.defines[f]);
            for (var d in a) p.push(d), p.push(a[d]);
            for (var m, g = p.join(), d = 0, v = We.length; v > d; d++) {
                var E = We[d];
                if (E.code === g) {
                    m = E, m.usedTimes++;
                    break
                }
            }
            void 0 === m && (m = new THREE.WebGLProgram(this, g, t, a), We.push(m), Ge.info.memory.programs = We.length), t.program = m;
            var y = t.program.attributes;
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                var T, x = "morphTarget";
                for (o = 0; o < this.maxMorphTargets; o++) T = x + o, y[T] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                var T, x = "morphNormal";
                for (o = 0; o < this.maxMorphNormals; o++) T = x + o, y[T] >= 0 && t.numSupportedMorphNormals++
            }
            t.uniformsList = [];
            for (i in t.__webglShader.uniforms) {
                var _ = t.program.uniforms[i];
                _ && t.uniformsList.push([t.__webglShader.uniforms[i], _])
            }
        }, this.setFaceCulling = function(t, e) {
            t === THREE.CullFaceNone ? Fe.disable(Fe.CULL_FACE) : (Fe.frontFace(e === THREE.FrontFaceDirectionCW ? Fe.CW : Fe.CCW), Fe.cullFace(t === THREE.CullFaceBack ? Fe.BACK : t === THREE.CullFaceFront ? Fe.FRONT : Fe.FRONT_AND_BACK), Fe.enable(Fe.CULL_FACE))
        }, this.setMaterialFaces = function(t) {
            var e = t.side === THREE.DoubleSide,
                r = t.side === THREE.BackSide;
            Je !== e && (e ? Fe.disable(Fe.CULL_FACE) : Fe.enable(Fe.CULL_FACE), Je = e), $e !== r && (Fe.frontFace(r ? Fe.CW : Fe.CCW), $e = r)
        }, this.setDepthTest = function(t) {
            ir !== t && (t ? Fe.enable(Fe.DEPTH_TEST) : Fe.disable(Fe.DEPTH_TEST), ir = t)
        }, this.setDepthWrite = function(t) {
            or !== t && (Fe.depthMask(t), or = t)
        }, this.setBlending = function(t, e, r, n) {
            t !== tr && (t === THREE.NoBlending ? Fe.disable(Fe.BLEND) : t === THREE.AdditiveBlending ? (Fe.enable(Fe.BLEND), Fe.blendEquation(Fe.FUNC_ADD), Fe.blendFunc(Fe.SRC_ALPHA, Fe.ONE)) : t === THREE.SubtractiveBlending ? (Fe.enable(Fe.BLEND), Fe.blendEquation(Fe.FUNC_ADD), Fe.blendFunc(Fe.ZERO, Fe.ONE_MINUS_SRC_COLOR)) : t === THREE.MultiplyBlending ? (Fe.enable(Fe.BLEND), Fe.blendEquation(Fe.FUNC_ADD), Fe.blendFunc(Fe.ZERO, Fe.SRC_COLOR)) : t === THREE.CustomBlending ? Fe.enable(Fe.BLEND) : (Fe.enable(Fe.BLEND), Fe.blendEquationSeparate(Fe.FUNC_ADD, Fe.FUNC_ADD), Fe.blendFuncSeparate(Fe.SRC_ALPHA, Fe.ONE_MINUS_SRC_ALPHA, Fe.ONE, Fe.ONE_MINUS_SRC_ALPHA)), tr = t), t === THREE.CustomBlending ? (e !== er && (Fe.blendEquation(ge(e)), er = e), (r !== rr || n !== nr) && (Fe.blendFunc(ge(r), ge(n)), rr = r, nr = n)) : (er = null, rr = null, nr = null)
        }, this.setTexture = function(t, e) {
            if (t.needsUpdate) {
                t.__webglInit || (t.__webglInit = !0, t.addEventListener("dispose", Or), t.__webglTexture = Fe.createTexture(), Ge.info.memory.textures++), Fe.activeTexture(Fe.TEXTURE0 + e), Fe.bindTexture(Fe.TEXTURE_2D, t.__webglTexture), Fe.pixelStorei(Fe.UNPACK_FLIP_Y_WEBGL, t.flipY), Fe.pixelStorei(Fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), Fe.pixelStorei(Fe.UNPACK_ALIGNMENT, t.unpackAlignment);
                var r = t.image,
                    n = THREE.Math.isPowerOfTwo(r.width) && THREE.Math.isPowerOfTwo(r.height),
                    i = ge(t.format),
                    o = ge(t.type);
                he(Fe.TEXTURE_2D, t, n);
                var a, s = t.mipmaps;
                if (t instanceof THREE.DataTexture)
                    if (s.length > 0 && n) {
                        for (var h = 0, u = s.length; u > h; h++) a = s[h], Fe.texImage2D(Fe.TEXTURE_2D, h, i, a.width, a.height, 0, i, o, a.data);
                        t.generateMipmaps = !1
                    } else Fe.texImage2D(Fe.TEXTURE_2D, 0, i, r.width, r.height, 0, i, o, r.data);
                else if (t instanceof THREE.CompressedTexture)
                    for (var h = 0, u = s.length; u > h; h++) a = s[h], t.format !== THREE.RGBAFormat ? Fe.compressedTexImage2D(Fe.TEXTURE_2D, h, i, a.width, a.height, 0, a.data) : Fe.texImage2D(Fe.TEXTURE_2D, h, i, a.width, a.height, 0, i, o, a.data);
                else if (s.length > 0 && n) {
                    for (var h = 0, u = s.length; u > h; h++) a = s[h], Fe.texImage2D(Fe.TEXTURE_2D, h, i, i, o, a);
                    t.generateMipmaps = !1
                } else Fe.texImage2D(Fe.TEXTURE_2D, 0, i, i, o, t.image);
                t.generateMipmaps && n && Fe.generateMipmap(Fe.TEXTURE_2D), t.needsUpdate = !1, t.onUpdate && t.onUpdate()
            } else Fe.activeTexture(Fe.TEXTURE0 + e), Fe.bindTexture(Fe.TEXTURE_2D, t.__webglTexture)
        }, this.setRenderTarget = function(t) {
            var e = t instanceof THREE.WebGLRenderTargetCube;
            if (t && !t.__webglFramebuffer) {
                void 0 === t.depthBuffer && (t.depthBuffer = !0), void 0 === t.stencilBuffer && (t.stencilBuffer = !0), t.addEventListener("dispose", Br), t.__webglTexture = Fe.createTexture(), Ge.info.memory.textures++;
                var r = THREE.Math.isPowerOfTwo(t.width) && THREE.Math.isPowerOfTwo(t.height),
                    n = ge(t.format),
                    i = ge(t.type);
                if (e) {
                    t.__webglFramebuffer = [], t.__webglRenderbuffer = [], Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, t.__webglTexture), he(Fe.TEXTURE_CUBE_MAP, t, r);
                    for (var o = 0; 6 > o; o++) t.__webglFramebuffer[o] = Fe.createFramebuffer(), t.__webglRenderbuffer[o] = Fe.createRenderbuffer(), Fe.texImage2D(Fe.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, n, t.width, t.height, 0, n, i, null), pe(t.__webglFramebuffer[o], t, Fe.TEXTURE_CUBE_MAP_POSITIVE_X + o), fe(t.__webglRenderbuffer[o], t);
                    r && Fe.generateMipmap(Fe.TEXTURE_CUBE_MAP)
                } else t.__webglFramebuffer = Fe.createFramebuffer(), t.__webglRenderbuffer = t.shareDepthFrom ? t.shareDepthFrom.__webglRenderbuffer : Fe.createRenderbuffer(), Fe.bindTexture(Fe.TEXTURE_2D, t.__webglTexture), he(Fe.TEXTURE_2D, t, r), Fe.texImage2D(Fe.TEXTURE_2D, 0, n, t.width, t.height, 0, n, i, null), pe(t.__webglFramebuffer, t, Fe.TEXTURE_2D), t.shareDepthFrom ? t.depthBuffer && !t.stencilBuffer ? Fe.framebufferRenderbuffer(Fe.FRAMEBUFFER, Fe.DEPTH_ATTACHMENT, Fe.RENDERBUFFER, t.__webglRenderbuffer) : t.depthBuffer && t.stencilBuffer && Fe.framebufferRenderbuffer(Fe.FRAMEBUFFER, Fe.DEPTH_STENCIL_ATTACHMENT, Fe.RENDERBUFFER, t.__webglRenderbuffer) : fe(t.__webglRenderbuffer, t), r && Fe.generateMipmap(Fe.TEXTURE_2D);
                e ? Fe.bindTexture(Fe.TEXTURE_CUBE_MAP, null) : Fe.bindTexture(Fe.TEXTURE_2D, null), Fe.bindRenderbuffer(Fe.RENDERBUFFER, null), Fe.bindFramebuffer(Fe.FRAMEBUFFER, null)
            }
            var a, s, h, u, l;
            t ? (a = e ? t.__webglFramebuffer[t.activeCubeFace] : t.__webglFramebuffer, s = t.width, h = t.height, u = 0, l = 0) : (a = null, s = pr, h = fr, u = lr, l = cr), a !== qe && (Fe.bindFramebuffer(Fe.FRAMEBUFFER, a), Fe.viewport(u, l, s, h), qe = a), dr = s, mr = h
        }, this.shadowMapPlugin = new THREE.ShadowMapPlugin, this.addPrePlugin(this.shadowMapPlugin), this.addPostPlugin(new THREE.SpritePlugin), this.addPostPlugin(new THREE.LensFlarePlugin)
    }, THREE.WebGLRenderTarget = function(t, e, r) {
        this.width = t, this.height = e, r = r || {}, this.wrapS = void 0 !== r.wrapS ? r.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r.wrapT ? r.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== r.magFilter ? r.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== r.minFilter ? r.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== r.format ? r.format : THREE.RGBAFormat, this.type = void 0 !== r.type ? r.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== r.depthBuffer ? r.depthBuffer : !0, this.stencilBuffer = void 0 !== r.stencilBuffer ? r.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = null
    }, THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        setSize: function(t, e) {
            this.width = t, this.height = e
        },
        clone: function() {
            var t = new THREE.WebGLRenderTarget(this.width, this.height);
            return t.wrapS = this.wrapS, t.wrapT = this.wrapT, t.magFilter = this.magFilter, t.minFilter = this.minFilter, t.anisotropy = this.anisotropy, t.offset.copy(this.offset), t.repeat.copy(this.repeat), t.format = this.format, t.type = this.type, t.depthBuffer = this.depthBuffer, t.stencilBuffer = this.stencilBuffer, t.generateMipmaps = this.generateMipmaps, t.shareDepthFrom = this.shareDepthFrom, t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(t, e, r) {
        THREE.WebGLRenderTarget.call(this, t, e, r), this.activeCubeFace = 0
    }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLProgram = function() {
        var t = 0,
            e = function(t) {
                var e, r, n = [];
                for (var i in t) e = t[i], e !== !1 && (r = "#define " + i + " " + e, n.push(r));
                return n.join("\n")
            },
            r = function(t, e, r) {
                for (var n = {}, i = 0, o = r.length; o > i; i++) {
                    var a = r[i];
                    n[a] = t.getUniformLocation(e, a)
                }
                return n
            },
            n = function(t, e, r) {
                for (var n = {}, i = 0, o = r.length; o > i; i++) {
                    var a = r[i];
                    n[a] = t.getAttribLocation(e, a)
                }
                return n
            };
        return function(i, o, a, s) {
            var h = i,
                u = h.context,
                l = a.defines,
                c = a.__webglShader.uniforms,
                p = a.attributes,
                f = a.__webglShader.vertexShader,
                d = a.__webglShader.fragmentShader,
                m = a.index0AttributeName;
            void 0 === m && s.morphTargets === !0 && (m = "position");
            var g = "SHADOWMAP_TYPE_BASIC";
            s.shadowMapType === THREE.PCFShadowMap ? g = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === THREE.PCFSoftShadowMap && (g = "SHADOWMAP_TYPE_PCF_SOFT");
            var v, E, y = e(l),
                T = u.createProgram();
            a instanceof THREE.RawShaderMaterial ? (v = "", E = "") : (v = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", y, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", h.gammaInput ? "#define GAMMA_INPUT" : "", h.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + s.maxDirLights, "#define MAX_POINT_LIGHTS " + s.maxPointLights, "#define MAX_SPOT_LIGHTS " + s.maxSpotLights, "#define MAX_HEMI_LIGHTS " + s.maxHemiLights, "#define MAX_SHADOWS " + s.maxShadows, "#define MAX_BONES " + s.maxBones, s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals ? "#define USE_MORPHNORMALS" : "", s.wrapAround ? "#define WRAP_AROUND" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + g : "", s.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", s.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", ""].join("\n"), E = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", s.bumpMap || s.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", y, "#define MAX_DIR_LIGHTS " + s.maxDirLights, "#define MAX_POINT_LIGHTS " + s.maxPointLights, "#define MAX_SPOT_LIGHTS " + s.maxSpotLights, "#define MAX_HEMI_LIGHTS " + s.maxHemiLights, "#define MAX_SHADOWS " + s.maxShadows, s.alphaTest ? "#define ALPHATEST " + s.alphaTest : "", h.gammaInput ? "#define GAMMA_INPUT" : "", h.gammaOutput ? "#define GAMMA_OUTPUT" : "", s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexColors ? "#define USE_COLOR" : "", s.metal ? "#define METAL" : "", s.wrapAround ? "#define WRAP_AROUND" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + g : "", s.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", s.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", ""].join("\n"));
            var x = new THREE.WebGLShader(u, u.VERTEX_SHADER, v + f),
                _ = new THREE.WebGLShader(u, u.FRAGMENT_SHADER, E + d);
            u.attachShader(T, x), u.attachShader(T, _), void 0 !== m && u.bindAttribLocation(T, 0, m), u.linkProgram(T), u.getProgramParameter(T, u.LINK_STATUS) === !1 && (console.error("THREE.WebGLProgram: Could not initialise shader."), console.error("gl.VALIDATE_STATUS", u.getProgramParameter(T, u.VALIDATE_STATUS)), console.error("gl.getError()", u.getError())), "" !== u.getProgramInfoLog(T) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", u.getProgramInfoLog(T)), u.deleteShader(x), u.deleteShader(_);
            var b = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences", "bindMatrix", "bindMatrixInverse"];
            s.useVertexTexture ? (b.push("boneTexture"), b.push("boneTextureWidth"), b.push("boneTextureHeight")) : b.push("boneGlobalMatrices"), s.logarithmicDepthBuffer && b.push("logDepthBufFC");
            for (var R in c) b.push(R);
            this.uniforms = r(u, T, b), b = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"];
            for (var w = 0; w < s.maxMorphTargets; w++) b.push("morphTarget" + w);
            for (var w = 0; w < s.maxMorphNormals; w++) b.push("morphNormal" + w);
            for (var H in p) b.push(H);
            return this.attributes = n(u, T, b), this.id = t++, this.code = o, this.usedTimes = 1, this.program = T, this.vertexShader = x, this.fragmentShader = _, this
        }
    }(), THREE.WebGLShader = function() {
        var t = function(t) {
            for (var e = t.split("\n"), r = 0; r < e.length; r++) e[r] = r + 1 + ": " + e[r];
            return e.join("\n")
        };
        return function(e, r, n) {
            var i = e.createShader(r);
            return e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(i) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e.getShaderInfoLog(i)), console.warn(t(n))), i
        }
    }(), THREE.RenderableVertex = function() {
        this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
    }, THREE.RenderableVertex.prototype.copy = function(t) {
        this.positionWorld.copy(t.positionWorld), this.positionScreen.copy(t.positionScreen)
    }, THREE.RenderableFace = function() {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0
    }, THREE.RenderableObject = function() {
        this.id = 0, this.object = null, this.z = 0
    }, THREE.RenderableSprite = function() {
        this.id = 0, this.object = null, this.x = 0, this.y = 0, this.z = 0, this.rotation = 0, this.scale = new THREE.Vector2, this.material = null
    }, THREE.RenderableLine = function() {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
    }, THREE.GeometryUtils = {
        merge: function(t, e, r) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var n;
            e instanceof THREE.Mesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, r)
        },
        center: function(t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
        }
    }, THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(t, e, r, n) {
            var i = new THREE.ImageLoader;
            i.crossOrigin = this.crossOrigin;
            var o = new THREE.Texture(void 0, e);
            return i.load(t, function(t) {
                o.image = t, o.needsUpdate = !0, r && r(o)
            }, void 0, function(t) {
                n && n(t)
            }), o.sourceFile = t, o
        },
        loadTextureCube: function(t, e, r) {
            var n = [],
                i = new THREE.ImageLoader;
            i.crossOrigin = this.crossOrigin;
            var o = new THREE.CubeTexture(n, e);
            o.flipY = !1;
            for (var a = 0, s = function(e) {
                    i.load(t[e], function(t) {
                        o.images[e] = t, a += 1, 6 === a && (o.needsUpdate = !0, r && r(o))
                    })
                }, h = 0, u = t.length; u > h; ++h) s(h);
            return o
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        },
        getNormalMap: function(t, e) {
            var r = function(t, e) {
                    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
                },
                n = function(t, e) {
                    return [t[0] - e[0], t[1] - e[1], t[2] - e[2]]
                },
                i = function(t) {
                    var e = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
                    return [t[0] / e, t[1] / e, t[2] / e]
                };
            e = 1 | e;
            var o = t.width,
                a = t.height,
                s = document.createElement("canvas");
            s.width = o, s.height = a;
            var h = s.getContext("2d");
            h.drawImage(t, 0, 0);
            for (var u = h.getImageData(0, 0, o, a).data, l = h.createImageData(o, a), c = l.data, p = 0; o > p; p++)
                for (var f = 0; a > f; f++) {
                    var d = 0 > f - 1 ? 0 : f - 1,
                        m = f + 1 > a - 1 ? a - 1 : f + 1,
                        g = 0 > p - 1 ? 0 : p - 1,
                        v = p + 1 > o - 1 ? o - 1 : p + 1,
                        E = [],
                        y = [0, 0, u[4 * (f * o + p)] / 255 * e];
                    E.push([-1, 0, u[4 * (f * o + g)] / 255 * e]), E.push([-1, -1, u[4 * (d * o + g)] / 255 * e]), E.push([0, -1, u[4 * (d * o + p)] / 255 * e]), E.push([1, -1, u[4 * (d * o + v)] / 255 * e]), E.push([1, 0, u[4 * (f * o + v)] / 255 * e]), E.push([1, 1, u[4 * (m * o + v)] / 255 * e]), E.push([0, 1, u[4 * (m * o + p)] / 255 * e]), E.push([-1, 1, u[4 * (m * o + g)] / 255 * e]);
                    for (var T = [], x = E.length, _ = 0; x > _; _++) {
                        var b = E[_],
                            R = E[(_ + 1) % x];
                        b = n(b, y), R = n(R, y), T.push(i(r(b, R)))
                    }
                    for (var w = [0, 0, 0], _ = 0; _ < T.length; _++) w[0] += T[_][0], w[1] += T[_][1], w[2] += T[_][2];
                    w[0] /= T.length, w[1] /= T.length, w[2] /= T.length;
                    var H = 4 * (f * o + p);
                    c[H] = (w[0] + 1) / 2 * 255 | 0, c[H + 1] = (w[1] + 1) / 2 * 255 | 0, c[H + 2] = 255 * w[2] | 0, c[H + 3] = 255
                }
            return h.putImageData(l, 0, 0), s
        },
        generateDataTexture: function(t, e, r) {
            for (var n = t * e, i = new Uint8Array(3 * n), o = Math.floor(255 * r.r), a = Math.floor(255 * r.g), s = Math.floor(255 * r.b), h = 0; n > h; h++) i[3 * h] = o, i[3 * h + 1] = a, i[3 * h + 2] = s;
            var u = new THREE.DataTexture(i, t, e, THREE.RGBFormat);
            return u.needsUpdate = !0, u
        }
    }, THREE.SceneUtils = {
        createMultiMaterialObject: function(t, e) {
            for (var r = new THREE.Object3D, n = 0, i = e.length; i > n; n++) r.add(new THREE.Mesh(t, e[n]));
            return r
        },
        detach: function(t, e, r) {
            t.applyMatrix(e.matrixWorld), e.remove(t), r.add(t)
        },
        attach: function(t, e, r) {
            var n = new THREE.Matrix4;
            n.getInverse(r.matrixWorld), t.applyMatrix(n), e.remove(t), r.add(t)
        }
    }, THREE.FontUtils = {
        faces: {},
        face: "helvetiker",
        weight: "normal",
        style: "normal",
        size: 150,
        divisions: 10,
        getFace: function() {
            try {
                return this.faces[this.face][this.weight][this.style]
            } catch (t) {
                throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
            }
        },
        loadFace: function(t) {
            var e = t.familyName.toLowerCase(),
                r = this;
            r.faces[e] = r.faces[e] || {}, r.faces[e][t.cssFontWeight] = r.faces[e][t.cssFontWeight] || {}, r.faces[e][t.cssFontWeight][t.cssFontStyle] = t;
            r.faces[e][t.cssFontWeight][t.cssFontStyle] = t;
            return t
        },
        drawText: function(t) {
            var e, r = this.getFace(),
                n = this.size / r.resolution,
                i = 0,
                o = String(t).split(""),
                a = o.length,
                s = [];
            for (e = 0; a > e; e++) {
                var h = new THREE.Path,
                    u = this.extractGlyphPoints(o[e], r, n, i, h);
                i += u.offset, s.push(u.path)
            }
            var l = i / 2;
            return {
                paths: s,
                offset: l
            }
        },
        extractGlyphPoints: function(t, e, r, n, i) {
            var o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R = [],
                w = e.glyphs[t] || e.glyphs["?"];
            if (w) {
                if (w.o)
                    for (h = w._cachedOutline || (w._cachedOutline = w.o.split(" ")), l = h.length, c = r, p = r, o = 0; l > o;) switch (u = h[o++]) {
                        case "m":
                            f = h[o++] * c + n, d = h[o++] * p, i.moveTo(f, d);
                            break;
                        case "l":
                            f = h[o++] * c + n, d = h[o++] * p, i.lineTo(f, d);
                            break;
                        case "q":
                            if (m = h[o++] * c + n, g = h[o++] * p, y = h[o++] * c + n, T = h[o++] * p, i.quadraticCurveTo(y, T, m, g), b = R[R.length - 1])
                                for (v = b.x, E = b.y, a = 1, s = this.divisions; s >= a; a++) {
                                    var H = a / s;
                                    THREE.Shape.Utils.b2(H, v, y, m), THREE.Shape.Utils.b2(H, E, T, g)
                                }
                            break;
                        case "b":
                            if (m = h[o++] * c + n, g = h[o++] * p, y = h[o++] * c + n, T = h[o++] * p, x = h[o++] * c + n, _ = h[o++] * p, i.bezierCurveTo(y, T, x, _, m, g), b = R[R.length - 1])
                                for (v = b.x, E = b.y, a = 1, s = this.divisions; s >= a; a++) {
                                    var H = a / s;
                                    THREE.Shape.Utils.b3(H, v, y, x, m), THREE.Shape.Utils.b3(H, E, T, _, g)
                                }
                    }
                return {
                    offset: w.ha * r,
                    path: i
                }
            }
        }
    }, THREE.FontUtils.generateShapes = function(t, e) {
        e = e || {};
        var r = void 0 !== e.size ? e.size : 100,
            n = void 0 !== e.curveSegments ? e.curveSegments : 4,
            i = void 0 !== e.font ? e.font : "helvetiker",
            o = void 0 !== e.weight ? e.weight : "normal",
            a = void 0 !== e.style ? e.style : "normal";
        THREE.FontUtils.size = r, THREE.FontUtils.divisions = n, THREE.FontUtils.face = i, THREE.FontUtils.weight = o, THREE.FontUtils.style = a;
        for (var s = THREE.FontUtils.drawText(t), h = s.paths, u = [], l = 0, c = h.length; c > l; l++) Array.prototype.push.apply(u, h[l].toShapes());
        return u
    },
    function(t) {
        var e = 1e-10,
            r = function(t, e) {
                var r = t.length;
                if (3 > r) return null;
                var o, a, s, h = [],
                    u = [],
                    l = [];
                if (n(t) > 0)
                    for (a = 0; r > a; a++) u[a] = a;
                else
                    for (a = 0; r > a; a++) u[a] = r - 1 - a;
                var c = r,
                    p = 2 * c;
                for (a = c - 1; c > 2;) {
                    if (p-- <= 0) return console.log("Warning, unable to triangulate polygon!"), e ? l : h;
                    if (o = a, o >= c && (o = 0), a = o + 1, a >= c && (a = 0), s = a + 1, s >= c && (s = 0), i(t, o, a, s, c, u)) {
                        var f, d, m, g, v;
                        for (f = u[o], d = u[a], m = u[s], h.push([t[f], t[d], t[m]]), l.push([u[o], u[a], u[s]]), g = a, v = a + 1; c > v; g++, v++) u[g] = u[v];
                        c--, p = 2 * c
                    }
                }
                return e ? l : h
            },
            n = function(t) {
                for (var e = t.length, r = 0, n = e - 1, i = 0; e > i; n = i++) r += t[n].x * t[i].y - t[i].x * t[n].y;
                return .5 * r
            },
            i = function(t, r, n, i, o, a) {
                var s, h, u, l, c, p, f, d, m;
                if (h = t[a[r]].x, u = t[a[r]].y, l = t[a[n]].x, c = t[a[n]].y, p = t[a[i]].x, f = t[a[i]].y, e > (l - h) * (f - u) - (c - u) * (p - h)) return !1;
                var g, v, E, y, T, x, _, b, R, w, H, M, S, A, C;
                for (g = p - l, v = f - c, E = h - p, y = u - f, T = l - h, x = c - u, s = 0; o > s; s++)
                    if (d = t[a[s]].x, m = t[a[s]].y, !(d === h && m === u || d === l && m === c || d === p && m === f) && (_ = d - h, b = m - u, R = d - l, w = m - c, H = d - p, M = m - f, C = g * w - v * R, S = T * b - x * _, A = E * M - y * H, C >= -e && A >= -e && S >= -e)) return !1;
                return !0
            };
        return t.Triangulate = r, t.Triangulate.area = n, t
    }(THREE.FontUtils), self._typeface_js = {
        faces: THREE.FontUtils.faces,
        loadFace: THREE.FontUtils.loadFace
    }, THREE.typeface_js = self._typeface_js, THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function() {
        return console.log("Warning, getPoint() not implemented!"), null
    }, THREE.Curve.prototype.getPointAt = function(t) {
        var e = this.getUtoTmapping(t);
        return this.getPoint(e)
    }, THREE.Curve.prototype.getPoints = function(t) {
        t || (t = 5);
        var e, r = [];
        for (e = 0; t >= e; e++) r.push(this.getPoint(e / t));
        return r
    }, THREE.Curve.prototype.getSpacedPoints = function(t) {
        t || (t = 5);
        var e, r = [];
        for (e = 0; t >= e; e++) r.push(this.getPointAt(e / t));
        return r
    }, THREE.Curve.prototype.getLength = function() {
        var t = this.getLengths();
        return t[t.length - 1]
    }, THREE.Curve.prototype.getLengths = function(t) {
        if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var e, r, n = [],
            i = this.getPoint(0),
            o = 0;
        for (n.push(0), r = 1; t >= r; r++) e = this.getPoint(r / t), o += e.distanceTo(i), n.push(o), i = e;
        return this.cacheArcLengths = n, n
    }, THREE.Curve.prototype.updateArcLengths = function() {
        this.needsUpdate = !0, this.getLengths()
    }, THREE.Curve.prototype.getUtoTmapping = function(t, e) {
        var r, n = this.getLengths(),
            i = 0,
            o = n.length;
        r = e ? e : t * n[o - 1];
        for (var a, s = 0, h = o - 1; h >= s;)
            if (i = Math.floor(s + (h - s) / 2), a = n[i] - r, 0 > a) s = i + 1;
            else {
                if (!(a > 0)) {
                    h = i;
                    break
                }
                h = i - 1
            }
        if (i = h, n[i] == r) {
            var u = i / (o - 1);
            return u
        }
        var l = n[i],
            c = n[i + 1],
            p = c - l,
            f = (r - l) / p,
            u = (i + f) / (o - 1);
        return u
    }, THREE.Curve.prototype.getTangent = function(t) {
        var e = 1e-4,
            r = t - e,
            n = t + e;
        0 > r && (r = 0), n > 1 && (n = 1);
        var i = this.getPoint(r),
            o = this.getPoint(n),
            a = o.clone().sub(i);
        return a.normalize()
    }, THREE.Curve.prototype.getTangentAt = function(t) {
        var e = this.getUtoTmapping(t);
        return this.getTangent(e)
    }, THREE.Curve.Utils = {
        tangentQuadraticBezier: function(t, e, r, n) {
            return 2 * (1 - t) * (r - e) + 2 * t * (n - r)
        },
        tangentCubicBezier: function(t, e, r, n, i) {
            return -3 * e * (1 - t) * (1 - t) + 3 * r * (1 - t) * (1 - t) - 6 * t * r * (1 - t) + 6 * t * n * (1 - t) - 3 * t * t * n + 3 * t * t * i
        },
        tangentSpline: function(t) {
            var e = 6 * t * t - 6 * t,
                r = 3 * t * t - 4 * t + 1,
                n = -6 * t * t + 6 * t,
                i = 3 * t * t - 2 * t;
            return e + r + n + i
        },
        interpolate: function(t, e, r, n, i) {
            var o = .5 * (r - t),
                a = .5 * (n - e),
                s = i * i,
                h = i * s;
            return (2 * e - 2 * r + o + a) * h + (-3 * e + 3 * r - 2 * o - a) * s + o * i + e
        }
    }, THREE.Curve.create = function(t, e) {
        return t.prototype = Object.create(THREE.Curve.prototype), t.prototype.getPoint = e, t
    }, THREE.CurvePath = function() {
        this.curves = [], this.bends = [], this.autoClose = !1
    }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.add = function(t) {
        this.curves.push(t)
    }, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
        var t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new THREE.LineCurve(e, t))
    }, THREE.CurvePath.prototype.getPoint = function(t) {
        for (var e, r, n = t * this.getLength(), i = this.getCurveLengths(), o = 0; o < i.length;) {
            if (i[o] >= n) {
                e = i[o] - n, r = this.curves[o];
                var a = 1 - e / r.getLength();
                return r.getPointAt(a)
            }
            o++
        }
        return null
    }, THREE.CurvePath.prototype.getLength = function() {
        var t = this.getCurveLengths();
        return t[t.length - 1]
    }, THREE.CurvePath.prototype.getCurveLengths = function() {
        if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
        var t, e = [],
            r = 0,
            n = this.curves.length;
        for (t = 0; n > t; t++) r += this.curves[t].getLength(), e.push(r);
        return this.cacheLengths = e, e
    }, THREE.CurvePath.prototype.getBoundingBox = function() {
        var t, e, r, n, i, o, a = this.getPoints();
        t = e = Number.NEGATIVE_INFINITY, n = i = Number.POSITIVE_INFINITY;
        var s, h, u, l, c = a[0] instanceof THREE.Vector3;
        for (l = c ? new THREE.Vector3 : new THREE.Vector2, h = 0, u = a.length; u > h; h++) s = a[h], s.x > t ? t = s.x : s.x < n && (n = s.x), s.y > e ? e = s.y : s.y < i && (i = s.y), c && (s.z > r ? r = s.z : s.z < o && (o = s.z)), l.add(s);
        var p = {
            minX: n,
            minY: i,
            maxX: t,
            maxY: e
        };
        return c && (p.maxZ = r, p.minZ = o), p
    }, THREE.CurvePath.prototype.createPointsGeometry = function(t) {
        var e = this.getPoints(t, !0);
        return this.createGeometry(e)
    }, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(t) {
        var e = this.getSpacedPoints(t, !0);
        return this.createGeometry(e)
    }, THREE.CurvePath.prototype.createGeometry = function(t) {
        for (var e = new THREE.Geometry, r = 0; r < t.length; r++) e.vertices.push(new THREE.Vector3(t[r].x, t[r].y, t[r].z || 0));
        return e
    }, THREE.CurvePath.prototype.addWrapPath = function(t) {
        this.bends.push(t)
    }, THREE.CurvePath.prototype.getTransformedPoints = function(t, e) {
        var r, n, i = this.getPoints(t);
        for (e || (e = this.bends), r = 0, n = e.length; n > r; r++) i = this.getWrapPoints(i, e[r]);
        return i
    }, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(t, e) {
        var r, n, i = this.getSpacedPoints(t);
        for (e || (e = this.bends), r = 0, n = e.length; n > r; r++) i = this.getWrapPoints(i, e[r]);
        return i
    }, THREE.CurvePath.prototype.getWrapPoints = function(t, e) {
        var r, n, i, o, a, s, h = this.getBoundingBox();
        for (r = 0, n = t.length; n > r; r++) {
            i = t[r], o = i.x, a = i.y, s = o / h.maxX, s = e.getUtoTmapping(s, o);
            var u = e.getPoint(s),
                l = e.getTangent(s);
            l.set(-l.y, l.x).multiplyScalar(a), i.x = u.x + l.x, i.y = u.y + l.y
        }
        return t
    }, THREE.Gyroscope = function() {
        THREE.Object3D.call(this)
    }, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.updateMatrixWorld = function(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        for (var e = 0, r = this.children.length; r > e; e++) this.children[e].updateMatrixWorld(t)
    }, THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3, THREE.Gyroscope.prototype.translationObject = new THREE.Vector3, THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion, THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion, THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3, THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3, THREE.Path = function(t) {
        THREE.CurvePath.call(this), this.actions = [], t && this.fromPoints(t)
    }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.PathActions = {
        MOVE_TO: "moveTo",
        LINE_TO: "lineTo",
        QUADRATIC_CURVE_TO: "quadraticCurveTo",
        BEZIER_CURVE_TO: "bezierCurveTo",
        CSPLINE_THRU: "splineThru",
        ARC: "arc",
        ELLIPSE: "ellipse"
    }, THREE.Path.prototype.fromPoints = function(t) {
        this.moveTo(t[0].x, t[0].y);
        for (var e = 1, r = t.length; r > e; e++) this.lineTo(t[e].x, t[e].y)
    }, THREE.Path.prototype.moveTo = function() {
        var t = Array.prototype.slice.call(arguments);
        this.actions.push({
            action: THREE.PathActions.MOVE_TO,
            args: t
        })
    }, THREE.Path.prototype.lineTo = function(t, e) {
        var r = Array.prototype.slice.call(arguments),
            n = this.actions[this.actions.length - 1].args,
            i = n[n.length - 2],
            o = n[n.length - 1],
            a = new THREE.LineCurve(new THREE.Vector2(i, o), new THREE.Vector2(t, e));
        this.curves.push(a), this.actions.push({
            action: THREE.PathActions.LINE_TO,
            args: r
        })
    }, THREE.Path.prototype.quadraticCurveTo = function(t, e, r, n) {
        var i = Array.prototype.slice.call(arguments),
            o = this.actions[this.actions.length - 1].args,
            a = o[o.length - 2],
            s = o[o.length - 1],
            h = new THREE.QuadraticBezierCurve(new THREE.Vector2(a, s), new THREE.Vector2(t, e), new THREE.Vector2(r, n));
        this.curves.push(h), this.actions.push({
            action: THREE.PathActions.QUADRATIC_CURVE_TO,
            args: i
        })
    }, THREE.Path.prototype.bezierCurveTo = function(t, e, r, n, i, o) {
        var a = Array.prototype.slice.call(arguments),
            s = this.actions[this.actions.length - 1].args,
            h = s[s.length - 2],
            u = s[s.length - 1],
            l = new THREE.CubicBezierCurve(new THREE.Vector2(h, u), new THREE.Vector2(t, e), new THREE.Vector2(r, n), new THREE.Vector2(i, o));
        this.curves.push(l), this.actions.push({
            action: THREE.PathActions.BEZIER_CURVE_TO,
            args: a
        })
    }, THREE.Path.prototype.splineThru = function(t) {
        var e = Array.prototype.slice.call(arguments),
            r = this.actions[this.actions.length - 1].args,
            n = r[r.length - 2],
            i = r[r.length - 1],
            o = [new THREE.Vector2(n, i)];
        Array.prototype.push.apply(o, t);
        var a = new THREE.SplineCurve(o);
        this.curves.push(a), this.actions.push({
            action: THREE.PathActions.CSPLINE_THRU,
            args: e
        })
    }, THREE.Path.prototype.arc = function(t, e, r, n, i, o) {
        var a = this.actions[this.actions.length - 1].args,
            s = a[a.length - 2],
            h = a[a.length - 1];
        this.absarc(t + s, e + h, r, n, i, o)
    }, THREE.Path.prototype.absarc = function(t, e, r, n, i, o) {
        this.absellipse(t, e, r, r, n, i, o)
    }, THREE.Path.prototype.ellipse = function(t, e, r, n, i, o, a) {
        var s = this.actions[this.actions.length - 1].args,
            h = s[s.length - 2],
            u = s[s.length - 1];
        this.absellipse(t + h, e + u, r, n, i, o, a)
    }, THREE.Path.prototype.absellipse = function(t, e, r, n, i, o, a) {
        var s = Array.prototype.slice.call(arguments),
            h = new THREE.EllipseCurve(t, e, r, n, i, o, a);
        this.curves.push(h);
        var u = h.getPoint(1);
        s.push(u.x), s.push(u.y), this.actions.push({
            action: THREE.PathActions.ELLIPSE,
            args: s
        })
    }, THREE.Path.prototype.getSpacedPoints = function(t) {
        t || (t = 40);
        for (var e = [], r = 0; t > r; r++) e.push(this.getPoint(r / t));
        return e
    }, THREE.Path.prototype.getPoints = function(t, e) {
        if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(t, e);
        t = t || 12;
        var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T = [];
        for (r = 0, n = this.actions.length; n > r; r++) switch (i = this.actions[r], o = i.action, a = i.args, o) {
            case THREE.PathActions.MOVE_TO:
                T.push(new THREE.Vector2(a[0], a[1]));
                break;
            case THREE.PathActions.LINE_TO:
                T.push(new THREE.Vector2(a[0], a[1]));
                break;
            case THREE.PathActions.QUADRATIC_CURVE_TO:
                for (s = a[2], h = a[3], c = a[0], p = a[1], T.length > 0 ? (m = T[T.length - 1], f = m.x, d = m.y) : (m = this.actions[r - 1].args, f = m[m.length - 2], d = m[m.length - 1]), g = 1; t >= g; g++) v = g / t, E = THREE.Shape.Utils.b2(v, f, c, s), y = THREE.Shape.Utils.b2(v, d, p, h), T.push(new THREE.Vector2(E, y));
                break;
            case THREE.PathActions.BEZIER_CURVE_TO:
                for (s = a[4], h = a[5], c = a[0], p = a[1], u = a[2], l = a[3], T.length > 0 ? (m = T[T.length - 1], f = m.x, d = m.y) : (m = this.actions[r - 1].args, f = m[m.length - 2], d = m[m.length - 1]), g = 1; t >= g; g++) v = g / t, E = THREE.Shape.Utils.b3(v, f, c, u, s), y = THREE.Shape.Utils.b3(v, d, p, l, h), T.push(new THREE.Vector2(E, y));
                break;
            case THREE.PathActions.CSPLINE_THRU:
                m = this.actions[r - 1].args;
                var x = new THREE.Vector2(m[m.length - 2], m[m.length - 1]),
                    _ = [x],
                    b = t * a[0].length;
                _ = _.concat(a[0]);
                var R = new THREE.SplineCurve(_);
                for (g = 1; b >= g; g++) T.push(R.getPointAt(g / b));
                break;
            case THREE.PathActions.ARC:
                var w, H = a[0],
                    M = a[1],
                    S = a[2],
                    A = a[3],
                    C = a[4],
                    k = !!a[5],
                    L = C - A,
                    z = 2 * t;
                for (g = 1; z >= g; g++) v = g / z, k || (v = 1 - v), w = A + v * L, E = H + S * Math.cos(w), y = M + S * Math.sin(w), T.push(new THREE.Vector2(E, y));
                break;
            case THREE.PathActions.ELLIPSE:
                var w, H = a[0],
                    M = a[1],
                    P = a[2],
                    D = a[3],
                    A = a[4],
                    C = a[5],
                    k = !!a[6],
                    L = C - A,
                    z = 2 * t;
                for (g = 1; z >= g; g++) v = g / z, k || (v = 1 - v), w = A + v * L, E = H + P * Math.cos(w), y = M + D * Math.sin(w), T.push(new THREE.Vector2(E, y))
        }
        var F = T[T.length - 1],
            U = 1e-10;
        return Math.abs(F.x - T[0].x) < U && Math.abs(F.y - T[0].y) < U && T.splice(T.length - 1, 1), e && T.push(T[0]), T
    }, THREE.Path.prototype.toShapes = function(t, e) {
        function r(t) {
            var e, r, n, i, o, a = [],
                s = new THREE.Path;
            for (e = 0, r = t.length; r > e; e++) n = t[e], o = n.args, i = n.action, i == THREE.PathActions.MOVE_TO && 0 != s.actions.length && (a.push(s), s = new THREE.Path), s[i].apply(s, o);
            return 0 != s.actions.length && a.push(s), a
        }

        function n(t) {
            for (var e = [], r = 0, n = t.length; n > r; r++) {
                var i = t[r],
                    o = new THREE.Shape;
                o.actions = i.actions, o.curves = i.curves, e.push(o)
            }
            return e
        }

        function i(t, e) {
            for (var r = 1e-10, n = e.length, i = !1, o = n - 1, a = 0; n > a; o = a++) {
                var s = e[o],
                    h = e[a],
                    u = h.x - s.x,
                    l = h.y - s.y;
                if (Math.abs(l) > r) {
                    if (0 > l && (s = e[a], u = -u, h = e[o], l = -l), t.y < s.y || t.y > h.y) continue;
                    if (t.y == s.y) {
                        if (t.x == s.x) return !0
                    } else {
                        var c = l * (t.x - s.x) - u * (t.y - s.y);
                        if (0 == c) return !0;
                        if (0 > c) continue;
                        i = !i
                    }
                } else {
                    if (t.y != s.y) continue;
                    if (h.x <= t.x && t.x <= s.x || s.x <= t.x && t.x <= h.x) return !0
                }
            }
            return i
        }
        var o = r(this.actions);
        if (0 == o.length) return [];
        if (e === !0) return n(o);
        var a, s, h, u = [];
        if (1 == o.length) return s = o[0], h = new THREE.Shape, h.actions = s.actions, h.curves = s.curves, u.push(h), u;
        var l = !THREE.Shape.Utils.isClockWise(o[0].getPoints());
        l = t ? !l : l;
        var c, p = [],
            f = [],
            d = [],
            m = 0;
        f[m] = void 0, d[m] = [];
        var g, v;
        for (g = 0, v = o.length; v > g; g++) s = o[g], c = s.getPoints(), a = THREE.Shape.Utils.isClockWise(c), a = t ? !a : a, a ? (!l && f[m] && m++, f[m] = {
            s: new THREE.Shape,
            p: c
        }, f[m].s.actions = s.actions, f[m].s.curves = s.curves, l && m++, d[m] = []) : d[m].push({
            h: s,
            p: c[0]
        });
        if (!f[0]) return n(o);
        if (f.length > 1) {
            for (var E = !1, y = [], T = 0, x = f.length; x > T; T++) p[T] = [];
            for (var T = 0, x = f.length; x > T; T++)
                for (var _ = (f[T], d[T]), b = 0; b < _.length; b++) {
                    for (var R = _[b], w = !0, H = 0; H < f.length; H++) i(R.p, f[H].p) && (T != H && y.push({
                        froms: T,
                        tos: H,
                        hole: b
                    }), w ? (w = !1, p[H].push(R)) : E = !0);
                    w && p[T].push(R)
                }
            y.length > 0 && (E || (d = p))
        }
        var M, S, A;
        for (g = 0, v = f.length; v > g; g++)
            for (h = f[g].s, u.push(h), M = d[g], S = 0, A = M.length; A > S; S++) h.holes.push(M[S].h);
        return u
    }, THREE.Shape = function() {
        THREE.Path.apply(this, arguments), this.holes = []
    }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.extrude = function(t) {
        var e = new THREE.ExtrudeGeometry(this, t);
        return e
    }, THREE.Shape.prototype.makeGeometry = function(t) {
        var e = new THREE.ShapeGeometry(this, t);
        return e
    }, THREE.Shape.prototype.getPointsHoles = function(t) {
        var e, r = this.holes.length,
            n = [];
        for (e = 0; r > e; e++) n[e] = this.holes[e].getTransformedPoints(t, this.bends);
        return n
    }, THREE.Shape.prototype.getSpacedPointsHoles = function(t) {
        var e, r = this.holes.length,
            n = [];
        for (e = 0; r > e; e++) n[e] = this.holes[e].getTransformedSpacedPoints(t, this.bends);
        return n
    }, THREE.Shape.prototype.extractAllPoints = function(t) {
        return {
            shape: this.getTransformedPoints(t),
            holes: this.getPointsHoles(t)
        }
    }, THREE.Shape.prototype.extractPoints = function(t) {
        return this.useSpacedPoints ? this.extractAllSpacedPoints(t) : this.extractAllPoints(t)
    }, THREE.Shape.prototype.extractAllSpacedPoints = function(t) {
        return {
            shape: this.getTransformedSpacedPoints(t),
            holes: this.getSpacedPointsHoles(t)
        }
    }, THREE.Shape.Utils = {
        triangulateShape: function(t, e) {
            function r(t, e, r) {
                return t.x != e.x ? t.x < e.x ? t.x <= r.x && r.x <= e.x : e.x <= r.x && r.x <= t.x : t.y < e.y ? t.y <= r.y && r.y <= e.y : e.y <= r.y && r.y <= t.y
            }

            function n(t, e, n, i, o) {
                var a = 1e-10,
                    s = e.x - t.x,
                    h = e.y - t.y,
                    u = i.x - n.x,
                    l = i.y - n.y,
                    c = t.x - n.x,
                    p = t.y - n.y,
                    f = h * u - s * l,
                    d = h * c - s * p;
                if (Math.abs(f) > a) {
                    var m;
                    if (f > 0) {
                        if (0 > d || d > f) return [];
                        if (m = l * c - u * p, 0 > m || m > f) return []
                    } else {
                        if (d > 0 || f > d) return [];
                        if (m = l * c - u * p, m > 0 || f > m) return []
                    }
                    if (0 == m) return !o || 0 != d && d != f ? [t] : [];
                    if (m == f) return !o || 0 != d && d != f ? [e] : [];
                    if (0 == d) return [n];
                    if (d == f) return [i];
                    var g = m / f;
                    return [{
                        x: t.x + g * s,
                        y: t.y + g * h
                    }]
                }
                if (0 != d || l * c != u * p) return [];
                var v = 0 == s && 0 == h,
                    E = 0 == u && 0 == l;
                if (v && E) return t.x != n.x || t.y != n.y ? [] : [t];
                if (v) return r(n, i, t) ? [t] : [];
                if (E) return r(t, e, n) ? [n] : [];
                var y, T, x, _, b, R, w, H;
                return 0 != s ? (t.x < e.x ? (y = t, x = t.x, T = e, _ = e.x) : (y = e, x = e.x, T = t, _ = t.x), n.x < i.x ? (b = n, w = n.x, R = i, H = i.x) : (b = i, w = i.x, R = n, H = n.x)) : (t.y < e.y ? (y = t, x = t.y, T = e, _ = e.y) : (y = e, x = e.y, T = t, _ = t.y), n.y < i.y ? (b = n, w = n.y, R = i, H = i.y) : (b = i, w = i.y, R = n, H = n.y)), w >= x ? w > _ ? [] : _ == w ? o ? [] : [b] : H >= _ ? [b, T] : [b, R] : x > H ? [] : x == H ? o ? [] : [y] : H >= _ ? [y, T] : [y, R]
            }

            function i(t, e, r, n) {
                var i = 1e-10,
                    o = e.x - t.x,
                    a = e.y - t.y,
                    s = r.x - t.x,
                    h = r.y - t.y,
                    u = n.x - t.x,
                    l = n.y - t.y,
                    c = o * h - a * s,
                    p = o * l - a * u;
                if (Math.abs(c) > i) {
                    var f = u * h - l * s;
                    return c > 0 ? p >= 0 && f >= 0 : p >= 0 || f >= 0
                }
                return p > 0
            }

            function o(t, e) {
                function r(t, e) {
                    var r = E.length - 1,
                        n = t - 1;
                    0 > n && (n = r);
                    var o = t + 1;
                    o > r && (o = 0);
                    var a = i(E[t], E[n], E[o], s[e]);
                    if (!a) return !1;
                    var h = s.length - 1,
                        u = e - 1;
                    0 > u && (u = h);
                    var l = e + 1;
                    return l > h && (l = 0), a = i(s[e], s[u], s[l], E[t]), a ? !0 : !1
                }

                function o(t, e) {
                    var r, i, o;
                    for (r = 0; r < E.length; r++)
                        if (i = r + 1, i %= E.length, o = n(t, e, E[r], E[i], !0), o.length > 0) return !0;
                    return !1
                }

                function a(t, r) {
                    var i, o, a, s, h;
                    for (i = 0; i < y.length; i++)
                        for (o = e[y[i]], a = 0; a < o.length; a++)
                            if (s = a + 1, s %= o.length, h = n(t, r, o[a], o[s], !0), h.length > 0) return !0;
                    return !1
                }
                for (var s, h, u, l, c, p, f, d, m, g, v, E = t.concat(), y = [], T = [], x = 0, _ = e.length; _ > x; x++) y.push(x);
                for (var b = 0, R = 2 * y.length; y.length > 0;) {
                    if (R--, 0 > R) {
                        console.log("Infinite Loop! Holes left:" + y.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (u = b; u < E.length; u++) {
                        l = E[u], h = -1;
                        for (var x = 0; x < y.length; x++)
                            if (p = y[x], f = l.x + ":" + l.y + ":" + p, void 0 === T[f]) {
                                s = e[p];
                                for (var w = 0; w < s.length; w++)
                                    if (c = s[w], r(u, w) && !o(l, c) && !a(l, c)) {
                                        h = w, y.splice(x, 1), d = E.slice(0, u + 1), m = E.slice(u), g = s.slice(h), v = s.slice(0, h + 1), E = d.concat(g).concat(v).concat(m), b = u;
                                        break
                                    }
                                if (h >= 0) break;
                                T[f] = !0
                            }
                        if (h >= 0) break
                    }
                }
                return E
            }
            for (var a, s, h, u, l, c, p = {}, f = t.concat(), d = 0, m = e.length; m > d; d++) Array.prototype.push.apply(f, e[d]);
            for (a = 0, s = f.length; s > a; a++) l = f[a].x + ":" + f[a].y, void 0 !== p[l] && console.log("Duplicate point", l), p[l] = a;
            var g = o(t, e),
                v = THREE.FontUtils.Triangulate(g, !1);
            for (a = 0, s = v.length; s > a; a++)
                for (u = v[a], h = 0; 3 > h; h++) l = u[h].x + ":" + u[h].y, c = p[l], void 0 !== c && (u[h] = c);
            return v.concat()
        },
        isClockWise: function(t) {
            return THREE.FontUtils.Triangulate.area(t) < 0
        },
        b2p0: function(t, e) {
            var r = 1 - t;
            return r * r * e
        },
        b2p1: function(t, e) {
            return 2 * (1 - t) * t * e
        },
        b2p2: function(t, e) {
            return t * t * e
        },
        b2: function(t, e, r, n) {
            return this.b2p0(t, e) + this.b2p1(t, r) + this.b2p2(t, n)
        },
        b3p0: function(t, e) {
            var r = 1 - t;
            return r * r * r * e
        },
        b3p1: function(t, e) {
            var r = 1 - t;
            return 3 * r * r * t * e
        },
        b3p2: function(t, e) {
            var r = 1 - t;
            return 3 * r * t * t * e
        },
        b3p3: function(t, e) {
            return t * t * t * e
        },
        b3: function(t, e, r, n, i) {
            return this.b3p0(t, e) + this.b3p1(t, r) + this.b3p2(t, n) + this.b3p3(t, i)
        }
    }, THREE.LineCurve = function(t, e) {
        this.v1 = t, this.v2 = e
    }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.getPoint = function(t) {
        var e = this.v2.clone().sub(this.v1);
        return e.multiplyScalar(t).add(this.v1), e
    }, THREE.LineCurve.prototype.getPointAt = function(t) {
        return this.getPoint(t)
    }, THREE.LineCurve.prototype.getTangent = function() {
        var t = this.v2.clone().sub(this.v1);
        return t.normalize()
    }, THREE.QuadraticBezierCurve = function(t, e, r) {
        this.v0 = t, this.v1 = e, this.v2 = r
    }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
        var e, r;
        return e = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x), r = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y), new THREE.Vector2(e, r)
    }, THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
        var e, r;
        e = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), r = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
        var n = new THREE.Vector2(e, r);
        return n.normalize(), n
    }, THREE.CubicBezierCurve = function(t, e, r, n) {
        this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = n
    }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.getPoint = function(t) {
        var e, r;
        return e = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), r = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(e, r)
    }, THREE.CubicBezierCurve.prototype.getTangent = function(t) {
        var e, r;
        e = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), r = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
        var n = new THREE.Vector2(e, r);
        return n.normalize(), n
    }, THREE.SplineCurve = function(t) {
        this.points = void 0 == t ? [] : t
    }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.getPoint = function(t) {
        var e, r, n, i = new THREE.Vector2,
            o = [],
            a = this.points;
        return e = (a.length - 1) * t, r = Math.floor(e), n = e - r, o[0] = 0 == r ? r : r - 1, o[1] = r, o[2] = r > a.length - 2 ? a.length - 1 : r + 1, o[3] = r > a.length - 3 ? a.length - 1 : r + 2, i.x = THREE.Curve.Utils.interpolate(a[o[0]].x, a[o[1]].x, a[o[2]].x, a[o[3]].x, n), i.y = THREE.Curve.Utils.interpolate(a[o[0]].y, a[o[1]].y, a[o[2]].y, a[o[3]].y, n), i
    }, THREE.EllipseCurve = function(t, e, r, n, i, o, a) {
        this.aX = t, this.aY = e, this.xRadius = r, this.yRadius = n, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = a
    }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.getPoint = function(t) {
        var e, r = this.aEndAngle - this.aStartAngle;
        0 > r && (r += 2 * Math.PI), r > 2 * Math.PI && (r -= 2 * Math.PI), e = this.aClockwise === !0 ? this.aEndAngle + (1 - t) * (2 * Math.PI - r) : this.aStartAngle + t * r;
        var n = this.aX + this.xRadius * Math.cos(e),
            i = this.aY + this.yRadius * Math.sin(e);
        return new THREE.Vector2(n, i)
    }, THREE.ArcCurve = function(t, e, r, n, i, o) {
        THREE.EllipseCurve.call(this, t, e, r, r, n, i, o)
    }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.LineCurve3 = THREE.Curve.create(function(t, e) {
        this.v1 = t, this.v2 = e
    }, function(t) {
        var e = new THREE.Vector3;
        return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e
    }), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(t, e, r) {
        this.v0 = t, this.v1 = e, this.v2 = r
    }, function(t) {
        var e, r, n;
        return e = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x), r = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y), n = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z), new THREE.Vector3(e, r, n)
    }), THREE.CubicBezierCurve3 = THREE.Curve.create(function(t, e, r, n) {
        this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = n
    }, function(t) {
        var e, r, n;
        return e = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), r = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), n = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z), new THREE.Vector3(e, r, n)
    }), THREE.SplineCurve3 = THREE.Curve.create(function(t) {
        this.points = void 0 == t ? [] : t
    }, function(t) {
        var e, r, n, i = new THREE.Vector3,
            o = [],
            a = this.points;
        e = (a.length - 1) * t, r = Math.floor(e), n = e - r, o[0] = 0 == r ? r : r - 1, o[1] = r, o[2] = r > a.length - 2 ? a.length - 1 : r + 1, o[3] = r > a.length - 3 ? a.length - 1 : r + 2;
        var s = a[o[0]],
            h = a[o[1]],
            u = a[o[2]],
            l = a[o[3]];
        return i.x = THREE.Curve.Utils.interpolate(s.x, h.x, u.x, l.x, n), i.y = THREE.Curve.Utils.interpolate(s.y, h.y, u.y, l.y, n), i.z = THREE.Curve.Utils.interpolate(s.z, h.z, u.z, l.z, n), i
    }), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(t) {
        this.points = void 0 == t ? [] : t
    }, function(t) {
        var e, r, n, i = new THREE.Vector3,
            o = [],
            a = this.points;
        return e = (a.length - 0) * t, r = Math.floor(e), n = e - r, r += r > 0 ? 0 : (Math.floor(Math.abs(r) / a.length) + 1) * a.length, o[0] = (r - 1) % a.length, o[1] = r % a.length, o[2] = (r + 1) % a.length, o[3] = (r + 2) % a.length, i.x = THREE.Curve.Utils.interpolate(a[o[0]].x, a[o[1]].x, a[o[2]].x, a[o[3]].x, n), i.y = THREE.Curve.Utils.interpolate(a[o[0]].y, a[o[1]].y, a[o[2]].y, a[o[3]].y, n), i.z = THREE.Curve.Utils.interpolate(a[o[0]].z, a[o[1]].z, a[o[2]].z, a[o[3]].z, n), i
    }), THREE.AnimationHandler = {
        LINEAR: 0,
        CATMULLROM: 1,
        CATMULLROM_FORWARD: 2,
        add: function() {
            console.warn("THREE.AnimationHandler.add() has been deprecated.")
        },
        get: function() {
            console.warn("THREE.AnimationHandler.get() has been deprecated.")
        },
        remove: function() {
            console.warn("THREE.AnimationHandler.remove() has been deprecated.")
        },
        animations: [],
        init: function(t) {
            if (t.initialized !== !0) {
                for (var e = 0; e < t.hierarchy.length; e++) {
                    for (var r = 0; r < t.hierarchy[e].keys.length; r++)
                        if (t.hierarchy[e].keys[r].time < 0 && (t.hierarchy[e].keys[r].time = 0), void 0 !== t.hierarchy[e].keys[r].rot && !(t.hierarchy[e].keys[r].rot instanceof THREE.Quaternion)) {
                            var n = t.hierarchy[e].keys[r].rot;
                            t.hierarchy[e].keys[r].rot = (new THREE.Quaternion).fromArray(n)
                        }
                    if (t.hierarchy[e].keys.length && void 0 !== t.hierarchy[e].keys[0].morphTargets) {
                        for (var i = {}, r = 0; r < t.hierarchy[e].keys.length; r++)
                            for (var o = 0; o < t.hierarchy[e].keys[r].morphTargets.length; o++) {
                                var a = t.hierarchy[e].keys[r].morphTargets[o];
                                i[a] = -1
                            }
                        t.hierarchy[e].usedMorphTargets = i;
                        for (var r = 0; r < t.hierarchy[e].keys.length; r++) {
                            var s = {};
                            for (var a in i) {
                                for (var o = 0; o < t.hierarchy[e].keys[r].morphTargets.length; o++)
                                    if (t.hierarchy[e].keys[r].morphTargets[o] === a) {
                                        s[a] = t.hierarchy[e].keys[r].morphTargetsInfluences[o];
                                        break
                                    }
                                o === t.hierarchy[e].keys[r].morphTargets.length && (s[a] = 0)
                            }
                            t.hierarchy[e].keys[r].morphTargetsInfluences = s
                        }
                    }
                    for (var r = 1; r < t.hierarchy[e].keys.length; r++) t.hierarchy[e].keys[r].time === t.hierarchy[e].keys[r - 1].time && (t.hierarchy[e].keys.splice(r, 1), r--);
                    for (var r = 0; r < t.hierarchy[e].keys.length; r++) t.hierarchy[e].keys[r].index = r
                }
                return t.initialized = !0, t
            }
        },
        parse: function(t) {
            var e = function(t, r) {
                    r.push(t);
                    for (var n = 0; n < t.children.length; n++) e(t.children[n], r)
                },
                r = [];
            if (t instanceof THREE.SkinnedMesh)
                for (var n = 0; n < t.skeleton.bones.length; n++) r.push(t.skeleton.bones[n]);
            else e(t, r);
            return r
        },
        play: function(t) {
            -1 === this.animations.indexOf(t) && this.animations.push(t)
        },
        stop: function(t) {
            var e = this.animations.indexOf(t); - 1 !== e && this.animations.splice(e, 1)
        },
        update: function(t) {
            for (var e = 0; e < this.animations.length; e++) this.animations[e].update(t)
        }
    }, THREE.Animation = function(t, e) {
        this.root = t, this.data = THREE.AnimationHandler.init(e), this.hierarchy = THREE.AnimationHandler.parse(t), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = THREE.AnimationHandler.LINEAR
    }, THREE.Animation.prototype.keyTypes = ["pos", "rot", "scl"], THREE.Animation.prototype.play = function(t, e) {
        this.currentTime = void 0 !== t ? t : 0, this.weight = void 0 !== e ? e : 1, this.isPlaying = !0, this.reset(), THREE.AnimationHandler.play(this)
    }, THREE.Animation.prototype.stop = function() {
        this.isPlaying = !1, THREE.AnimationHandler.stop(this)
    }, THREE.Animation.prototype.reset = function() {
        for (var t = 0, e = this.hierarchy.length; e > t; t++) {
            var r = this.hierarchy[t];
            r.matrixAutoUpdate = !0, void 0 === r.animationCache && (r.animationCache = {}), void 0 === r.animationCache[this.data.name] && (r.animationCache[this.data.name] = {}, r.animationCache[this.data.name].prevKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, r.animationCache[this.data.name].nextKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, r.animationCache[this.data.name].originalMatrix = r.matrix);
            for (var n = r.animationCache[this.data.name], i = 0; 3 > i; i++) {
                for (var o = this.keyTypes[i], a = this.data.hierarchy[t].keys[0], s = this.getNextKeyWith(o, t, 1); s.time < this.currentTime && s.index > a.index;) a = s, s = this.getNextKeyWith(o, t, s.index + 1);
                n.prevKey[o] = a, n.nextKey[o] = s
            }
        }
    }, THREE.Animation.prototype.update = function() {
        var t = [],
            e = new THREE.Vector3,
            r = new THREE.Vector3,
            n = new THREE.Quaternion,
            i = function(t, e) {
                var r, n, i, a, s, h, u, l, c, p = [],
                    f = [];
                return r = (t.length - 1) * e, n = Math.floor(r), i = r - n, p[0] = 0 === n ? n : n - 1, p[1] = n, p[2] = n > t.length - 2 ? n : n + 1, p[3] = n > t.length - 3 ? n : n + 2, h = t[p[0]], u = t[p[1]], l = t[p[2]], c = t[p[3]], a = i * i, s = i * a, f[0] = o(h[0], u[0], l[0], c[0], i, a, s), f[1] = o(h[1], u[1], l[1], c[1], i, a, s), f[2] = o(h[2], u[2], l[2], c[2], i, a, s), f
            },
            o = function(t, e, r, n, i, o, a) {
                var s = .5 * (r - t),
                    h = .5 * (n - e);
                return (2 * (e - r) + s + h) * a + (-3 * (e - r) - 2 * s - h) * o + s * i + e
            };
        return function(o) {
            if (this.isPlaying !== !1 && (this.currentTime += o * this.timeScale, 0 !== this.weight)) {
                var a = this.data.length;
                if (this.loop === !0 && this.currentTime > a) this.currentTime %= a, this.reset();
                else if (this.loop === !1 && this.currentTime > a) return void this.stop();
                for (var s = 0, h = this.hierarchy.length; h > s; s++)
                    for (var u = this.hierarchy[s], l = u.animationCache[this.data.name], c = 0; 3 > c; c++) {
                        var p = this.keyTypes[c],
                            f = l.prevKey[p],
                            d = l.nextKey[p];
                        if (d.time <= this.currentTime) {
                            for (f = this.data.hierarchy[s].keys[0], d = this.getNextKeyWith(p, s, 1); d.time < this.currentTime && d.index > f.index;) f = d, d = this.getNextKeyWith(p, s, d.index + 1);
                            l.prevKey[p] = f, l.nextKey[p] = d
                        }
                        u.matrixAutoUpdate = !0, u.matrixWorldNeedsUpdate = !0;
                        var m = (this.currentTime - f.time) / (d.time - f.time),
                            g = f[p],
                            v = d[p];
                        if (0 > m && (m = 0), m > 1 && (m = 1), "pos" === p) {
                            if (this.interpolationType === THREE.AnimationHandler.LINEAR)
                                if (r.x = g[0] + (v[0] - g[0]) * m, r.y = g[1] + (v[1] - g[1]) * m, r.z = g[2] + (v[2] - g[2]) * m, u instanceof THREE.Bone) {
                                    var E = this.weight / (this.weight + u.accumulatedPosWeight);
                                    u.position.lerp(r, E), u.accumulatedPosWeight += this.weight
                                } else u.position.copy(r);
                            else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                                t[0] = this.getPrevKeyWith("pos", s, f.index - 1).pos, t[1] = g, t[2] = v, t[3] = this.getNextKeyWith("pos", s, d.index + 1).pos, m = .33 * m + .33;
                                var y = i(t, m),
                                    E = 1;
                                u instanceof THREE.Bone && (E = this.weight / (this.weight + u.accumulatedPosWeight), u.accumulatedPosWeight += this.weight);
                                var T = u.position;
                                if (T.x = T.x + (y[0] - T.x) * E, T.y = T.y + (y[1] - T.y) * E, T.z = T.z + (y[2] - T.z) * E, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                                    var x = i(t, 1.01 * m);
                                    e.set(x[0], x[1], x[2]), e.sub(T), e.y = 0, e.normalize();
                                    var _ = Math.atan2(e.x, e.z);
                                    u.rotation.set(0, _, 0)
                                }
                            }
                        } else if ("rot" === p)
                            if (THREE.Quaternion.slerp(g, v, n, m), u instanceof THREE.Bone)
                                if (0 === u.accumulatedRotWeight) u.quaternion.copy(n), u.accumulatedRotWeight = this.weight;
                                else {
                                    var E = this.weight / (this.weight + u.accumulatedRotWeight);
                                    THREE.Quaternion.slerp(u.quaternion, n, u.quaternion, E), u.accumulatedRotWeight += this.weight
                                } else u.quaternion.copy(n);
                        else if ("scl" === p)
                            if (r.x = g[0] + (v[0] - g[0]) * m, r.y = g[1] + (v[1] - g[1]) * m, r.z = g[2] + (v[2] - g[2]) * m, u instanceof THREE.Bone) {
                                var E = this.weight / (this.weight + u.accumulatedSclWeight);
                                u.scale.lerp(r, E), u.accumulatedSclWeight += this.weight
                            } else u.scale.copy(r)
                    }
                return !0
            }
        }
    }(), THREE.Animation.prototype.getNextKeyWith = function(t, e, r) {
        var n = this.data.hierarchy[e].keys;
        for (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? r = r < n.length - 1 ? r : n.length - 1 : r %= n.length; r < n.length; r++)
            if (void 0 !== n[r][t]) return n[r];
        return this.data.hierarchy[e].keys[0]
    }, THREE.Animation.prototype.getPrevKeyWith = function(t, e, r) {
        var n = this.data.hierarchy[e].keys;
        for (r = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? r > 0 ? r : 0 : r >= 0 ? r : r + n.length; r >= 0; r--)
            if (void 0 !== n[r][t]) return n[r];
        return this.data.hierarchy[e].keys[n.length - 1]
    }, THREE.KeyFrameAnimation = function(t) {
        this.root = t.node, this.data = THREE.AnimationHandler.init(t), this.hierarchy = THREE.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.isPaused = !0, this.loop = !0;
        for (var e = 0, r = this.hierarchy.length; r > e; e++) {
            var n = this.data.hierarchy[e].keys,
                i = this.data.hierarchy[e].sids,
                o = this.hierarchy[e];
            if (n.length && i) {
                for (var a = 0; a < i.length; a++) {
                    var s = i[a],
                        h = this.getNextKeyWith(s, e, 0);
                    h && h.apply(s)
                }
                o.matrixAutoUpdate = !1, this.data.hierarchy[e].node.updateMatrix(), o.matrixWorldNeedsUpdate = !0
            }
        }
    }, THREE.KeyFrameAnimation.prototype.play = function(t) {
        if (this.currentTime = void 0 !== t ? t : 0, this.isPlaying === !1) {
            this.isPlaying = !0;
            var e, r, n, i = this.hierarchy.length;
            for (e = 0; i > e; e++) {
                r = this.hierarchy[e], n = this.data.hierarchy[e], void 0 === n.animationCache && (n.animationCache = {}, n.animationCache.prevKey = null, n.animationCache.nextKey = null, n.animationCache.originalMatrix = r.matrix);
                var o = this.data.hierarchy[e].keys;
                o.length && (n.animationCache.prevKey = o[0], n.animationCache.nextKey = o[1], this.startTime = Math.min(o[0].time, this.startTime), this.endTime = Math.max(o[o.length - 1].time, this.endTime))
            }
            this.update(0)
        }
        this.isPaused = !1, THREE.AnimationHandler.play(this)
    }, THREE.KeyFrameAnimation.prototype.stop = function() {
        this.isPlaying = !1, this.isPaused = !1, THREE.AnimationHandler.stop(this);
        for (var t = 0; t < this.data.hierarchy.length; t++) {
            var e = this.hierarchy[t],
                r = this.data.hierarchy[t];
            if (void 0 !== r.animationCache) {
                var n = r.animationCache.originalMatrix;
                n.copy(e.matrix), e.matrix = n, delete r.animationCache
            }
        }
    }, THREE.KeyFrameAnimation.prototype.update = function(t) {
        if (this.isPlaying !== !1) {
            this.currentTime += t * this.timeScale;
            var e = this.data.length;
            this.loop === !0 && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e);
            for (var r = 0, n = this.hierarchy.length; n > r; r++) {
                var i = this.hierarchy[r],
                    o = this.data.hierarchy[r],
                    a = o.keys,
                    s = o.animationCache;
                if (a.length) {
                    var h = s.prevKey,
                        u = s.nextKey;
                    if (u.time <= this.currentTime) {
                        for (; u.time < this.currentTime && u.index > h.index;) h = u, u = a[h.index + 1];
                        s.prevKey = h, s.nextKey = u
                    }
                    u.time >= this.currentTime ? h.interpolate(u, this.currentTime) : h.interpolate(u, u.time), this.data.hierarchy[r].node.updateMatrix(), i.matrixWorldNeedsUpdate = !0
                }
            }
        }
    }, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(t, e, r) {
        var n = this.data.hierarchy[e].keys;
        for (r %= n.length; r < n.length; r++)
            if (n[r].hasTarget(t)) return n[r];
        return n[0]
    }, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(t, e, r) {
        var n = this.data.hierarchy[e].keys;
        for (r = r >= 0 ? r : r + n.length; r >= 0; r--)
            if (n[r].hasTarget(t)) return n[r];
        return n[n.length - 1]
    }, THREE.MorphAnimation = function(t) {
        this.mesh = t, this.frames = t.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.isPlaying = !1
    }, THREE.MorphAnimation.prototype = {
        play: function() {
            this.isPlaying = !0
        },
        pause: function() {
            this.isPlaying = !1
        },
        update: function() {
            var t = 0,
                e = 0;
            return function(r) {
                if (this.isPlaying !== !1) {
                    this.currentTime += r, this.loop === !0 && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration);
                    var n = this.duration / this.frames,
                        i = Math.floor(this.currentTime / n);
                    i != e && (this.mesh.morphTargetInfluences[t] = 0, this.mesh.morphTargetInfluences[e] = 1, this.mesh.morphTargetInfluences[i] = 0, t = e, e = i), this.mesh.morphTargetInfluences[i] = this.currentTime % n / n, this.mesh.morphTargetInfluences[t] = 1 - this.mesh.morphTargetInfluences[i]
                }
            }
        }()
    }, THREE.BoxGeometry = function(t, e, r, n, i, o) {
        function a(t, e, r, n, i, o, a, h) {
            var u, l, c, p = s.widthSegments,
                f = s.heightSegments,
                d = i / 2,
                m = o / 2,
                g = s.vertices.length;
            "x" === t && "y" === e || "y" === t && "x" === e ? u = "z" : "x" === t && "z" === e || "z" === t && "x" === e ? (u = "y", f = s.depthSegments) : ("z" === t && "y" === e || "y" === t && "z" === e) && (u = "x", p = s.depthSegments);
            var v = p + 1,
                E = f + 1,
                y = i / p,
                T = o / f,
                x = new THREE.Vector3;
            for (x[u] = a > 0 ? 1 : -1, c = 0; E > c; c++)
                for (l = 0; v > l; l++) {
                    var _ = new THREE.Vector3;
                    _[t] = (l * y - d) * r, _[e] = (c * T - m) * n, _[u] = a, s.vertices.push(_)
                }
            for (c = 0; f > c; c++)
                for (l = 0; p > l; l++) {
                    var b = l + v * c,
                        R = l + v * (c + 1),
                        w = l + 1 + v * (c + 1),
                        H = l + 1 + v * c,
                        M = new THREE.Vector2(l / p, 1 - c / f),
                        S = new THREE.Vector2(l / p, 1 - (c + 1) / f),
                        A = new THREE.Vector2((l + 1) / p, 1 - (c + 1) / f),
                        C = new THREE.Vector2((l + 1) / p, 1 - c / f),
                        k = new THREE.Face3(b + g, R + g, H + g);
                    k.normal.copy(x), k.vertexNormals.push(x.clone(), x.clone(), x.clone()), k.materialIndex = h, s.faces.push(k), s.faceVertexUvs[0].push([M, S, C]), k = new THREE.Face3(R + g, w + g, H + g), k.normal.copy(x), k.vertexNormals.push(x.clone(), x.clone(), x.clone()), k.materialIndex = h, s.faces.push(k), s.faceVertexUvs[0].push([S.clone(), A, C.clone()])
                }
        }
        THREE.Geometry.call(this), this.parameters = {
            width: t,
            height: e,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: o
        }, this.widthSegments = n || 1, this.heightSegments = i || 1, this.depthSegments = o || 1;
        var s = this,
            h = t / 2,
            u = e / 2,
            l = r / 2;
        a("z", "y", -1, -1, r, e, h, 0), a("z", "y", 1, -1, r, e, -h, 1), a("x", "z", 1, 1, t, r, u, 2), a("x", "z", 1, -1, t, r, -u, 3), a("x", "y", 1, -1, t, e, l, 4), a("x", "y", -1, -1, t, e, -l, 5), this.mergeVertices()
    }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry = function(t, e, r, n) {
        THREE.Geometry.call(this), this.parameters = {
            radius: t,
            segments: e,
            thetaStart: r,
            thetaLength: n
        }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI;
        var i, o = [],
            a = new THREE.Vector3,
            s = new THREE.Vector2(.5, .5);
        for (this.vertices.push(a), o.push(s), i = 0; e >= i; i++) {
            var h = new THREE.Vector3,
                u = r + i / e * n;
            h.x = t * Math.cos(u), h.y = t * Math.sin(u), this.vertices.push(h), o.push(new THREE.Vector2((h.x / t + 1) / 2, (h.y / t + 1) / 2))
        }
        var l = new THREE.Vector3(0, 0, 1);
        for (i = 1; e >= i; i++) this.faces.push(new THREE.Face3(i, i + 1, 0, [l.clone(), l.clone(), l.clone()])), this.faceVertexUvs[0].push([o[i].clone(), o[i + 1].clone(), s.clone()]);
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t)
    }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CubeGeometry = function(t, e, r, n, i, o) {
        return console.warn("THEE.CubeGeometry has been renamed to THREE.BoxGeometry."), new THREE.BoxGeometry(t, e, r, n, i, o)
    }, THREE.CylinderGeometry = function(t, e, r, n, i, o) {
        THREE.Geometry.call(this), this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: o
        }, t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, r = void 0 !== r ? r : 100, n = n || 8, i = i || 1, o = void 0 !== o ? o : !1;
        var a, s, h = r / 2,
            u = [],
            l = [];
        for (s = 0; i >= s; s++) {
            var c = [],
                p = [],
                f = s / i,
                d = f * (e - t) + t;
            for (a = 0; n >= a; a++) {
                var m = a / n,
                    g = new THREE.Vector3;
                g.x = d * Math.sin(m * Math.PI * 2), g.y = -f * r + h, g.z = d * Math.cos(m * Math.PI * 2), this.vertices.push(g), c.push(this.vertices.length - 1), p.push(new THREE.Vector2(m, 1 - f))
            }
            u.push(c), l.push(p)
        }
        var v, E, y = (e - t) / r;
        for (a = 0; n > a; a++)
            for (0 !== t ? (v = this.vertices[u[0][a]].clone(), E = this.vertices[u[0][a + 1]].clone()) : (v = this.vertices[u[1][a]].clone(), E = this.vertices[u[1][a + 1]].clone()), v.setY(Math.sqrt(v.x * v.x + v.z * v.z) * y).normalize(), E.setY(Math.sqrt(E.x * E.x + E.z * E.z) * y).normalize(), s = 0; i > s; s++) {
                var T = u[s][a],
                    x = u[s + 1][a],
                    _ = u[s + 1][a + 1],
                    b = u[s][a + 1],
                    R = v.clone(),
                    w = v.clone(),
                    H = E.clone(),
                    M = E.clone(),
                    S = l[s][a].clone(),
                    A = l[s + 1][a].clone(),
                    C = l[s + 1][a + 1].clone(),
                    k = l[s][a + 1].clone();
                this.faces.push(new THREE.Face3(T, x, b, [R, w, M])), this.faceVertexUvs[0].push([S, A, k]), this.faces.push(new THREE.Face3(x, _, b, [w.clone(), H, M.clone()])), this.faceVertexUvs[0].push([A.clone(), C, k.clone()])
            }
        if (o === !1 && t > 0)
            for (this.vertices.push(new THREE.Vector3(0, h, 0)), a = 0; n > a; a++) {
                var T = u[0][a],
                    x = u[0][a + 1],
                    _ = this.vertices.length - 1,
                    R = new THREE.Vector3(0, 1, 0),
                    w = new THREE.Vector3(0, 1, 0),
                    H = new THREE.Vector3(0, 1, 0),
                    S = l[0][a].clone(),
                    A = l[0][a + 1].clone(),
                    C = new THREE.Vector2(A.x, 0);
                this.faces.push(new THREE.Face3(T, x, _, [R, w, H])), this.faceVertexUvs[0].push([S, A, C])
            }
        if (o === !1 && e > 0)
            for (this.vertices.push(new THREE.Vector3(0, -h, 0)), a = 0; n > a; a++) {
                var T = u[s][a + 1],
                    x = u[s][a],
                    _ = this.vertices.length - 1,
                    R = new THREE.Vector3(0, -1, 0),
                    w = new THREE.Vector3(0, -1, 0),
                    H = new THREE.Vector3(0, -1, 0),
                    S = l[s][a + 1].clone(),
                    A = l[s][a].clone(),
                    C = new THREE.Vector2(A.x, 1);
                this.faces.push(new THREE.Face3(T, x, _, [R, w, H])), this.faceVertexUvs[0].push([S, A, C])
            }
        this.computeFaceNormals()
    }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry = function(t, e) {
        return "undefined" == typeof t ? void(t = []) : (THREE.Geometry.call(this), t = t instanceof Array ? t : [t], this.addShapeList(t, e), void this.computeFaceNormals())
    }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.addShapeList = function(t, e) {
        for (var r = t.length, n = 0; r > n; n++) {
            var i = t[n];
            this.addShape(i, e)
        }
    }, THREE.ExtrudeGeometry.prototype.addShape = function(t, e) {
        function r(t, e, r) {
            return e || console.log("die"), e.clone().multiplyScalar(r).add(t)
        }

        function n(t, e, r) {
            var n, i, o = 1e-10,
                a = THREE.Math.sign,
                s = 1,
                h = t.x - e.x,
                u = t.y - e.y,
                l = r.x - t.x,
                c = r.y - t.y,
                p = h * h + u * u,
                f = h * c - u * l;
            if (Math.abs(f) > o) {
                var d = Math.sqrt(p),
                    m = Math.sqrt(l * l + c * c),
                    g = e.x - u / d,
                    v = e.y + h / d,
                    E = r.x - c / m,
                    y = r.y + l / m,
                    T = ((E - g) * c - (y - v) * l) / (h * c - u * l);
                n = g + h * T - t.x, i = v + u * T - t.y;
                var x = n * n + i * i;
                if (2 >= x) return new THREE.Vector2(n, i);
                s = Math.sqrt(x / 2)
            } else {
                var _ = !1;
                h > o ? l > o && (_ = !0) : -o > h ? -o > l && (_ = !0) : a(u) == a(c) && (_ = !0), _ ? (n = -u, i = h, s = Math.sqrt(p)) : (n = h, i = u, s = Math.sqrt(p / 2))
            }
            return new THREE.Vector2(n / s, i / s)
        }

        function i() {
            if (y) {
                var t = 0,
                    e = G * t;
                for (q = 0; W > q; q++) I = F[q], h(I[2] + e, I[1] + e, I[0] + e, !0);
                for (t = x + 2 * E, e = G * t, q = 0; W > q; q++) I = F[q], h(I[0] + e, I[1] + e, I[2] + e, !1)
            } else {
                for (q = 0; W > q; q++) I = F[q], h(I[2], I[1], I[0], !0);
                for (q = 0; W > q; q++) I = F[q], h(I[0] + G * x, I[1] + G * x, I[2] + G * x, !1)
            }
        }

        function o() {
            var t = 0;
            for (a(U, t), t += U.length, S = 0, A = P.length; A > S; S++) M = P[S], a(M, t), t += M.length
        }

        function a(t, e) {
            var r, n;
            for (q = t.length; --q >= 0;) {
                r = q, n = q - 1, 0 > n && (n = t.length - 1);
                var i = 0,
                    o = x + 2 * E;
                for (i = 0; o > i; i++) {
                    var a = G * i,
                        s = G * (i + 1),
                        h = e + r + a,
                        l = e + n + a,
                        c = e + n + s,
                        p = e + r + s;
                    u(h, l, c, p, t, i, o, r, n)
                }
            }
        }

        function s(t, e, r) {
            C.vertices.push(new THREE.Vector3(t, e, r))
        }

        function h(r, n, i, o) {
            r += k, n += k, i += k, C.faces.push(new THREE.Face3(r, n, i, null, null, R));
            var a = o ? H.generateBottomUV(C, t, e, r, n, i) : H.generateTopUV(C, t, e, r, n, i);
            C.faceVertexUvs[0].push(a)
        }

        function u(r, n, i, o, a, s, h, u, l) {
            r += k, n += k, i += k, o += k, C.faces.push(new THREE.Face3(r, n, o, null, null, w)), C.faces.push(new THREE.Face3(n, i, o, null, null, w));
            var c = H.generateSideWallUV(C, t, a, e, r, n, i, o, s, h, u, l);
            C.faceVertexUvs[0].push([c[0], c[1], c[3]]), C.faceVertexUvs[0].push([c[1], c[2], c[3]])
        }
        var l, c, p, f, d, m = void 0 !== e.amount ? e.amount : 100,
            g = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            v = void 0 !== e.bevelSize ? e.bevelSize : g - 2,
            E = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
            y = void 0 !== e.bevelEnabled ? e.bevelEnabled : !0,
            T = void 0 !== e.curveSegments ? e.curveSegments : 12,
            x = void 0 !== e.steps ? e.steps : 1,
            _ = e.extrudePath,
            b = !1,
            R = e.material,
            w = e.extrudeMaterial,
            H = void 0 !== e.UVGenerator ? e.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
        _ && (l = _.getSpacedPoints(x), b = !0, y = !1, c = void 0 !== e.frames ? e.frames : new THREE.TubeGeometry.FrenetFrames(_, x, !1), p = new THREE.Vector3, f = new THREE.Vector3, d = new THREE.Vector3), y || (E = 0, g = 0, v = 0);
        var M, S, A, C = this,
            k = this.vertices.length,
            L = t.extractPoints(T),
            z = L.shape,
            P = L.holes,
            D = !THREE.Shape.Utils.isClockWise(z);
        if (D) {
            for (z = z.reverse(), S = 0, A = P.length; A > S; S++) M = P[S], THREE.Shape.Utils.isClockWise(M) && (P[S] = M.reverse());
            D = !1
        }
        var F = THREE.Shape.Utils.triangulateShape(z, P),
            U = z;
        for (S = 0, A = P.length; A > S; S++) M = P[S], z = z.concat(M);
        for (var O, B, V, N, j, I, G = z.length, W = F.length, X = (U.length, 180 / Math.PI, []), q = 0, Y = U.length, K = Y - 1, Z = q + 1; Y > q; q++, K++, Z++) {
            K === Y && (K = 0), Z === Y && (Z = 0); {
                U[q], U[K], U[Z]
            }
            X[q] = n(U[q], U[K], U[Z])
        }
        var Q, J = [],
            $ = X.concat();
        for (S = 0, A = P.length; A > S; S++) {
            for (M = P[S], Q = [], q = 0, Y = M.length, K = Y - 1, Z = q + 1; Y > q; q++, K++, Z++) K === Y && (K = 0), Z === Y && (Z = 0), Q[q] = n(M[q], M[K], M[Z]);
            J.push(Q), $ = $.concat(Q)
        }
        for (O = 0; E > O; O++) {
            for (V = O / E, N = g * (1 - V), B = v * Math.sin(V * Math.PI / 2), q = 0, Y = U.length; Y > q; q++) j = r(U[q], X[q], B), s(j.x, j.y, -N);
            for (S = 0, A = P.length; A > S; S++)
                for (M = P[S], Q = J[S], q = 0, Y = M.length; Y > q; q++) j = r(M[q], Q[q], B), s(j.x, j.y, -N)
        }
        for (B = v, q = 0; G > q; q++) j = y ? r(z[q], $[q], B) : z[q], b ? (f.copy(c.normals[0]).multiplyScalar(j.x), p.copy(c.binormals[0]).multiplyScalar(j.y), d.copy(l[0]).add(f).add(p), s(d.x, d.y, d.z)) : s(j.x, j.y, 0);
        var te;
        for (te = 1; x >= te; te++)
            for (q = 0; G > q; q++) j = y ? r(z[q], $[q], B) : z[q], b ? (f.copy(c.normals[te]).multiplyScalar(j.x), p.copy(c.binormals[te]).multiplyScalar(j.y), d.copy(l[te]).add(f).add(p), s(d.x, d.y, d.z)) : s(j.x, j.y, m / x * te);
        for (O = E - 1; O >= 0; O--) {
            for (V = O / E, N = g * (1 - V), B = v * Math.sin(V * Math.PI / 2), q = 0, Y = U.length; Y > q; q++) j = r(U[q], X[q], B), s(j.x, j.y, m + N);
            for (S = 0, A = P.length; A > S; S++)
                for (M = P[S], Q = J[S], q = 0, Y = M.length; Y > q; q++) j = r(M[q], Q[q], B), b ? s(j.x, j.y + l[x - 1].y, l[x - 1].x + N) : s(j.x, j.y, m + N)
        }
        i(), o()
    }, THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(t, e, r, n, i, o) {
            var a = t.vertices[n].x,
                s = t.vertices[n].y,
                h = t.vertices[i].x,
                u = t.vertices[i].y,
                l = t.vertices[o].x,
                c = t.vertices[o].y;
            return [new THREE.Vector2(a, s), new THREE.Vector2(h, u), new THREE.Vector2(l, c)]
        },
        generateBottomUV: function(t, e, r, n, i, o) {
            return this.generateTopUV(t, e, r, n, i, o)
        },
        generateSideWallUV: function(t, e, r, n, i, o, a, s) {
            var h = t.vertices[i].x,
                u = t.vertices[i].y,
                l = t.vertices[i].z,
                c = t.vertices[o].x,
                p = t.vertices[o].y,
                f = t.vertices[o].z,
                d = t.vertices[a].x,
                m = t.vertices[a].y,
                g = t.vertices[a].z,
                v = t.vertices[s].x,
                E = t.vertices[s].y,
                y = t.vertices[s].z;
            return Math.abs(u - p) < .01 ? [new THREE.Vector2(h, 1 - l), new THREE.Vector2(c, 1 - f), new THREE.Vector2(d, 1 - g), new THREE.Vector2(v, 1 - y)] : [new THREE.Vector2(u, 1 - l), new THREE.Vector2(p, 1 - f), new THREE.Vector2(m, 1 - g), new THREE.Vector2(E, 1 - y)]
        }
    }, THREE.ExtrudeGeometry.__v1 = new THREE.Vector2, THREE.ExtrudeGeometry.__v2 = new THREE.Vector2, THREE.ExtrudeGeometry.__v3 = new THREE.Vector2, THREE.ExtrudeGeometry.__v4 = new THREE.Vector2, THREE.ExtrudeGeometry.__v5 = new THREE.Vector2, THREE.ExtrudeGeometry.__v6 = new THREE.Vector2, THREE.ShapeGeometry = function(t, e) {
        THREE.Geometry.call(this), t instanceof Array == !1 && (t = [t]), this.addShapeList(t, e), this.computeFaceNormals()
    }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.addShapeList = function(t, e) {
        for (var r = 0, n = t.length; n > r; r++) this.addShape(t[r], e);
        return this
    }, THREE.ShapeGeometry.prototype.addShape = function(t, e) {
        void 0 === e && (e = {});
        var r, n, i, o = void 0 !== e.curveSegments ? e.curveSegments : 12,
            a = e.material,
            s = void 0 === e.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : e.UVGenerator,
            h = this.vertices.length,
            u = t.extractPoints(o),
            l = u.shape,
            c = u.holes,
            p = !THREE.Shape.Utils.isClockWise(l);
        if (p) {
            for (l = l.reverse(), r = 0, n = c.length; n > r; r++) i = c[r], THREE.Shape.Utils.isClockWise(i) && (c[r] = i.reverse());
            p = !1
        }
        var f = THREE.Shape.Utils.triangulateShape(l, c),
            d = l;
        for (r = 0, n = c.length; n > r; r++) i = c[r], l = l.concat(i); {
            var m, g, v = l.length,
                E = f.length;
            d.length
        }
        for (r = 0; v > r; r++) m = l[r], this.vertices.push(new THREE.Vector3(m.x, m.y, 0));
        for (r = 0; E > r; r++) {
            g = f[r];
            var y = g[0] + h,
                T = g[1] + h,
                x = g[2] + h;
            this.faces.push(new THREE.Face3(y, T, x, null, null, a)), this.faceVertexUvs[0].push(s.generateBottomUV(this, t, e, y, T, x))
        }
    }, THREE.LatheGeometry = function(t, e, r, n) {
        THREE.Geometry.call(this), e = e || 12, r = r || 0, n = n || 2 * Math.PI;
        for (var i = 1 / (t.length - 1), o = 1 / e, a = 0, s = e; s >= a; a++)
            for (var h = r + a * o * n, u = Math.cos(h), l = Math.sin(h), c = 0, p = t.length; p > c; c++) {
                var f = t[c],
                    d = new THREE.Vector3;
                d.x = u * f.x - l * f.y, d.y = l * f.x + u * f.y, d.z = f.z, this.vertices.push(d)
            }
        for (var m = t.length, a = 0, s = e; s > a; a++)
            for (var c = 0, p = t.length - 1; p > c; c++) {
                var g = c + m * a,
                    v = g,
                    E = g + m,
                    u = g + 1 + m,
                    y = g + 1,
                    T = a * o,
                    x = c * i,
                    _ = T + o,
                    b = x + i;
                this.faces.push(new THREE.Face3(v, E, y)), this.faceVertexUvs[0].push([new THREE.Vector2(T, x), new THREE.Vector2(_, x), new THREE.Vector2(T, b)]), this.faces.push(new THREE.Face3(E, u, y)), this.faceVertexUvs[0].push([new THREE.Vector2(_, x), new THREE.Vector2(_, b), new THREE.Vector2(T, b)])
            }
        this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry = function(t, e, r, n) {
        THREE.Geometry.call(this), this.parameters = {
            width: t,
            height: e,
            widthSegments: r,
            heightSegments: n
        };
        var i, o, a = t / 2,
            s = e / 2,
            h = r || 1,
            u = n || 1,
            l = h + 1,
            c = u + 1,
            p = t / h,
            f = e / u,
            d = new THREE.Vector3(0, 0, 1);
        for (o = 0; c > o; o++) {
            var m = o * f - s;
            for (i = 0; l > i; i++) {
                var g = i * p - a;
                this.vertices.push(new THREE.Vector3(g, -m, 0))
            }
        }
        for (o = 0; u > o; o++)
            for (i = 0; h > i; i++) {
                var v = i + l * o,
                    E = i + l * (o + 1),
                    y = i + 1 + l * (o + 1),
                    T = i + 1 + l * o,
                    x = new THREE.Vector2(i / h, 1 - o / u),
                    _ = new THREE.Vector2(i / h, 1 - (o + 1) / u),
                    b = new THREE.Vector2((i + 1) / h, 1 - (o + 1) / u),
                    R = new THREE.Vector2((i + 1) / h, 1 - o / u),
                    w = new THREE.Face3(v, E, T);
                w.normal.copy(d), w.vertexNormals.push(d.clone(), d.clone(), d.clone()), this.faces.push(w), this.faceVertexUvs[0].push([x, _, R]), w = new THREE.Face3(E, y, T), w.normal.copy(d), w.vertexNormals.push(d.clone(), d.clone(), d.clone()), this.faces.push(w), this.faceVertexUvs[0].push([_.clone(), b, R.clone()])
            }
    }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry = function(t, e, r, n, i, o) {
        THREE.Geometry.call(this), t = t || 0, e = e || 50, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, r = void 0 !== r ? Math.max(3, r) : 8, n = void 0 !== n ? Math.max(1, n) : 8;
        var a, s, h = [],
            u = t,
            l = (e - t) / n;
        for (a = 0; n + 1 > a; a++) {
            for (s = 0; r + 1 > s; s++) {
                var c = new THREE.Vector3,
                    p = i + s / r * o;
                c.x = u * Math.cos(p), c.y = u * Math.sin(p), this.vertices.push(c), h.push(new THREE.Vector2((c.x / e + 1) / 2, (c.y / e + 1) / 2))
            }
            u += l
        }
        var f = new THREE.Vector3(0, 0, 1);
        for (a = 0; n > a; a++) {
            var d = a * (r + 1);
            for (s = 0; r > s; s++) {
                var p = s + d,
                    m = p,
                    g = p + r + 1,
                    v = p + r + 2;
                this.faces.push(new THREE.Face3(m, g, v, [f.clone(), f.clone(), f.clone()])), this.faceVertexUvs[0].push([h[m].clone(), h[g].clone(), h[v].clone()]), m = p, g = p + r + 2, v = p + 1, this.faces.push(new THREE.Face3(m, g, v, [f.clone(), f.clone(), f.clone()])), this.faceVertexUvs[0].push([h[m].clone(), h[g].clone(), h[v].clone()])
            }
        }
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, u)
    }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry = function(t, e, r, n, i, o, a) {
        THREE.Geometry.call(this), this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), r = Math.max(2, Math.floor(r) || 6), n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, h, u = [],
            l = [];
        for (h = 0; r >= h; h++) {
            var c = [],
                p = [];
            for (s = 0; e >= s; s++) {
                var f = s / e,
                    d = h / r,
                    m = new THREE.Vector3;
                m.x = -t * Math.cos(n + f * i) * Math.sin(o + d * a), m.y = t * Math.cos(o + d * a), m.z = t * Math.sin(n + f * i) * Math.sin(o + d * a), this.vertices.push(m), c.push(this.vertices.length - 1), p.push(new THREE.Vector2(f, 1 - d))
            }
            u.push(c), l.push(p)
        }
        for (h = 0; r > h; h++)
            for (s = 0; e > s; s++) {
                var g = u[h][s + 1],
                    v = u[h][s],
                    E = u[h + 1][s],
                    y = u[h + 1][s + 1],
                    T = this.vertices[g].clone().normalize(),
                    x = this.vertices[v].clone().normalize(),
                    _ = this.vertices[E].clone().normalize(),
                    b = this.vertices[y].clone().normalize(),
                    R = l[h][s + 1].clone(),
                    w = l[h][s].clone(),
                    H = l[h + 1][s].clone(),
                    M = l[h + 1][s + 1].clone();
                Math.abs(this.vertices[g].y) === t ? (R.x = (R.x + w.x) / 2, this.faces.push(new THREE.Face3(g, E, y, [T, _, b])), this.faceVertexUvs[0].push([R, H, M])) : Math.abs(this.vertices[E].y) === t ? (H.x = (H.x + M.x) / 2, this.faces.push(new THREE.Face3(g, v, E, [T, x, _])), this.faceVertexUvs[0].push([R, w, H])) : (this.faces.push(new THREE.Face3(g, v, y, [T, x, b])), this.faceVertexUvs[0].push([R, w, M]), this.faces.push(new THREE.Face3(v, E, y, [x.clone(), _, b.clone()])), this.faceVertexUvs[0].push([w.clone(), H, M.clone()]))
            }
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t)
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TextGeometry = function(t, e) {
        e = e || {};
        var r = THREE.FontUtils.generateShapes(t, e);
        e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, r, e)
    }, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TorusGeometry = function(t, e, r, n, i) {
        THREE.Geometry.call(this), this.parameters = {
            radius: t,
            tube: e,
            radialSegments: r,
            tubularSegments: n,
            arc: i
        }, t = t || 100, e = e || 40, r = r || 8, n = n || 6, i = i || 2 * Math.PI;
        for (var o = new THREE.Vector3, a = [], s = [], h = 0; r >= h; h++)
            for (var u = 0; n >= u; u++) {
                var l = u / n * i,
                    c = h / r * Math.PI * 2;
                o.x = t * Math.cos(l), o.y = t * Math.sin(l);
                var p = new THREE.Vector3;
                p.x = (t + e * Math.cos(c)) * Math.cos(l), p.y = (t + e * Math.cos(c)) * Math.sin(l), p.z = e * Math.sin(c), this.vertices.push(p), a.push(new THREE.Vector2(u / n, h / r)), s.push(p.clone().sub(o).normalize())
            }
        for (var h = 1; r >= h; h++)
            for (var u = 1; n >= u; u++) {
                var f = (n + 1) * h + u - 1,
                    d = (n + 1) * (h - 1) + u - 1,
                    m = (n + 1) * (h - 1) + u,
                    g = (n + 1) * h + u,
                    v = new THREE.Face3(f, d, g, [s[f].clone(), s[d].clone(), s[g].clone()]);
                this.faces.push(v), this.faceVertexUvs[0].push([a[f].clone(), a[d].clone(), a[g].clone()]), v = new THREE.Face3(d, m, g, [s[d].clone(), s[m].clone(), s[g].clone()]), this.faces.push(v), this.faceVertexUvs[0].push([a[d].clone(), a[m].clone(), a[g].clone()])
            }
        this.computeFaceNormals()
    }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry = function(t, e, r, n, i, o, a) {
        function s(t, e, r, n, i) {
            var o = Math.cos(t),
                a = Math.sin(t),
                s = e / r * t,
                h = Math.cos(s),
                u = n * (2 + h) * .5 * o,
                l = n * (2 + h) * a * .5,
                c = i * n * Math.sin(s) * .5;
            return new THREE.Vector3(u, l, c)
        }
        THREE.Geometry.call(this), this.parameters = {
            radius: t,
            tube: e,
            radialSegments: r,
            tubularSegments: n,
            p: i,
            q: o,
            heightScale: a
        }, t = t || 100, e = e || 40, r = r || 64, n = n || 8, i = i || 2, o = o || 3, a = a || 1;
        for (var h = new Array(r), u = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3, p = 0; r > p; ++p) {
            h[p] = new Array(n);
            var f = p / r * 2 * i * Math.PI,
                d = s(f, o, i, t, a),
                m = s(f + .01, o, i, t, a);
            u.subVectors(m, d), l.addVectors(m, d), c.crossVectors(u, l), l.crossVectors(c, u), c.normalize(), l.normalize();
            for (var g = 0; n > g; ++g) {
                var v = g / n * 2 * Math.PI,
                    E = -e * Math.cos(v),
                    y = e * Math.sin(v),
                    T = new THREE.Vector3;
                T.x = d.x + E * l.x + y * c.x, T.y = d.y + E * l.y + y * c.y, T.z = d.z + E * l.z + y * c.z, h[p][g] = this.vertices.push(T) - 1
            }
        }
        for (var p = 0; r > p; ++p)
            for (var g = 0; n > g; ++g) {
                var x = (p + 1) % r,
                    _ = (g + 1) % n,
                    b = h[p][g],
                    R = h[x][g],
                    w = h[x][_],
                    H = h[p][_],
                    M = new THREE.Vector2(p / r, g / n),
                    S = new THREE.Vector2((p + 1) / r, g / n),
                    A = new THREE.Vector2((p + 1) / r, (g + 1) / n),
                    C = new THREE.Vector2(p / r, (g + 1) / n);
                this.faces.push(new THREE.Face3(b, R, H)), this.faceVertexUvs[0].push([M, S, C]), this.faces.push(new THREE.Face3(R, w, H)), this.faceVertexUvs[0].push([S.clone(), A, C.clone()])
            }
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry = function(t, e, r, n, i) {
        function o(t, e, r) {
            return M.vertices.push(new THREE.Vector3(t, e, r)) - 1
        }
        THREE.Geometry.call(this), this.parameters = {
            path: t,
            segments: e,
            radius: r,
            radialSegments: n,
            closed: i
        }, e = e || 64, r = r || 1, n = n || 8, i = i || !1;
        var a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H = [],
            M = this,
            S = e + 1,
            A = new THREE.Vector3,
            C = new THREE.TubeGeometry.FrenetFrames(t, e, i),
            k = C.tangents,
            L = C.normals,
            z = C.binormals;
        for (this.tangents = k, this.normals = L, this.binormals = z, d = 0; S > d; d++)
            for (H[d] = [], u = d / (S - 1), f = t.getPointAt(u), a = k[d], s = L[d], h = z[d], m = 0; n > m; m++) l = m / n * 2 * Math.PI, c = -r * Math.cos(l), p = r * Math.sin(l), A.copy(f), A.x += c * s.x + p * h.x, A.y += c * s.y + p * h.y, A.z += c * s.z + p * h.z, H[d][m] = o(A.x, A.y, A.z);
        for (d = 0; e > d; d++)
            for (m = 0; n > m; m++) g = i ? (d + 1) % e : d + 1, v = (m + 1) % n, E = H[d][m], y = H[g][m], T = H[g][v], x = H[d][v], _ = new THREE.Vector2(d / e, m / n), b = new THREE.Vector2((d + 1) / e, m / n), R = new THREE.Vector2((d + 1) / e, (m + 1) / n), w = new THREE.Vector2(d / e, (m + 1) / n), this.faces.push(new THREE.Face3(E, y, x)), this.faceVertexUvs[0].push([_, b, w]), this.faces.push(new THREE.Face3(y, T, x)), this.faceVertexUvs[0].push([b.clone(), R, w.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.FrenetFrames = function(t, e, r) {
        function n() {
            f[0] = new THREE.Vector3, d[0] = new THREE.Vector3, o = Number.MAX_VALUE, a = Math.abs(p[0].x), s = Math.abs(p[0].y), h = Math.abs(p[0].z), o >= a && (o = a, c.set(1, 0, 0)), o >= s && (o = s, c.set(0, 1, 0)), o >= h && c.set(0, 0, 1), m.crossVectors(p[0], c).normalize(), f[0].crossVectors(p[0], m), d[0].crossVectors(p[0], f[0])
        }
        var i, o, a, s, h, u, l, c = (new THREE.Vector3, new THREE.Vector3),
            p = (new THREE.Vector3, []),
            f = [],
            d = [],
            m = new THREE.Vector3,
            g = new THREE.Matrix4,
            v = e + 1,
            E = 1e-4;
        for (this.tangents = p, this.normals = f, this.binormals = d, u = 0; v > u; u++) l = u / (v - 1), p[u] = t.getTangentAt(l), p[u].normalize();
        for (n(), u = 1; v > u; u++) f[u] = f[u - 1].clone(), d[u] = d[u - 1].clone(), m.crossVectors(p[u - 1], p[u]), m.length() > E && (m.normalize(), i = Math.acos(THREE.Math.clamp(p[u - 1].dot(p[u]), -1, 1)), f[u].applyMatrix4(g.makeRotationAxis(m, i))), d[u].crossVectors(p[u], f[u]);
        if (r)
            for (i = Math.acos(THREE.Math.clamp(f[0].dot(f[v - 1]), -1, 1)), i /= v - 1, p[0].dot(m.crossVectors(f[0], f[v - 1])) > 0 && (i = -i), u = 1; v > u; u++) f[u].applyMatrix4(g.makeRotationAxis(p[u], i * u)), d[u].crossVectors(p[u], f[u])
    }, THREE.PolyhedronGeometry = function(t, e, r, n) {
        function i(t) {
            var e = t.normalize().clone();
            e.index = l.vertices.push(e) - 1;
            var r = s(t) / 2 / Math.PI + .5,
                n = h(t) / Math.PI + .5;
            return e.uv = new THREE.Vector2(r, 1 - n), e
        }

        function o(t, e, r) {
            var n = new THREE.Face3(t.index, e.index, r.index, [t.clone(), e.clone(), r.clone()]);
            l.faces.push(n), y.copy(t).add(e).add(r).divideScalar(3);
            var i = s(y);
            l.faceVertexUvs[0].push([u(t.uv, t, i), u(e.uv, e, i), u(r.uv, r, i)])
        }

        function a(t, e) {
            for (var r = Math.pow(2, e), n = (Math.pow(4, e), i(l.vertices[t.a])), a = i(l.vertices[t.b]), s = i(l.vertices[t.c]), h = [], u = 0; r >= u; u++) {
                h[u] = [];
                for (var c = i(n.clone().lerp(s, u / r)), p = i(a.clone().lerp(s, u / r)), f = r - u, d = 0; f >= d; d++) h[u][d] = 0 == d && u == r ? c : i(c.clone().lerp(p, d / f))
            }
            for (var u = 0; r > u; u++)
                for (var d = 0; 2 * (r - u) - 1 > d; d++) {
                    var m = Math.floor(d / 2);
                    d % 2 == 0 ? o(h[u][m + 1], h[u + 1][m], h[u][m]) : o(h[u][m + 1], h[u + 1][m + 1], h[u + 1][m])
                }
        }

        function s(t) {
            return Math.atan2(t.z, -t.x)
        }

        function h(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }

        function u(t, e, r) {
            return 0 > r && 1 === t.x && (t = new THREE.Vector2(t.x - 1, t.y)), 0 === e.x && 0 === e.z && (t = new THREE.Vector2(r / 2 / Math.PI + .5, t.y)), t.clone()
        }
        THREE.Geometry.call(this), r = r || 1, n = n || 0;
        for (var l = this, c = 0, p = t.length; p > c; c += 3) i(new THREE.Vector3(t[c], t[c + 1], t[c + 2]));
        for (var f = this.vertices, d = [], c = 0, m = 0, p = e.length; p > c; c += 3, m++) {
            var g = f[e[c]],
                v = f[e[c + 1]],
                E = f[e[c + 2]];
            d[m] = new THREE.Face3(g.index, v.index, E.index, [g.clone(), v.clone(), E.clone()])
        }
        for (var y = new THREE.Vector3, c = 0, p = d.length; p > c; c++) a(d[c], n);
        for (var c = 0, p = this.faceVertexUvs[0].length; p > c; c++) {
            var T = this.faceVertexUvs[0][c],
                x = T[0].x,
                _ = T[1].x,
                b = T[2].x,
                R = Math.max(x, Math.max(_, b)),
                w = Math.min(x, Math.min(_, b));
            R > .9 && .1 > w && (.2 > x && (T[0].x += 1), .2 > _ && (T[1].x += 1), .2 > b && (T[2].x += 1))
        }
        for (var c = 0, p = this.vertices.length; p > c; c++) this.vertices[c].multiplyScalar(r);
        this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, r)
    }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry = function(t, e) {
        this.parameters = {
            radius: t,
            detail: e
        };
        var r = (1 + Math.sqrt(5)) / 2,
            n = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1],
            i = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        THREE.PolyhedronGeometry.call(this, n, i, t, e)
    }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry = function(t, e) {
        this.parameters = {
            radius: t,
            detail: e
        };
        var r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        THREE.PolyhedronGeometry.call(this, r, n, t, e)
    }, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry = function(t, e) {
        var r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        THREE.PolyhedronGeometry.call(this, r, n, t, e)
    }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry = function(t, e, r) {
        THREE.Geometry.call(this);
        var n, i, o, a, s, h = this.vertices,
            u = this.faces,
            l = this.faceVertexUvs[0],
            c = e + 1;
        for (n = 0; r >= n; n++)
            for (s = n / r, i = 0; e >= i; i++) a = i / e, o = t(a, s), h.push(o);
        var p, f, d, m, g, v, E, y;
        for (n = 0; r > n; n++)
            for (i = 0; e > i; i++) p = n * c + i, f = n * c + i + 1, d = (n + 1) * c + i + 1, m = (n + 1) * c + i, g = new THREE.Vector2(i / e, n / r), v = new THREE.Vector2((i + 1) / e, n / r), E = new THREE.Vector2((i + 1) / e, (n + 1) / r), y = new THREE.Vector2(i / e, (n + 1) / r), u.push(new THREE.Face3(p, f, m)), l.push([g, v, y]), u.push(new THREE.Face3(f, d, m)), l.push([v.clone(), E, y.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.AxisHelper = function(t) {
        t = t || 1;
        var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]),
            r = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]),
            n = new THREE.BufferGeometry;
        n.addAttribute("position", new THREE.BufferAttribute(e, 3)), n.addAttribute("color", new THREE.BufferAttribute(r, 3));
        var i = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        });
        THREE.Line.call(this, n, i, THREE.LinePieces)
    }, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.ArrowHelper = function() {
        var t = new THREE.Geometry;
        t.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var e = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
        return e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)),
            function(r, n, i, o, a, s) {
                THREE.Object3D.call(this), void 0 === o && (o = 16776960), void 0 === i && (i = 1), void 0 === a && (a = .2 * i), void 0 === s && (s = .2 * a), this.position.copy(n), this.line = new THREE.Line(t, new THREE.LineBasicMaterial({
                    color: o
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(e, new THREE.MeshBasicMaterial({
                    color: o
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(r), this.setLength(i, a, s)
            }
    }(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.setDirection = function() {
        var t, e = new THREE.Vector3;
        return function(r) {
            r.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : r.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(r.z, 0, -r.x).normalize(), t = Math.acos(r.y), this.quaternion.setFromAxisAngle(e, t))
        }
    }(), THREE.ArrowHelper.prototype.setLength = function(t, e, r) {
        void 0 === e && (e = .2 * t), void 0 === r && (r = .2 * e), this.line.scale.set(1, t, 1), this.line.updateMatrix(), this.cone.scale.set(r, e, r), this.cone.position.y = t, this.cone.updateMatrix()
    }, THREE.ArrowHelper.prototype.setColor = function(t) {
        this.line.material.color.set(t), this.cone.material.color.set(t)
    }, THREE.BoxHelper = function(t) {
        var e = new THREE.BufferGeometry;
        e.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), THREE.Line.call(this, e, new THREE.LineBasicMaterial({
            color: 16776960
        }), THREE.LinePieces), void 0 !== t && this.update(t)
    }, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.update = function(t) {
        var e = t.geometry;
        null === e.boundingBox && e.computeBoundingBox();
        var r = e.boundingBox.min,
            n = e.boundingBox.max,
            i = this.geometry.attributes.position.array;
        i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = r.x, i[4] = n.y, i[5] = n.z, i[6] = r.x, i[7] = n.y, i[8] = n.z, i[9] = r.x, i[10] = r.y, i[11] = n.z, i[12] = r.x, i[13] = r.y, i[14] = n.z, i[15] = n.x, i[16] = r.y, i[17] = n.z, i[18] = n.x, i[19] = r.y, i[20] = n.z, i[21] = n.x, i[22] = n.y, i[23] = n.z, i[24] = n.x, i[25] = n.y, i[26] = r.z, i[27] = r.x, i[28] = n.y, i[29] = r.z, i[30] = r.x, i[31] = n.y, i[32] = r.z, i[33] = r.x, i[34] = r.y, i[35] = r.z, i[36] = r.x, i[37] = r.y, i[38] = r.z, i[39] = n.x, i[40] = r.y, i[41] = r.z, i[42] = n.x, i[43] = r.y, i[44] = r.z, i[45] = n.x, i[46] = n.y, i[47] = r.z, i[48] = n.x, i[49] = n.y, i[50] = n.z, i[51] = n.x, i[52] = n.y, i[53] = r.z, i[54] = r.x, i[55] = n.y, i[56] = n.z, i[57] = r.x, i[58] = n.y, i[59] = r.z, i[60] = r.x, i[61] = r.y, i[62] = n.z, i[63] = r.x, i[64] = r.y, i[65] = r.z, i[66] = n.x, i[67] = r.y, i[68] = n.z, i[69] = n.x, i[70] = r.y, i[71] = r.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrixAutoUpdate = !1, this.matrixWorld = t.matrixWorld
    }, THREE.BoundingBoxHelper = function(t, e) {
        var r = void 0 !== e ? e : 8947848;
        this.object = t, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
            color: r,
            wireframe: !0
        }))
    }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.update = function() {
        this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
    }, THREE.CameraHelper = function(t) {
        function e(t, e, n) {
            r(t, n), r(e, n)
        }

        function r(t, e) {
            n.vertices.push(new THREE.Vector3), n.colors.push(new THREE.Color(e)), void 0 === o[t] && (o[t] = []), o[t].push(n.vertices.length - 1)
        }
        var n = new THREE.Geometry,
            i = new THREE.LineBasicMaterial({
                color: 16777215,
                vertexColors: THREE.FaceColors
            }),
            o = {},
            a = 16755200,
            s = 16711680,
            h = 43775,
            u = 16777215,
            l = 3355443;
        e("n1", "n2", a), e("n2", "n4", a), e("n4", "n3", a), e("n3", "n1", a), e("f1", "f2", a), e("f2", "f4", a), e("f4", "f3", a), e("f3", "f1", a), e("n1", "f1", a), e("n2", "f2", a), e("n3", "f3", a), e("n4", "f4", a), e("p", "n1", s), e("p", "n2", s), e("p", "n3", s), e("p", "n4", s), e("u1", "u2", h), e("u2", "u3", h), e("u3", "u1", h), e("c", "t", u), e("p", "c", l), e("cn1", "cn2", l), e("cn3", "cn4", l), e("cf1", "cf2", l), e("cf3", "cf4", l), THREE.Line.call(this, n, i, THREE.LinePieces), this.camera = t, this.matrixWorld = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.update = function() {
        var t = new THREE.Vector3,
            e = new THREE.Camera,
            r = new THREE.Projector;
        return function() {
            function n(n, o, a, s) {
                t.set(o, a, s), r.unprojectVector(t, e);
                var h = i.pointMap[n];
                if (void 0 !== h)
                    for (var u = 0, l = h.length; l > u; u++) i.geometry.vertices[h[u]].copy(t)
            }
            var i = this,
                o = 1,
                a = 1;
            e.projectionMatrix.copy(this.camera.projectionMatrix), n("c", 0, 0, -1), n("t", 0, 0, 1), n("n1", -o, -a, -1), n("n2", o, -a, -1), n("n3", -o, a, -1), n("n4", o, a, -1), n("f1", -o, -a, 1), n("f2", o, -a, 1), n("f3", -o, a, 1), n("f4", o, a, 1), n("u1", .7 * o, 1.1 * a, -1), n("u2", .7 * -o, 1.1 * a, -1), n("u3", 0, 2 * a, -1), n("cf1", -o, 0, 1), n("cf2", o, 0, 1), n("cf3", 0, -a, 1), n("cf4", 0, a, 1), n("cn1", -o, 0, -1), n("cn2", o, 0, -1), n("cn3", 0, -a, -1), n("cn4", 0, a, -1), this.geometry.verticesNeedUpdate = !0
        }
    }(), THREE.DirectionalLightHelper = function(t, e) {
        THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrixWorld = t.matrixWorld, this.matrixAutoUpdate = !1, e = e || 1;
        var r = new THREE.Geometry;
        r.vertices.push(new THREE.Vector3(-e, e, 0), new THREE.Vector3(e, e, 0), new THREE.Vector3(e, -e, 0), new THREE.Vector3(-e, -e, 0), new THREE.Vector3(-e, e, 0));
        var n = new THREE.LineBasicMaterial({
            fog: !1
        });
        n.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(r, n), this.add(this.lightPlane), r = new THREE.Geometry, r.vertices.push(new THREE.Vector3, new THREE.Vector3), n = new THREE.LineBasicMaterial({
            fog: !1
        }), n.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(r, n), this.add(this.targetLine), this.update()
    }, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, THREE.DirectionalLightHelper.prototype.update = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3,
            r = new THREE.Vector3;
        return function() {
            t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), r.subVectors(e, t), this.lightPlane.lookAt(r), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(r), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
        }
    }(), THREE.EdgesHelper = function(t, e) {
        var r = void 0 !== e ? e : 16777215,
            n = [0, 0],
            i = {},
            o = function(t, e) {
                return t - e
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry,
            h = t.geometry.clone();
        h.mergeVertices(), h.computeFaceNormals();
        for (var u = h.vertices, l = h.faces, c = 0, p = 0, f = l.length; f > p; p++)
            for (var d = l[p], m = 0; 3 > m; m++) {
                n[0] = d[a[m]], n[1] = d[a[(m + 1) % 3]], n.sort(o);
                var g = n.toString();
                void 0 === i[g] ? (i[g] = {
                    vert1: n[0],
                    vert2: n[1],
                    face1: p,
                    face2: void 0
                }, c++) : i[g].face2 = p
            }
        s.addAttribute("position", new THREE.Float32Attribute(2 * c * 3, 3));
        var v = s.attributes.position.array,
            E = 0;
        for (var g in i) {
            var y = i[g];
            if (void 0 === y.face2 || l[y.face1].normal.dot(l[y.face2].normal) < .9999) {
                var T = u[y.vert1];
                v[E++] = T.x, v[E++] = T.y, v[E++] = T.z, T = u[y.vert2], v[E++] = T.x, v[E++] = T.y, v[E++] = T.z
            }
        }
        THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: r
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = t.matrixWorld
    }, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper = function(t, e, r, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        for (var i = void 0 !== r ? r : 16776960, o = void 0 !== n ? n : 1, a = new THREE.Geometry, s = this.object.geometry.faces, h = 0, u = s.length; u > h; h++) a.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, a, new THREE.LineBasicMaterial({
            color: i,
            linewidth: o
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.update = function() {
        var t = this.geometry.vertices,
            e = this.object,
            r = e.geometry.vertices,
            n = e.geometry.faces,
            i = e.matrixWorld;
        e.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(i);
        for (var o = 0, a = 0, s = n.length; s > o; o++, a += 2) {
            var h = n[o];
            t[a].copy(r[h.a]).add(r[h.b]).add(r[h.c]).divideScalar(3).applyMatrix4(i), t[a + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(t[a])
        }
        return this.geometry.verticesNeedUpdate = !0, this
    }, THREE.GridHelper = function(t, e) {
        var r = new THREE.Geometry,
            n = new THREE.LineBasicMaterial({
                vertexColors: THREE.VertexColors
            });
        this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
        for (var i = -t; t >= i; i += e) {
            r.vertices.push(new THREE.Vector3(-t, 0, i), new THREE.Vector3(t, 0, i), new THREE.Vector3(i, 0, -t), new THREE.Vector3(i, 0, t));
            var o = 0 === i ? this.color1 : this.color2;
            r.colors.push(o, o, o, o)
        }
        THREE.Line.call(this, r, n, THREE.LinePieces)
    }, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.setColors = function(t, e) {
        this.color1.set(t), this.color2.set(e), this.geometry.colorsNeedUpdate = !0
    }, THREE.HemisphereLightHelper = function(t, e) {
        THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrixWorld = t.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color];
        var r = new THREE.SphereGeometry(e, 4, 2);
        r.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        for (var n = 0, i = 8; i > n; n++) r.faces[n].color = this.colors[4 > n ? 0 : 1];
        var o = new THREE.MeshBasicMaterial({
            vertexColors: THREE.FaceColors,
            wireframe: !0
        });
        this.lightSphere = new THREE.Mesh(r, o), this.add(this.lightSphere), this.update()
    }, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.dispose = function() {
        this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
    }, THREE.HemisphereLightHelper.prototype.update = function() {
        var t = new THREE.Vector3;
        return function() {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
        }
    }(), THREE.PointLightHelper = function(t, e) {
        this.light = t, this.light.updateMatrixWorld();
        var r = new THREE.SphereGeometry(e, 4, 2),
            n = new THREE.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
        n.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, r, n), this.matrixWorld = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, THREE.PointLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }, THREE.SkeletonHelper = function(t) {
        this.bones = this.getBoneList(t);
        for (var e = new THREE.Geometry, r = 0; r < this.bones.length; r++) {
            var n = this.bones[r];
            n.parent instanceof THREE.Bone && (e.vertices.push(new THREE.Vector3), e.vertices.push(new THREE.Vector3), e.colors.push(new THREE.Color(0, 0, 1)), e.colors.push(new THREE.Color(0, 1, 0)))
        }
        var i = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        THREE.Line.call(this, e, i, THREE.LinePieces), this.root = t, this.matrixWorld = t.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.getBoneList = function(t) {
        var e = [];
        t instanceof THREE.Bone && e.push(t);
        for (var r = 0; r < t.children.length; r++) e.push.apply(e, this.getBoneList(t.children[r]));
        return e
    }, THREE.SkeletonHelper.prototype.update = function() {
        for (var t = this.geometry, e = (new THREE.Matrix4).getInverse(this.root.matrixWorld), r = new THREE.Matrix4, n = 0, i = 0; i < this.bones.length; i++) {
            var o = this.bones[i];
            o.parent instanceof THREE.Bone && (r.multiplyMatrices(e, o.matrixWorld), t.vertices[n].setFromMatrixPosition(r), r.multiplyMatrices(e, o.parent.matrixWorld), t.vertices[n + 1].setFromMatrixPosition(r), n += 2)
        }
        t.verticesNeedUpdate = !0, t.computeBoundingSphere()
    }, THREE.SpotLightHelper = function(t) {
        THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrixWorld = t.matrixWorld, this.matrixAutoUpdate = !1;
        var e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
        e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        var r = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        this.cone = new THREE.Mesh(e, r), this.add(this.cone), this.update()
    }, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, THREE.SpotLightHelper.prototype.update = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3;
        return function() {
            var r = this.light.distance ? this.light.distance : 1e4,
                n = r * Math.tan(this.light.angle);
            this.cone.scale.set(n, n, r), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }(), THREE.VertexNormalsHelper = function(t, e, r, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        for (var i = void 0 !== r ? r : 16711680, o = void 0 !== n ? n : 1, a = new THREE.Geometry, s = (t.geometry.vertices, t.geometry.faces), h = 0, u = s.length; u > h; h++)
            for (var l = s[h], c = 0, p = l.vertexNormals.length; p > c; c++) a.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, a, new THREE.LineBasicMaterial({
            color: i,
            linewidth: o
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.update = function() {
        var t = new THREE.Vector3;
        return function() {
            var e = ["a", "b", "c", "d"];
            this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var r = this.geometry.vertices, n = this.object.geometry.vertices, i = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, h = i.length; h > s; s++)
                for (var u = i[s], l = 0, c = u.vertexNormals.length; c > l; l++) {
                    var p = u[e[l]],
                        f = n[p],
                        d = u.vertexNormals[l];
                    r[a].copy(f).applyMatrix4(o), t.copy(d).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(r[a]), a += 1, r[a].copy(t), a += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.VertexTangentsHelper = function(t, e, r, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        for (var i = void 0 !== r ? r : 255, o = void 0 !== n ? n : 1, a = new THREE.Geometry, s = (t.geometry.vertices, t.geometry.faces), h = 0, u = s.length; u > h; h++)
            for (var l = s[h], c = 0, p = l.vertexTangents.length; p > c; c++) a.vertices.push(new THREE.Vector3), a.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, a, new THREE.LineBasicMaterial({
            color: i,
            linewidth: o
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
    }, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.update = function() {
        var t = new THREE.Vector3;
        return function() {
            var e = ["a", "b", "c", "d"];
            this.object.updateMatrixWorld(!0);
            for (var r = this.geometry.vertices, n = this.object.geometry.vertices, i = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, h = i.length; h > s; s++)
                for (var u = i[s], l = 0, c = u.vertexTangents.length; c > l; l++) {
                    var p = u[e[l]],
                        f = n[p],
                        d = u.vertexTangents[l];
                    r[a].copy(f).applyMatrix4(o), t.copy(d).transformDirection(o).multiplyScalar(this.size), t.add(r[a]), a += 1, r[a].copy(t), a += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.WireframeHelper = function(t, e) {
        var r = void 0 !== e ? e : 16777215,
            n = [0, 0],
            i = {},
            o = function(t, e) {
                return t - e
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry;
        if (t.geometry instanceof THREE.Geometry) {
            for (var h = t.geometry.vertices, u = t.geometry.faces, l = 0, c = new Uint32Array(6 * u.length), p = 0, f = u.length; f > p; p++)
                for (var d = u[p], m = 0; 3 > m; m++) {
                    n[0] = d[a[m]], n[1] = d[a[(m + 1) % 3]], n.sort(o);
                    var g = n.toString();
                    void 0 === i[g] && (c[2 * l] = n[0], c[2 * l + 1] = n[1], i[g] = !0, l++)
                }
            for (var v = new Float32Array(2 * l * 3), p = 0, f = l; f > p; p++)
                for (var m = 0; 2 > m; m++) {
                    var E = h[c[2 * p + m]],
                        y = 6 * p + 3 * m;
                    v[y + 0] = E.x, v[y + 1] = E.y, v[y + 2] = E.z
                }
            s.addAttribute("position", new THREE.BufferAttribute(v, 3))
        } else if (t.geometry instanceof THREE.BufferGeometry)
            if (void 0 !== t.geometry.attributes.index) {
                for (var h = t.geometry.attributes.position.array, T = t.geometry.attributes.index.array, x = t.geometry.offsets, l = 0, c = new Uint32Array(2 * T.length), _ = 0, b = x.length; b > _; ++_)
                    for (var R = x[_].start, w = x[_].count, y = x[_].index, p = R, H = R + w; H > p; p += 3)
                        for (var m = 0; 3 > m; m++) {
                            n[0] = y + T[p + m], n[1] = y + T[p + (m + 1) % 3], n.sort(o);
                            var g = n.toString();
                            void 0 === i[g] && (c[2 * l] = n[0], c[2 * l + 1] = n[1], i[g] = !0, l++)
                        }
                for (var v = new Float32Array(2 * l * 3), p = 0, f = l; f > p; p++)
                    for (var m = 0; 2 > m; m++) {
                        var y = 6 * p + 3 * m,
                            M = 3 * c[2 * p + m];
                        v[y + 0] = h[M], v[y + 1] = h[M + 1], v[y + 2] = h[M + 2]
                    }
                s.addAttribute("position", new THREE.BufferAttribute(v, 3))
            } else {
                for (var h = t.geometry.attributes.position.array, l = h.length / 3, S = l / 3, v = new Float32Array(2 * l * 3), p = 0, f = S; f > p; p++)
                    for (var m = 0; 3 > m; m++) {
                        var y = 18 * p + 6 * m,
                            A = 9 * p + 3 * m;
                        v[y + 0] = h[A], v[y + 1] = h[A + 1], v[y + 2] = h[A + 2];
                        var M = 9 * p + 3 * ((m + 1) % 3);
                        v[y + 3] = h[M], v[y + 4] = h[M + 1], v[y + 5] = h[M + 2]
                    }
                s.addAttribute("position", new THREE.BufferAttribute(v, 3))
            }
        THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: r
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = t.matrixWorld
    }, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.ImmediateRenderObject = function() {
        THREE.Object3D.call(this), this.render = function() {}
    }, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare = function(t, e, r, n, i) {
        THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, r, n, i)
    }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.add = function(t, e, r, n, i, o) {
        void 0 === e && (e = -1), void 0 === r && (r = 0), void 0 === o && (o = 1), void 0 === i && (i = new THREE.Color(16777215)), void 0 === n && (n = THREE.NormalBlending), r = Math.min(r, Math.max(0, r)), this.lensFlares.push({
            texture: t,
            size: e,
            distance: r,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 1,
            opacity: o,
            color: i,
            blending: n
        })
    }, THREE.LensFlare.prototype.updateLensFlares = function() {
        var t, e, r = this.lensFlares.length,
            n = 2 * -this.positionScreen.x,
            i = 2 * -this.positionScreen.y;
        for (t = 0; r > t; t++) e = this.lensFlares[t], e.x = this.positionScreen.x + n * e.distance, e.y = this.positionScreen.y + i * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
    }, THREE.MorphBlendMesh = function(t, e) {
        THREE.Mesh.call(this, t, e), this.animationsMap = {}, this.animationsList = [];
        var r = this.geometry.morphTargets.length,
            n = "__default",
            i = 0,
            o = r - 1,
            a = r / 1;
        this.createAnimation(n, i, o, a), this.setAnimationWeight(n, 1)
    }, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.createAnimation = function(t, e, r, n) {
        var i = {
            startFrame: e,
            endFrame: r,
            length: r - e + 1,
            fps: n,
            duration: (r - e) / n,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        };
        this.animationsMap[t] = i, this.animationsList.push(i)
    }, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(t) {
        for (var e, r = /([a-z]+)_?(\d+)/, n = {}, i = this.geometry, o = 0, a = i.morphTargets.length; a > o; o++) {
            var s = i.morphTargets[o],
                h = s.name.match(r);
            if (h && h.length > 1) {
                {
                    var u = h[1];
                    h[2]
                }
                n[u] || (n[u] = {
                    start: 1 / 0,
                    end: -1 / 0
                });
                var l = n[u];
                o < l.start && (l.start = o), o > l.end && (l.end = o), e || (e = u)
            }
        }
        for (var u in n) {
            var l = n[u];
            this.createAnimation(u, l.start, l.end, t)
        }
        this.firstAnimation = e
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(t) {
        var e = this.animationsMap[t];
        e && (e.direction = 1, e.directionBackwards = !1)
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(t) {
        var e = this.animationsMap[t];
        e && (e.direction = -1, e.directionBackwards = !0)
    }, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(t, e) {
        var r = this.animationsMap[t];
        r && (r.fps = e, r.duration = (r.end - r.start) / r.fps)
    }, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(t, e) {
        var r = this.animationsMap[t];
        r && (r.duration = e, r.fps = (r.end - r.start) / r.duration)
    }, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(t, e) {
        var r = this.animationsMap[t];
        r && (r.weight = e)
    }, THREE.MorphBlendMesh.prototype.setAnimationTime = function(t, e) {
        var r = this.animationsMap[t];
        r && (r.time = e)
    }, THREE.MorphBlendMesh.prototype.getAnimationTime = function(t) {
        var e = 0,
            r = this.animationsMap[t];
        return r && (e = r.time), e
    }, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(t) {
        var e = -1,
            r = this.animationsMap[t];
        return r && (e = r.duration), e
    }, THREE.MorphBlendMesh.prototype.playAnimation = function(t) {
        var e = this.animationsMap[t];
        e ? (e.time = 0, e.active = !0) : console.warn("animation[" + t + "] undefined")
    }, THREE.MorphBlendMesh.prototype.stopAnimation = function(t) {
        var e = this.animationsMap[t];
        e && (e.active = !1)
    }, THREE.MorphBlendMesh.prototype.update = function(t) {
        for (var e = 0, r = this.animationsList.length; r > e; e++) {
            var n = this.animationsList[e];
            if (n.active) {
                var i = n.duration / n.length;
                n.time += n.direction * t, n.mirroredLoop ? (n.time > n.duration || n.time < 0) && (n.direction *= -1, n.time > n.duration && (n.time = n.duration, n.directionBackwards = !0), n.time < 0 && (n.time = 0, n.directionBackwards = !1)) : (n.time = n.time % n.duration, n.time < 0 && (n.time += n.duration));
                var o = n.startFrame + THREE.Math.clamp(Math.floor(n.time / i), 0, n.length - 1),
                    a = n.weight;
                o !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0, this.morphTargetInfluences[n.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, n.lastFrame = n.currentFrame, n.currentFrame = o);
                var s = n.time % i / i;
                n.directionBackwards && (s = 1 - s), this.morphTargetInfluences[n.currentFrame] = s * a, this.morphTargetInfluences[n.lastFrame] = (1 - s) * a
            }
        }
    }, THREE.LensFlarePlugin = function() {
        function t(t, r) {
            var n = e.createProgram(),
                i = e.createShader(e.FRAGMENT_SHADER),
                o = e.createShader(e.VERTEX_SHADER),
                a = "precision " + r + " float;\n";
            return e.shaderSource(i, a + t.fragmentShader), e.shaderSource(o, a + t.vertexShader), e.compileShader(i), e.compileShader(o), e.attachShader(n, i), e.attachShader(n, o), e.linkProgram(n), n
        }
        var e, r, n, i = [],
            o = {};
        this.init = function(i) {
            e = i.context, r = i, n = i.getPrecision(), o.vertices = new Float32Array(16), o.faces = new Uint16Array(6);
            var a = 0;
            o.vertices[a++] = -1, o.vertices[a++] = -1, o.vertices[a++] = 0, o.vertices[a++] = 0, o.vertices[a++] = 1, o.vertices[a++] = -1, o.vertices[a++] = 1, o.vertices[a++] = 0, o.vertices[a++] = 1, o.vertices[a++] = 1, o.vertices[a++] = 1, o.vertices[a++] = 1, o.vertices[a++] = -1, o.vertices[a++] = 1, o.vertices[a++] = 0, o.vertices[a++] = 1, a = 0, o.faces[a++] = 0, o.faces[a++] = 1, o.faces[a++] = 2, o.faces[a++] = 0, o.faces[a++] = 2, o.faces[a++] = 3, o.vertexBuffer = e.createBuffer(), o.elementBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, o.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, o.vertices, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o.elementBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, o.faces, e.STATIC_DRAW), o.tempTexture = e.createTexture(), o.occlusionTexture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, o.tempTexture), e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.bindTexture(e.TEXTURE_2D, o.occlusionTexture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0 ? (o.hasVertexTexture = !1, o.program = t(THREE.ShaderFlares.lensFlare, n)) : (o.hasVertexTexture = !0, o.program = t(THREE.ShaderFlares.lensFlareVertexTexture, n)), o.attributes = {}, o.uniforms = {}, o.attributes.vertex = e.getAttribLocation(o.program, "position"), o.attributes.uv = e.getAttribLocation(o.program, "uv"), o.uniforms.renderType = e.getUniformLocation(o.program, "renderType"), o.uniforms.map = e.getUniformLocation(o.program, "map"), o.uniforms.occlusionMap = e.getUniformLocation(o.program, "occlusionMap"), o.uniforms.opacity = e.getUniformLocation(o.program, "opacity"), o.uniforms.color = e.getUniformLocation(o.program, "color"), o.uniforms.scale = e.getUniformLocation(o.program, "scale"), o.uniforms.rotation = e.getUniformLocation(o.program, "rotation"), o.uniforms.screenPosition = e.getUniformLocation(o.program, "screenPosition")
        }, this.render = function(t, n, a, s) {
            if (i.length = 0, t.traverseVisible(function(t) {
                    t instanceof THREE.LensFlare && i.push(t)
                }), 0 !== i.length) {
                var h = new THREE.Vector3,
                    u = s / a,
                    l = .5 * a,
                    c = .5 * s,
                    p = 16 / s,
                    f = new THREE.Vector2(p * u, p),
                    d = new THREE.Vector3(1, 1, 0),
                    m = new THREE.Vector2(1, 1),
                    g = o.uniforms,
                    v = o.attributes;
                e.useProgram(o.program), e.enableVertexAttribArray(o.attributes.vertex), e.enableVertexAttribArray(o.attributes.uv), e.uniform1i(g.occlusionMap, 0), e.uniform1i(g.map, 1), e.bindBuffer(e.ARRAY_BUFFER, o.vertexBuffer), e.vertexAttribPointer(v.vertex, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(v.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o.elementBuffer), e.disable(e.CULL_FACE), e.depthMask(!1);
                for (var E = 0, y = i.length; y > E; E++) {
                    p = 16 / s, f.set(p * u, p);
                    var T = i[E];
                    if (h.set(T.matrixWorld.elements[12], T.matrixWorld.elements[13], T.matrixWorld.elements[14]), h.applyMatrix4(n.matrixWorldInverse), h.applyProjection(n.projectionMatrix), d.copy(h), m.x = d.x * l + l, m.y = d.y * c + c, o.hasVertexTexture || m.x > 0 && m.x < a && m.y > 0 && m.y < s) {
                        e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, o.tempTexture), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, m.x - 8, m.y - 8, 16, 16, 0), e.uniform1i(g.renderType, 0), e.uniform2f(g.scale, f.x, f.y), e.uniform3f(g.screenPosition, d.x, d.y, d.z), e.disable(e.BLEND), e.enable(e.DEPTH_TEST), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, o.occlusionTexture), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, m.x - 8, m.y - 8, 16, 16, 0), e.uniform1i(g.renderType, 1), e.disable(e.DEPTH_TEST), e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, o.tempTexture), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), T.positionScreen.copy(d), T.customUpdateCallback ? T.customUpdateCallback(T) : T.updateLensFlares(), e.uniform1i(g.renderType, 2), e.enable(e.BLEND);
                        for (var x = 0, _ = T.lensFlares.length; _ > x; x++) {
                            var b = T.lensFlares[x];
                            b.opacity > .001 && b.scale > .001 && (d.x = b.x, d.y = b.y, d.z = b.z, p = b.size * b.scale / s, f.x = p * u, f.y = p, e.uniform3f(g.screenPosition, d.x, d.y, d.z), e.uniform2f(g.scale, f.x, f.y), e.uniform1f(g.rotation, b.rotation), e.uniform1f(g.opacity, b.opacity), e.uniform3f(g.color, b.color.r, b.color.g, b.color.b), r.setBlending(b.blending, b.blendEquation, b.blendSrc, b.blendDst), r.setTexture(b.texture, 1), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0))
                        }
                    }
                }
                e.enable(e.CULL_FACE), e.enable(e.DEPTH_TEST), e.depthMask(!0)
            }
        }
    }, THREE.ShadowMapPlugin = function() {
        function t(e, r, n) {
            if (r.visible) {
                var i = e.__webglObjects[r.id];
                if (i && r.castShadow && (r.frustumCulled === !1 || c.intersectsObject(r) === !0))
                    for (var o = 0, a = i.length; a > o; o++) {
                        var s = i[o];
                        r._modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, r.matrixWorld), g.push(s)
                    }
                for (var o = 0, a = r.children.length; a > o; o++) t(e, r.children[o], n)
            }
        }

        function e(t, e) {
            var r = new THREE.DirectionalLight;
            r.isVirtual = !0, r.onlyShadow = !0, r.castShadow = !0, r.shadowCameraNear = t.shadowCameraNear, r.shadowCameraFar = t.shadowCameraFar, r.shadowCameraLeft = t.shadowCameraLeft, r.shadowCameraRight = t.shadowCameraRight, r.shadowCameraBottom = t.shadowCameraBottom, r.shadowCameraTop = t.shadowCameraTop, r.shadowCameraVisible = t.shadowCameraVisible, r.shadowDarkness = t.shadowDarkness, r.shadowBias = t.shadowCascadeBias[e], r.shadowMapWidth = t.shadowCascadeWidth[e], r.shadowMapHeight = t.shadowCascadeHeight[e], r.pointsWorld = [], r.pointsFrustum = [];
            for (var n = r.pointsWorld, i = r.pointsFrustum, o = 0; 8 > o; o++) n[o] = new THREE.Vector3, i[o] = new THREE.Vector3;
            var a = t.shadowCascadeNearZ[e],
                s = t.shadowCascadeFarZ[e];
            return i[0].set(-1, -1, a), i[1].set(1, -1, a), i[2].set(-1, 1, a), i[3].set(1, 1, a), i[4].set(-1, -1, s), i[5].set(1, -1, s), i[6].set(-1, 1, s), i[7].set(1, 1, s), r
        }

        function r(t, e) {
            var r = t.shadowCascadeArray[e];
            r.position.copy(t.position), r.target.position.copy(t.target.position), r.lookAt(r.target), r.shadowCameraVisible = t.shadowCameraVisible, r.shadowDarkness = t.shadowDarkness, r.shadowBias = t.shadowCascadeBias[e];
            var n = t.shadowCascadeNearZ[e],
                i = t.shadowCascadeFarZ[e],
                o = r.pointsFrustum;
            o[0].z = n, o[1].z = n, o[2].z = n, o[3].z = n, o[4].z = i, o[5].z = i, o[6].z = i, o[7].z = i
        }

        function n(t, e) {
            var r = e.shadowCamera,
                n = e.pointsFrustum,
                i = e.pointsWorld;
            f.set(1 / 0, 1 / 0, 1 / 0), d.set(-1 / 0, -1 / 0, -1 / 0);
            for (var o = 0; 8 > o; o++) {
                var a = i[o];
                a.copy(n[o]), THREE.ShadowMapPlugin.__projector.unprojectVector(a, t), a.applyMatrix4(r.matrixWorldInverse), a.x < f.x && (f.x = a.x), a.x > d.x && (d.x = a.x), a.y < f.y && (f.y = a.y), a.y > d.y && (d.y = a.y), a.z < f.z && (f.z = a.z), a.z > d.z && (d.z = a.z)
            }
            r.left = f.x, r.right = d.x, r.top = d.y, r.bottom = f.y, r.updateProjectionMatrix()
        }

        function i(t) {
            return t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material
        }
        var o, a, s, h, u, l, c = new THREE.Frustum,
            p = new THREE.Matrix4,
            f = new THREE.Vector3,
            d = new THREE.Vector3,
            m = new THREE.Vector3,
            g = [];
        this.init = function(t) {
            o = t.context, a = t;
            var e = THREE.ShaderLib.depthRGBA,
                r = THREE.UniformsUtils.clone(e.uniforms);
            s = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: r
            }), h = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: r,
                morphTargets: !0
            }), u = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: r,
                skinning: !0
            }), l = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: r,
                morphTargets: !0,
                skinning: !0
            }), s._shadowPass = !0, h._shadowPass = !0, u._shadowPass = !0, l._shadowPass = !0
        }, this.render = function(t, e) {
            a.shadowMapEnabled && a.shadowMapAutoUpdate && this.update(t, e)
        }, this.update = function(f, d) {
            var v, E, y, T, x, _, b, R, w, H, M, S, A, C = [],
                k = 0,
                L = null;
            for (o.clearColor(1, 1, 1, 1), o.disable(o.BLEND), o.enable(o.CULL_FACE), o.frontFace(o.CCW), o.cullFace(a.shadowMapCullFace === THREE.CullFaceFront ? o.FRONT : o.BACK), a.setDepthTest(!0), v = 0, E = f.__lights.length; E > v; v++)
                if (A = f.__lights[v], A.castShadow)
                    if (A instanceof THREE.DirectionalLight && A.shadowCascade)
                        for (x = 0; x < A.shadowCascadeCount; x++) {
                            var z;
                            if (A.shadowCascadeArray[x]) z = A.shadowCascadeArray[x];
                            else {
                                z = e(A, x), z.originalCamera = d;
                                var P = new THREE.Gyroscope;
                                P.position.copy(A.shadowCascadeOffset), P.add(z), P.add(z.target), d.add(P), A.shadowCascadeArray[x] = z, console.log("Created virtualLight", z)
                            }
                            r(A, x), C[k] = z, k++
                        } else C[k] = A, k++;
            for (v = 0, E = C.length; E > v; v++) {
                if (A = C[v], !A.shadowMap) {
                    var D = THREE.LinearFilter;
                    a.shadowMapType === THREE.PCFSoftShadowMap && (D = THREE.NearestFilter);
                    var F = {
                        minFilter: D,
                        magFilter: D,
                        format: THREE.RGBAFormat
                    };
                    A.shadowMap = new THREE.WebGLRenderTarget(A.shadowMapWidth, A.shadowMapHeight, F), A.shadowMapSize = new THREE.Vector2(A.shadowMapWidth, A.shadowMapHeight), A.shadowMatrix = new THREE.Matrix4
                }
                if (!A.shadowCamera) {
                    if (A instanceof THREE.SpotLight) A.shadowCamera = new THREE.PerspectiveCamera(A.shadowCameraFov, A.shadowMapWidth / A.shadowMapHeight, A.shadowCameraNear, A.shadowCameraFar);
                    else {
                        if (!(A instanceof THREE.DirectionalLight)) {
                            console.error("Unsupported light type for shadow");
                            continue
                        }
                        A.shadowCamera = new THREE.OrthographicCamera(A.shadowCameraLeft, A.shadowCameraRight, A.shadowCameraTop, A.shadowCameraBottom, A.shadowCameraNear, A.shadowCameraFar)
                    }
                    f.add(A.shadowCamera), f.autoUpdate === !0 && f.updateMatrixWorld()
                }
                A.shadowCameraVisible && !A.cameraHelper && (A.cameraHelper = new THREE.CameraHelper(A.shadowCamera), A.shadowCamera.add(A.cameraHelper)), A.isVirtual && z.originalCamera == d && n(d, A), _ = A.shadowMap, b = A.shadowMatrix, R = A.shadowCamera, R.position.setFromMatrixPosition(A.matrixWorld), m.setFromMatrixPosition(A.target.matrixWorld), R.lookAt(m), R.updateMatrixWorld(), R.matrixWorldInverse.getInverse(R.matrixWorld), A.cameraHelper && (A.cameraHelper.visible = A.shadowCameraVisible), A.shadowCameraVisible && A.cameraHelper.update(), b.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), b.multiply(R.projectionMatrix), b.multiply(R.matrixWorldInverse), p.multiplyMatrices(R.projectionMatrix, R.matrixWorldInverse), c.setFromMatrix(p), a.setRenderTarget(_), a.clear(), g.length = 0, t(f, f, R);
                var U, O, B;
                for (y = 0, T = g.length; T > y; y++) M = g[y], S = M.object, w = M.buffer, U = i(S), O = void 0 !== S.geometry.morphTargets && S.geometry.morphTargets.length > 0 && U.morphTargets, B = S instanceof THREE.SkinnedMesh && U.skinning, H = S.customDepthMaterial ? S.customDepthMaterial : B ? O ? l : u : O ? h : s, a.setMaterialFaces(U), w instanceof THREE.BufferGeometry ? a.renderBufferDirect(R, f.__lights, L, H, w, S) : a.renderBuffer(R, f.__lights, L, H, w, S);
                var V = f.__webglObjectsImmediate;
                for (y = 0, T = V.length; T > y; y++) M = V[y], S = M.object, S.visible && S.castShadow && (S._modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, S.matrixWorld), a.renderImmediateObject(R, f.__lights, L, s, S))
            }
            var N = a.getClearColor(),
                j = a.getClearAlpha();
            o.clearColor(N.r, N.g, N.b, j), o.enable(o.BLEND), a.shadowMapCullFace === THREE.CullFaceFront && o.cullFace(o.BACK)
        }
    }, THREE.ShadowMapPlugin.__projector = new THREE.Projector, THREE.SpritePlugin = function() {
        function t() {
            var t = r.createProgram(),
                e = r.createShader(r.VERTEX_SHADER),
                i = r.createShader(r.FRAGMENT_SHADER);
            return r.shaderSource(e, ["precision " + n.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), r.shaderSource(i, ["precision " + n.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), r.compileShader(e), r.compileShader(i), r.attachShader(t, e), r.attachShader(t, i), r.linkProgram(t), t
        }

        function e(t, e) {
            return t.z !== e.z ? e.z - t.z : e.id - t.id
        }
        var r, n, i, o, a, s, h, u, l, c, p = [];
        this.init = function(e) {
            r = e.context, n = e, o = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), a = new Uint16Array([0, 1, 2, 0, 2, 3]), s = r.createBuffer(), h = r.createBuffer(), r.bindBuffer(r.ARRAY_BUFFER, s), r.bufferData(r.ARRAY_BUFFER, o, r.STATIC_DRAW), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, h), r.bufferData(r.ELEMENT_ARRAY_BUFFER, a, r.STATIC_DRAW), u = t(), l = {
                position: r.getAttribLocation(u, "position"),
                uv: r.getAttribLocation(u, "uv")
            }, c = {
                uvOffset: r.getUniformLocation(u, "uvOffset"),
                uvScale: r.getUniformLocation(u, "uvScale"),
                rotation: r.getUniformLocation(u, "rotation"),
                scale: r.getUniformLocation(u, "scale"),
                color: r.getUniformLocation(u, "color"),
                map: r.getUniformLocation(u, "map"),
                opacity: r.getUniformLocation(u, "opacity"),
                modelViewMatrix: r.getUniformLocation(u, "modelViewMatrix"),
                projectionMatrix: r.getUniformLocation(u, "projectionMatrix"),
                fogType: r.getUniformLocation(u, "fogType"),
                fogDensity: r.getUniformLocation(u, "fogDensity"),
                fogNear: r.getUniformLocation(u, "fogNear"),
                fogFar: r.getUniformLocation(u, "fogFar"),
                fogColor: r.getUniformLocation(u, "fogColor"),
                alphaTest: r.getUniformLocation(u, "alphaTest")
            };
            var p = document.createElement("canvas");
            p.width = 8, p.height = 8;
            var f = p.getContext("2d");
            f.fillStyle = "white", f.fillRect(0, 0, 8, 8), i = new THREE.Texture(p), i.needsUpdate = !0
        }, this.render = function(t, o) {
            if (p.length = 0, t.traverseVisible(function(t) {
                    t instanceof THREE.Sprite && p.push(t)
                }), 0 !== p.length) {
                r.useProgram(u), r.enableVertexAttribArray(l.position), r.enableVertexAttribArray(l.uv), r.disable(r.CULL_FACE), r.enable(r.BLEND), r.bindBuffer(r.ARRAY_BUFFER, s), r.vertexAttribPointer(l.position, 2, r.FLOAT, !1, 16, 0), r.vertexAttribPointer(l.uv, 2, r.FLOAT, !1, 16, 8), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, h), r.uniformMatrix4fv(c.projectionMatrix, !1, o.projectionMatrix.elements), r.activeTexture(r.TEXTURE0), r.uniform1i(c.map, 0);
                var a = 0,
                    f = 0,
                    d = t.fog;
                d ? (r.uniform3f(c.fogColor, d.color.r, d.color.g, d.color.b), d instanceof THREE.Fog ? (r.uniform1f(c.fogNear, d.near), r.uniform1f(c.fogFar, d.far), r.uniform1i(c.fogType, 1), a = 1, f = 1) : d instanceof THREE.FogExp2 && (r.uniform1f(c.fogDensity, d.density), r.uniform1i(c.fogType, 2), a = 2, f = 2)) : (r.uniform1i(c.fogType, 0), a = 0, f = 0);
                for (var m = 0, g = p.length; g > m; m++) {
                    var v = p[m],
                        E = v.material;
                    v._modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, v.matrixWorld), v.z = -v._modelViewMatrix.elements[14]
                }
                p.sort(e);
                for (var y = [], m = 0, g = p.length; g > m; m++) {
                    var v = p[m],
                        E = v.material;
                    r.uniform1f(c.alphaTest, E.alphaTest), r.uniformMatrix4fv(c.modelViewMatrix, !1, v._modelViewMatrix.elements), y[0] = v.scale.x, y[1] = v.scale.y;
                    var T = 0;
                    t.fog && E.fog && (T = f), a !== T && (r.uniform1i(c.fogType, T), a = T), null !== E.map ? (r.uniform2f(c.uvOffset, E.map.offset.x, E.map.offset.y), r.uniform2f(c.uvScale, E.map.repeat.x, E.map.repeat.y)) : (r.uniform2f(c.uvOffset, 0, 0), r.uniform2f(c.uvScale, 1, 1)), r.uniform1f(c.opacity, E.opacity), r.uniform3f(c.color, E.color.r, E.color.g, E.color.b), r.uniform1f(c.rotation, E.rotation), r.uniform2fv(c.scale, y), n.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), n.setDepthTest(E.depthTest), n.setDepthWrite(E.depthWrite), E.map && E.map.image && E.map.image.width ? n.setTexture(E.map, 0) : n.setTexture(i, 0), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0)
                }
                r.enable(r.CULL_FACE)
            }
        }
    }, THREE.DepthPassPlugin = function() {
        function t(e, r, n) {
            if (r.visible) {
                var i = e.__webglObjects[r.id];
                if (i && (r.frustumCulled === !1 || h.intersectsObject(r) === !0))
                    for (var o = 0, a = i.length; a > o; o++) {
                        var s = i[o];
                        r._modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, r.matrixWorld), l.push(s)
                    }
                for (var o = 0, a = r.children.length; a > o; o++) t(e, r.children[o], n)
            }
        }

        function e(t) {
            return t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material
        }
        this.enabled = !1, this.renderTarget = null;
        var r, n, i, o, a, s, h = new THREE.Frustum,
            u = new THREE.Matrix4,
            l = [];
        this.init = function(t) {
            r = t.context, n = t;
            var e = THREE.ShaderLib.depthRGBA,
                h = THREE.UniformsUtils.clone(e.uniforms);
            i = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: h
            }), o = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: h,
                morphTargets: !0
            }), a = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: h,
                skinning: !0
            }), s = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: h,
                morphTargets: !0,
                skinning: !0
            }), i._shadowPass = !0, o._shadowPass = !0, a._shadowPass = !0, s._shadowPass = !0
        }, this.render = function(t, e) {
            this.enabled && this.update(t, e)
        }, this.update = function(c, p) {
            var f, d, m, g, v, E, y, T = null;
            r.clearColor(1, 1, 1, 1), r.disable(r.BLEND), n.setDepthTest(!0), c.autoUpdate === !0 && c.updateMatrixWorld(), p.matrixWorldInverse.getInverse(p.matrixWorld), u.multiplyMatrices(p.projectionMatrix, p.matrixWorldInverse), h.setFromMatrix(u), n.setRenderTarget(this.renderTarget), n.clear(), l.length = 0, t(c, c, p);
            var x, _, b;
            for (f = 0, d = l.length; d > f; f++) v = l[f], E = v.object, m = v.buffer, E instanceof THREE.PointCloud && !E.customDepthMaterial || (x = e(E), x && n.setMaterialFaces(E.material), _ = void 0 !== E.geometry.morphTargets && E.geometry.morphTargets.length > 0 && x.morphTargets, b = E instanceof THREE.SkinnedMesh && x.skinning, g = E.customDepthMaterial ? E.customDepthMaterial : b ? _ ? s : a : _ ? o : i, m instanceof THREE.BufferGeometry ? n.renderBufferDirect(p, c.__lights, T, g, m, E) : n.renderBuffer(p, c.__lights, T, g, m, E));
            for (y = c.__webglObjectsImmediate, f = 0, d = y.length; d > f; f++) v = y[f], E = v.object, E.visible && (E._modelViewMatrix.multiplyMatrices(p.matrixWorldInverse, E.matrixWorld), n.renderImmediateObject(p, c.__lights, T, i, E));
            var R = n.getClearColor(),
                w = n.getClearAlpha();
            r.clearColor(R.r, R.g, R.b, w), r.enable(r.BLEND)
        }
    }, THREE.ShaderFlares = {
        lensFlareVertexTexture: {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        },
        lensFlare: {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        }
    },
    function() {
        function t(t, e, r) {
            for (var n = (r || 0) - 1, i = t ? t.length : 0; ++n < i;)
                if (t[n] === e) return n;
            return -1
        }

        function e(e, r) {
            var n = typeof r;
            if (e = e.cache, "boolean" == n || null == r) return e[r] ? 0 : -1;
            "number" != n && "string" != n && (n = "object");
            var i = "number" == n ? r : v + r;
            return e = (e = e[n]) && e[i], "object" == n ? e && t(e, r) > -1 ? 0 : -1 : e ? 0 : -1
        }

        function r(t) {
            var e = this.cache,
                r = typeof t;
            if ("boolean" == r || null == t) e[t] = !0;
            else {
                "number" != r && "string" != r && (r = "object");
                var n = "number" == r ? t : v + t,
                    i = e[r] || (e[r] = {});
                "object" == r ? (i[n] || (i[n] = [])).push(t) : i[n] = !0
            }
        }

        function n(t) {
            return t.charCodeAt(0)
        }

        function i(t, e) {
            for (var r = t.criteria, n = e.criteria, i = -1, o = r.length; ++i < o;) {
                var a = r[i],
                    s = n[i];
                if (a !== s) {
                    if (a > s || "undefined" == typeof a) return 1;
                    if (s > a || "undefined" == typeof s) return -1
                }
            }
            return t.index - e.index
        }

        function o(t) {
            var e = -1,
                n = t.length,
                i = t[0],
                o = t[n / 2 | 0],
                a = t[n - 1];
            if (i && "object" == typeof i && o && "object" == typeof o && a && "object" == typeof a) return !1;
            var s = h();
            s["false"] = s["null"] = s["true"] = s.undefined = !1;
            var u = h();
            for (u.array = t, u.cache = s, u.push = r; ++e < n;) u.push(t[e]);
            return u
        }

        function a(t) {
            return "\\" + q[t]
        }

        function s() {
            return d.pop() || []
        }

        function h() {
            return m.pop() || {
                array: null,
                cache: null,
                criteria: null,
                "false": !1,
                index: 0,
                "null": !1,
                number: null,
                object: null,
                push: null,
                string: null,
                "true": !1,
                undefined: !1,
                value: null
            }
        }

        function u(t) {
            t.length = 0, d.length < y && d.push(t)
        }

        function l(t) {
            var e = t.cache;
            e && l(e), t.array = t.cache = t.criteria = t.object = t.number = t.string = t.value = null, m.length < y && m.push(t)
        }

        function c(t, e, r) {
            e || (e = 0), "undefined" == typeof r && (r = t ? t.length : 0);
            for (var n = -1, i = r - e || 0, o = Array(0 > i ? 0 : i); ++n < i;) o[n] = t[e + n];
            return o
        }

        function p(r) {
            function d(t) {
                return t && "object" == typeof t && !Jn(t) && Pn.call(t, "__wrapped__") ? t : new m(t)
            }

            function m(t, e) {
                this.__chain__ = !!e, this.__wrapped__ = t
            }

            function y(t) {
                function e() {
                    if (n) {
                        var t = c(n);
                        Dn.apply(t, arguments)
                    }
                    if (this instanceof e) {
                        var o = K(r.prototype),
                            a = r.apply(o, t || arguments);
                        return Ce(a) ? a : o
                    }
                    return r.apply(i, t || arguments)
                }
                var r = t[0],
                    n = t[2],
                    i = t[4];
                return Qn(e, t), e
            }

            function q(t, e, r, n, i) {
                if (r) {
                    var o = r(t);
                    if ("undefined" != typeof o) return o
                }
                var a = Ce(t);
                if (!a) return t;
                var h = Mn.call(t);
                if (!I[h]) return t;
                var l = Kn[h];
                switch (h) {
                    case F:
                    case U:
                        return new l(+t);
                    case B:
                    case j:
                        return new l(t);
                    case N:
                        return o = l(t.source, w.exec(t)), o.lastIndex = t.lastIndex, o
                }
                var p = Jn(t);
                if (e) {
                    var f = !n;
                    n || (n = s()), i || (i = s());
                    for (var d = n.length; d--;)
                        if (n[d] == t) return i[d];
                    o = p ? l(t.length) : {}
                } else o = p ? c(t) : oi({}, t);
                return p && (Pn.call(t, "index") && (o.index = t.index), Pn.call(t, "input") && (o.input = t.input)), e ? (n.push(t), i.push(o), (p ? Ze : hi)(t, function(t, a) {
                    o[a] = q(t, e, r, n, i)
                }), f && (u(n), u(i)), o) : o
            }

            function K(t) {
                return Ce(t) ? Vn(t) : {}
            }

            function Z(t, e, r) {
                if ("function" != typeof t) return Qr;
                if ("undefined" == typeof e || !("prototype" in t)) return t;
                var n = t.__bindData__;
                if ("undefined" == typeof n && (Zn.funcNames && (n = !t.name), n = n || !Zn.funcDecomp, !n)) {
                    var i = Ln.call(t);
                    Zn.funcNames || (n = !H.test(i)), n || (n = C.test(i), Qn(t, n))
                }
                if (n === !1 || n !== !0 && 1 & n[1]) return t;
                switch (r) {
                    case 1:
                        return function(r) {
                            return t.call(e, r)
                        };
                    case 2:
                        return function(r, n) {
                            return t.call(e, r, n)
                        };
                    case 3:
                        return function(r, n, i) {
                            return t.call(e, r, n, i)
                        };
                    case 4:
                        return function(r, n, i, o) {
                            return t.call(e, r, n, i, o)
                        }
                }
                return Pr(t, e)
            }

            function Q(t) {
                function e() {
                    var t = h ? a : this;
                    if (i) {
                        var d = c(i);
                        Dn.apply(d, arguments)
                    }
                    if ((o || l) && (d || (d = c(arguments)), o && Dn.apply(d, o), l && d.length < s)) return n |= 16, Q([r, p ? n : -4 & n, d, null, a, s]);
                    if (d || (d = arguments), u && (r = t[f]), this instanceof e) {
                        t = K(r.prototype);
                        var m = r.apply(t, d);
                        return Ce(m) ? m : t
                    }
                    return r.apply(t, d)
                }
                var r = t[0],
                    n = t[1],
                    i = t[2],
                    o = t[3],
                    a = t[4],
                    s = t[5],
                    h = 1 & n,
                    u = 2 & n,
                    l = 4 & n,
                    p = 8 & n,
                    f = r;
                return Qn(e, t), e
            }

            function J(r, n) {
                var i = -1,
                    a = he(),
                    s = r ? r.length : 0,
                    h = s >= E && a === t,
                    u = [];
                if (h) {
                    var c = o(n);
                    c ? (a = e, n = c) : h = !1
                }
                for (; ++i < s;) {
                    var p = r[i];
                    a(n, p) < 0 && u.push(p)
                }
                return h && l(n), u
            }

            function te(t, e, r, n) {
                for (var i = (n || 0) - 1, o = t ? t.length : 0, a = []; ++i < o;) {
                    var s = t[i];
                    if (s && "object" == typeof s && "number" == typeof s.length && (Jn(s) || pe(s))) {
                        e || (s = te(s, e, r));
                        var h = -1,
                            u = s.length,
                            l = a.length;
                        for (a.length += u; ++h < u;) a[l++] = s[h]
                    } else r || a.push(s)
                }
                return a
            }

            function ee(t, e, r, n, i, o) {
                if (r) {
                    var a = r(t, e);
                    if ("undefined" != typeof a) return !!a
                }
                if (t === e) return 0 !== t || 1 / t == 1 / e;
                var h = typeof t,
                    l = typeof e;
                if (!(t !== t || t && X[h] || e && X[l])) return !1;
                if (null == t || null == e) return t === e;
                var c = Mn.call(t),
                    p = Mn.call(e);
                if (c == P && (c = V), p == P && (p = V), c != p) return !1;
                switch (c) {
                    case F:
                    case U:
                        return +t == +e;
                    case B:
                        return t != +t ? e != +e : 0 == t ? 1 / t == 1 / e : t == +e;
                    case N:
                    case j:
                        return t == _n(e)
                }
                var f = c == D;
                if (!f) {
                    var d = Pn.call(t, "__wrapped__"),
                        m = Pn.call(e, "__wrapped__");
                    if (d || m) return ee(d ? t.__wrapped__ : t, m ? e.__wrapped__ : e, r, n, i, o);
                    if (c != V) return !1;
                    var g = t.constructor,
                        v = e.constructor;
                    if (g != v && !(Ae(g) && g instanceof g && Ae(v) && v instanceof v) && "constructor" in t && "constructor" in e) return !1
                }
                var E = !i;
                i || (i = s()), o || (o = s());
                for (var y = i.length; y--;)
                    if (i[y] == t) return o[y] == e;
                var T = 0;
                if (a = !0, i.push(t), o.push(e), f) {
                    if (y = t.length, T = e.length, a = T == y, a || n)
                        for (; T--;) {
                            var x = y,
                                _ = e[T];
                            if (n)
                                for (; x-- && !(a = ee(t[x], _, r, n, i, o)););
                            else if (!(a = ee(t[T], _, r, n, i, o))) break
                        }
                } else si(e, function(e, s, h) {
                    return Pn.call(h, s) ? (T++, a = Pn.call(t, s) && ee(t[s], e, r, n, i, o)) : void 0
                }), a && !n && si(t, function(t, e, r) {
                    return Pn.call(r, e) ? a = --T > -1 : void 0
                });
                return i.pop(), o.pop(), E && (u(i), u(o)), a
            }

            function re(t, e, r, n, i) {
                (Jn(e) ? Ze : hi)(e, function(e, o) {
                    var a, s, h = e,
                        u = t[o];
                    if (e && ((s = Jn(e)) || ui(e))) {
                        for (var l = n.length; l--;)
                            if (a = n[l] == e) {
                                u = i[l];
                                break
                            }
                        if (!a) {
                            var c;
                            r && (h = r(u, e), (c = "undefined" != typeof h) && (u = h)), c || (u = s ? Jn(u) ? u : [] : ui(u) ? u : {}), n.push(e), i.push(u), c || re(u, e, r, n, i)
                        }
                    } else r && (h = r(u, e), "undefined" == typeof h && (h = e)), "undefined" != typeof h && (u = h);
                    t[o] = u
                })
            }

            function ne(t, e) {
                return t + kn(Yn() * (e - t + 1))
            }

            function ie(r, n, i) {
                var a = -1,
                    h = he(),
                    c = r ? r.length : 0,
                    p = [],
                    f = !n && c >= E && h === t,
                    d = i || f ? s() : p;
                if (f) {
                    var m = o(d);
                    h = e, d = m
                }
                for (; ++a < c;) {
                    var g = r[a],
                        v = i ? i(g, a, r) : g;
                    (n ? !a || d[d.length - 1] !== v : h(d, v) < 0) && ((i || f) && d.push(v), p.push(g))
                }
                return f ? (u(d.array), l(d)) : i && u(d), p
            }

            function oe(t) {
                return function(e, r, n) {
                    var i = {};
                    r = d.createCallback(r, n, 3);
                    var o = -1,
                        a = e ? e.length : 0;
                    if ("number" == typeof a)
                        for (; ++o < a;) {
                            var s = e[o];
                            t(i, s, r(s, o, e), e)
                        } else hi(e, function(e, n, o) {
                            t(i, e, r(e, n, o), o)
                        });
                    return i
                }
            }

            function ae(t, e, r, n, i, o) {
                var a = 1 & e,
                    s = 2 & e,
                    h = 4 & e,
                    u = 16 & e,
                    l = 32 & e;
                if (!s && !Ae(t)) throw new bn;
                u && !r.length && (e &= -17, u = r = !1), l && !n.length && (e &= -33, l = n = !1);
                var p = t && t.__bindData__;
                if (p && p !== !0) return p = c(p), p[2] && (p[2] = c(p[2])), p[3] && (p[3] = c(p[3])), !a || 1 & p[1] || (p[4] = i), !a && 1 & p[1] && (e |= 8), !h || 4 & p[1] || (p[5] = o), u && Dn.apply(p[2] || (p[2] = []), r), l && On.apply(p[3] || (p[3] = []), n), p[1] |= e, ae.apply(null, p);
                var f = 1 == e || 17 === e ? y : Q;
                return f([t, e, r, n, i, o])
            }

            function se(t) {
                return ei[t]
            }

            function he() {
                var e = (e = d.indexOf) === vr ? t : e;
                return e
            }

            function ue(t) {
                return "function" == typeof t && Sn.test(t)
            }

            function le(t) {
                var e, r;
                return t && Mn.call(t) == V && (e = t.constructor, !Ae(e) || e instanceof e) ? (si(t, function(t, e) {
                    r = e
                }), "undefined" == typeof r || Pn.call(t, r)) : !1
            }

            function ce(t) {
                return ri[t]
            }

            function pe(t) {
                return t && "object" == typeof t && "number" == typeof t.length && Mn.call(t) == P || !1
            }

            function fe(t, e, r, n) {
                return "boolean" != typeof e && null != e && (n = r, r = e, e = !1), q(t, e, "function" == typeof r && Z(r, n, 1))
            }

            function de(t, e, r) {
                return q(t, !0, "function" == typeof e && Z(e, r, 1))
            }

            function me(t, e) {
                var r = K(t);
                return e ? oi(r, e) : r
            }

            function ge(t, e, r) {
                var n;
                return e = d.createCallback(e, r, 3), hi(t, function(t, r, i) {
                    return e(t, r, i) ? (n = r, !1) : void 0
                }), n
            }

            function ve(t, e, r) {
                var n;
                return e = d.createCallback(e, r, 3), ye(t, function(t, r, i) {
                    return e(t, r, i) ? (n = r, !1) : void 0
                }), n
            }

            function Ee(t, e, r) {
                var n = [];
                si(t, function(t, e) {
                    n.push(e, t)
                });
                var i = n.length;
                for (e = Z(e, r, 3); i-- && e(n[i--], n[i], t) !== !1;);
                return t
            }

            function ye(t, e, r) {
                var n = ti(t),
                    i = n.length;
                for (e = Z(e, r, 3); i--;) {
                    var o = n[i];
                    if (e(t[o], o, t) === !1) break
                }
                return t
            }

            function Te(t) {
                var e = [];
                return si(t, function(t, r) {
                    Ae(t) && e.push(r)
                }), e.sort()
            }

            function xe(t, e) {
                return t ? Pn.call(t, e) : !1
            }

            function _e(t) {
                for (var e = -1, r = ti(t), n = r.length, i = {}; ++e < n;) {
                    var o = r[e];
                    i[t[o]] = o
                }
                return i
            }

            function be(t) {
                return t === !0 || t === !1 || t && "object" == typeof t && Mn.call(t) == F || !1
            }

            function Re(t) {
                return t && "object" == typeof t && Mn.call(t) == U || !1
            }

            function we(t) {
                return t && 1 === t.nodeType || !1
            }

            function He(t) {
                var e = !0;
                if (!t) return e;
                var r = Mn.call(t),
                    n = t.length;
                return r == D || r == j || r == P || r == V && "number" == typeof n && Ae(t.splice) ? !n : (hi(t, function() {
                    return e = !1
                }), e)
            }

            function Me(t, e, r, n) {
                return ee(t, e, "function" == typeof r && Z(r, n, 2))
            }

            function Se(t) {
                return jn(t) && !In(parseFloat(t))
            }

            function Ae(t) {
                return "function" == typeof t
            }

            function Ce(t) {
                return !(!t || !X[typeof t])
            }

            function ke(t) {
                return ze(t) && t != +t
            }

            function Le(t) {
                return null === t
            }

            function ze(t) {
                return "number" == typeof t || t && "object" == typeof t && Mn.call(t) == B || !1
            }

            function Pe(t) {
                return t && "object" == typeof t && Mn.call(t) == N || !1
            }

            function De(t) {
                return "string" == typeof t || t && "object" == typeof t && Mn.call(t) == j || !1
            }

            function Fe(t) {
                return "undefined" == typeof t
            }

            function Ue(t, e, r) {
                var n = {};
                return e = d.createCallback(e, r, 3), hi(t, function(t, r, i) {
                    n[r] = e(t, r, i)
                }), n
            }

            function Oe(t) {
                var e = arguments,
                    r = 2;
                if (!Ce(t)) return t;
                if ("number" != typeof e[2] && (r = e.length), r > 3 && "function" == typeof e[r - 2]) var n = Z(e[--r - 1], e[r--], 2);
                else r > 2 && "function" == typeof e[r - 1] && (n = e[--r]);
                for (var i = c(arguments, 1, r), o = -1, a = s(), h = s(); ++o < r;) re(t, i[o], n, a, h);
                return u(a), u(h), t
            }

            function Be(t, e, r) {
                var n = {};
                if ("function" != typeof e) {
                    var i = [];
                    si(t, function(t, e) {
                        i.push(e)
                    }), i = J(i, te(arguments, !0, !1, 1));
                    for (var o = -1, a = i.length; ++o < a;) {
                        var s = i[o];
                        n[s] = t[s]
                    }
                } else e = d.createCallback(e, r, 3), si(t, function(t, r, i) {
                    e(t, r, i) || (n[r] = t)
                });
                return n
            }

            function Ve(t) {
                for (var e = -1, r = ti(t), n = r.length, i = dn(n); ++e < n;) {
                    var o = r[e];
                    i[e] = [o, t[o]]
                }
                return i
            }

            function Ne(t, e, r) {
                var n = {};
                if ("function" != typeof e)
                    for (var i = -1, o = te(arguments, !0, !1, 1), a = Ce(t) ? o.length : 0; ++i < a;) {
                        var s = o[i];
                        s in t && (n[s] = t[s])
                    } else e = d.createCallback(e, r, 3), si(t, function(t, r, i) {
                        e(t, r, i) && (n[r] = t)
                    });
                return n
            }

            function je(t, e, r, n) {
                var i = Jn(t);
                if (null == r)
                    if (i) r = [];
                    else {
                        var o = t && t.constructor,
                            a = o && o.prototype;
                        r = K(a)
                    }
                return e && (e = d.createCallback(e, n, 4), (i ? Ze : hi)(t, function(t, n, i) {
                    return e(r, t, n, i)
                })), r
            }

            function Ie(t) {
                for (var e = -1, r = ti(t), n = r.length, i = dn(n); ++e < n;) i[e] = t[r[e]];
                return i
            }

            function Ge(t) {
                for (var e = arguments, r = -1, n = te(e, !0, !1, 1), i = e[2] && e[2][e[1]] === t ? 1 : n.length, o = dn(i); ++r < i;) o[r] = t[n[r]];
                return o
            }

            function We(t, e, r) {
                var n = -1,
                    i = he(),
                    o = t ? t.length : 0,
                    a = !1;
                return r = (0 > r ? Wn(0, o + r) : r) || 0, Jn(t) ? a = i(t, e, r) > -1 : "number" == typeof o ? a = (De(t) ? t.indexOf(e, r) : i(t, e, r)) > -1 : hi(t, function(t) {
                    return ++n >= r ? !(a = t === e) : void 0
                }), a
            }

            function Xe(t, e, r) {
                var n = !0;
                e = d.createCallback(e, r, 3);
                var i = -1,
                    o = t ? t.length : 0;
                if ("number" == typeof o)
                    for (; ++i < o && (n = !!e(t[i], i, t)););
                else hi(t, function(t, r, i) {
                    return n = !!e(t, r, i)
                });
                return n
            }

            function qe(t, e, r) {
                var n = [];
                e = d.createCallback(e, r, 3);
                var i = -1,
                    o = t ? t.length : 0;
                if ("number" == typeof o)
                    for (; ++i < o;) {
                        var a = t[i];
                        e(a, i, t) && n.push(a)
                    } else hi(t, function(t, r, i) {
                        e(t, r, i) && n.push(t)
                    });
                return n
            }

            function Ye(t, e, r) {
                e = d.createCallback(e, r, 3);
                var n = -1,
                    i = t ? t.length : 0;
                if ("number" != typeof i) {
                    var o;
                    return hi(t, function(t, r, n) {
                        return e(t, r, n) ? (o = t, !1) : void 0
                    }), o
                }
                for (; ++n < i;) {
                    var a = t[n];
                    if (e(a, n, t)) return a
                }
            }

            function Ke(t, e, r) {
                var n;
                return e = d.createCallback(e, r, 3), Qe(t, function(t, r, i) {
                    return e(t, r, i) ? (n = t, !1) : void 0
                }), n
            }

            function Ze(t, e, r) {
                var n = -1,
                    i = t ? t.length : 0;
                if (e = e && "undefined" == typeof r ? e : Z(e, r, 3), "number" == typeof i)
                    for (; ++n < i && e(t[n], n, t) !== !1;);
                else hi(t, e);
                return t
            }

            function Qe(t, e, r) {
                var n = t ? t.length : 0;
                if (e = e && "undefined" == typeof r ? e : Z(e, r, 3), "number" == typeof n)
                    for (; n-- && e(t[n], n, t) !== !1;);
                else {
                    var i = ti(t);
                    n = i.length, hi(t, function(t, r, o) {
                        return r = i ? i[--n] : --n, e(o[r], r, o)
                    })
                }
                return t
            }

            function Je(t, e) {
                var r = c(arguments, 2),
                    n = -1,
                    i = "function" == typeof e,
                    o = t ? t.length : 0,
                    a = dn("number" == typeof o ? o : 0);
                return Ze(t, function(t) {
                    a[++n] = (i ? e : t[e]).apply(t, r)
                }), a
            }

            function $e(t, e, r) {
                var n = -1,
                    i = t ? t.length : 0;
                if (e = d.createCallback(e, r, 3), "number" == typeof i)
                    for (var o = dn(i); ++n < i;) o[n] = e(t[n], n, t);
                else o = [], hi(t, function(t, r, i) {
                    o[++n] = e(t, r, i)
                });
                return o
            }

            function tr(t, e, r) {
                var i = -1 / 0,
                    o = i;
                if ("function" != typeof e && r && r[e] === t && (e = null), null == e && Jn(t))
                    for (var a = -1, s = t.length; ++a < s;) {
                        var h = t[a];
                        h > o && (o = h)
                    } else e = null == e && De(t) ? n : d.createCallback(e, r, 3), Ze(t, function(t, r, n) {
                        var a = e(t, r, n);
                        a > i && (i = a, o = t)
                    });
                return o
            }

            function er(t, e, r) {
                var i = 1 / 0,
                    o = i;
                if ("function" != typeof e && r && r[e] === t && (e = null), null == e && Jn(t))
                    for (var a = -1, s = t.length; ++a < s;) {
                        var h = t[a];
                        o > h && (o = h)
                    } else e = null == e && De(t) ? n : d.createCallback(e, r, 3), Ze(t, function(t, r, n) {
                        var a = e(t, r, n);
                        i > a && (i = a, o = t)
                    });
                return o
            }

            function rr(t, e, r, n) {
                if (!t) return r;
                var i = arguments.length < 3;
                e = d.createCallback(e, n, 4);
                var o = -1,
                    a = t.length;
                if ("number" == typeof a)
                    for (i && (r = t[++o]); ++o < a;) r = e(r, t[o], o, t);
                else hi(t, function(t, n, o) {
                    r = i ? (i = !1, t) : e(r, t, n, o)
                });
                return r
            }

            function nr(t, e, r, n) {
                var i = arguments.length < 3;
                return e = d.createCallback(e, n, 4), Qe(t, function(t, n, o) {
                    r = i ? (i = !1, t) : e(r, t, n, o)
                }), r
            }

            function ir(t, e, r) {
                return e = d.createCallback(e, r, 3), qe(t, function(t, r, n) {
                    return !e(t, r, n)
                })
            }

            function or(t, e, r) {
                if (t && "number" != typeof t.length && (t = Ie(t)), null == e || r) return t ? t[ne(0, t.length - 1)] : f;
                var n = ar(t);
                return n.length = Xn(Wn(0, e), n.length), n
            }

            function ar(t) {
                var e = -1,
                    r = t ? t.length : 0,
                    n = dn("number" == typeof r ? r : 0);
                return Ze(t, function(t) {
                    var r = ne(0, ++e);
                    n[e] = n[r], n[r] = t
                }), n
            }

            function sr(t) {
                var e = t ? t.length : 0;
                return "number" == typeof e ? e : ti(t).length
            }

            function hr(t, e, r) {
                var n;
                e = d.createCallback(e, r, 3);
                var i = -1,
                    o = t ? t.length : 0;
                if ("number" == typeof o)
                    for (; ++i < o && !(n = e(t[i], i, t)););
                else hi(t, function(t, r, i) {
                    return !(n = e(t, r, i))
                });
                return !!n
            }

            function ur(t, e, r) {
                var n = -1,
                    o = Jn(e),
                    a = t ? t.length : 0,
                    c = dn("number" == typeof a ? a : 0);
                for (o || (e = d.createCallback(e, r, 3)), Ze(t, function(t, r, i) {
                        var a = c[++n] = h();
                        o ? a.criteria = $e(e, function(e) {
                            return t[e]
                        }) : (a.criteria = s())[0] = e(t, r, i), a.index = n, a.value = t
                    }), a = c.length, c.sort(i); a--;) {
                    var p = c[a];
                    c[a] = p.value, o || u(p.criteria), l(p)
                }
                return c
            }

            function lr(t) {
                return t && "number" == typeof t.length ? c(t) : Ie(t)
            }

            function cr(t) {
                for (var e = -1, r = t ? t.length : 0, n = []; ++e < r;) {
                    var i = t[e];
                    i && n.push(i)
                }
                return n
            }

            function pr(t) {
                return J(t, te(arguments, !0, !0, 1))
            }

            function fr(t, e, r) {
                var n = -1,
                    i = t ? t.length : 0;
                for (e = d.createCallback(e, r, 3); ++n < i;)
                    if (e(t[n], n, t)) return n;
                return -1
            }

            function dr(t, e, r) {
                var n = t ? t.length : 0;
                for (e = d.createCallback(e, r, 3); n--;)
                    if (e(t[n], n, t)) return n;
                return -1
            }

            function mr(t, e, r) {
                var n = 0,
                    i = t ? t.length : 0;
                if ("number" != typeof e && null != e) {
                    var o = -1;
                    for (e = d.createCallback(e, r, 3); ++o < i && e(t[o], o, t);) n++
                } else if (n = e, null == n || r) return t ? t[0] : f;
                return c(t, 0, Xn(Wn(0, n), i))
            }

            function gr(t, e, r, n) {
                return "boolean" != typeof e && null != e && (n = r, r = "function" != typeof e && n && n[e] === t ? null : e, e = !1), null != r && (t = $e(t, r, n)), te(t, e)
            }

            function vr(e, r, n) {
                if ("number" == typeof n) {
                    var i = e ? e.length : 0;
                    n = 0 > n ? Wn(0, i + n) : n || 0
                } else if (n) {
                    var o = Hr(e, r);
                    return e[o] === r ? o : -1
                }
                return t(e, r, n)
            }

            function Er(t, e, r) {
                var n = 0,
                    i = t ? t.length : 0;
                if ("number" != typeof e && null != e) {
                    var o = i;
                    for (e = d.createCallback(e, r, 3); o-- && e(t[o], o, t);) n++
                } else n = null == e || r ? 1 : e || n;
                return c(t, 0, Xn(Wn(0, i - n), i))
            }

            function yr() {
                for (var r = [], n = -1, i = arguments.length, a = s(), h = he(), c = h === t, p = s(); ++n < i;) {
                    var f = arguments[n];
                    (Jn(f) || pe(f)) && (r.push(f), a.push(c && f.length >= E && o(n ? r[n] : p)))
                }
                var d = r[0],
                    m = -1,
                    g = d ? d.length : 0,
                    v = [];
                t: for (; ++m < g;) {
                    var y = a[0];
                    if (f = d[m], (y ? e(y, f) : h(p, f)) < 0) {
                        for (n = i, (y || p).push(f); --n;)
                            if (y = a[n], (y ? e(y, f) : h(r[n], f)) < 0) continue t;
                        v.push(f)
                    }
                }
                for (; i--;) y = a[i], y && l(y);
                return u(a), u(p), v
            }

            function Tr(t, e, r) {
                var n = 0,
                    i = t ? t.length : 0;
                if ("number" != typeof e && null != e) {
                    var o = i;
                    for (e = d.createCallback(e, r, 3); o-- && e(t[o], o, t);) n++
                } else if (n = e, null == n || r) return t ? t[i - 1] : f;
                return c(t, Wn(0, i - n))
            }

            function xr(t, e, r) {
                var n = t ? t.length : 0;
                for ("number" == typeof r && (n = (0 > r ? Wn(0, n + r) : Xn(r, n - 1)) + 1); n--;)
                    if (t[n] === e) return n;
                return -1
            }

            function _r(t) {
                for (var e = arguments, r = 0, n = e.length, i = t ? t.length : 0; ++r < n;)
                    for (var o = -1, a = e[r]; ++o < i;) t[o] === a && (Un.call(t, o--, 1), i--);
                return t
            }

            function br(t, e, r) {
                t = +t || 0, r = "number" == typeof r ? r : +r || 1, null == e && (e = t, t = 0);
                for (var n = -1, i = Wn(0, An((e - t) / (r || 1))), o = dn(i); ++n < i;) o[n] = t, t += r;
                return o
            }

            function Rr(t, e, r) {
                var n = -1,
                    i = t ? t.length : 0,
                    o = [];
                for (e = d.createCallback(e, r, 3); ++n < i;) {
                    var a = t[n];
                    e(a, n, t) && (o.push(a), Un.call(t, n--, 1), i--)
                }
                return o
            }

            function wr(t, e, r) {
                if ("number" != typeof e && null != e) {
                    var n = 0,
                        i = -1,
                        o = t ? t.length : 0;
                    for (e = d.createCallback(e, r, 3); ++i < o && e(t[i], i, t);) n++
                } else n = null == e || r ? 1 : Wn(0, e);
                return c(t, n)
            }

            function Hr(t, e, r, n) {
                var i = 0,
                    o = t ? t.length : i;
                for (r = r ? d.createCallback(r, n, 1) : Qr, e = r(e); o > i;) {
                    var a = i + o >>> 1;
                    r(t[a]) < e ? i = a + 1 : o = a
                }
                return i
            }

            function Mr() {
                return ie(te(arguments, !0, !0))
            }

            function Sr(t, e, r, n) {
                return "boolean" != typeof e && null != e && (n = r, r = "function" != typeof e && n && n[e] === t ? null : e, e = !1), null != r && (r = d.createCallback(r, n, 3)), ie(t, e, r)
            }

            function Ar(t) {
                return J(t, c(arguments, 1))
            }

            function Cr() {
                for (var t = -1, e = arguments.length; ++t < e;) {
                    var r = arguments[t];
                    if (Jn(r) || pe(r)) var n = n ? ie(J(n, r).concat(J(r, n))) : r
                }
                return n || []
            }

            function kr() {
                for (var t = arguments.length > 1 ? arguments : arguments[0], e = -1, r = t ? tr(fi(t, "length")) : 0, n = dn(0 > r ? 0 : r); ++e < r;) n[e] = fi(t, e);
                return n
            }

            function Lr(t, e) {
                var r = -1,
                    n = t ? t.length : 0,
                    i = {};
                for (e || !n || Jn(t[0]) || (e = []); ++r < n;) {
                    var o = t[r];
                    e ? i[o] = e[r] : o && (i[o[0]] = o[1])
                }
                return i
            }

            function zr(t, e) {
                if (!Ae(e)) throw new bn;
                return function() {
                    return --t < 1 ? e.apply(this, arguments) : void 0
                }
            }

            function Pr(t, e) {
                return arguments.length > 2 ? ae(t, 17, c(arguments, 2), null, e) : ae(t, 1, null, null, e)
            }

            function Dr(t) {
                for (var e = arguments.length > 1 ? te(arguments, !0, !1, 1) : Te(t), r = -1, n = e.length; ++r < n;) {
                    var i = e[r];
                    t[i] = ae(t[i], 1, null, null, t)
                }
                return t
            }

            function Fr(t, e) {
                return arguments.length > 2 ? ae(e, 19, c(arguments, 2), null, t) : ae(e, 3, null, null, t)
            }

            function Ur() {
                for (var t = arguments, e = t.length; e--;)
                    if (!Ae(t[e])) throw new bn;
                return function() {
                    for (var e = arguments, r = t.length; r--;) e = [t[r].apply(this, e)];
                    return e[0]
                }
            }

            function Or(t, e) {
                return e = "number" == typeof e ? e : +e || t.length, ae(t, 4, null, null, null, e)
            }

            function Br(t, e, r) {
                var n, i, o, a, s, h, u, l = 0,
                    c = !1,
                    p = !0;
                if (!Ae(t)) throw new bn;
                if (e = Wn(0, e) || 0, r === !0) {
                    var d = !0;
                    p = !1
                } else Ce(r) && (d = r.leading, c = "maxWait" in r && (Wn(e, r.maxWait) || 0), p = "trailing" in r ? r.trailing : p);
                var m = function() {
                        var r = e - (mi() - a);
                        if (0 >= r) {
                            i && Cn(i);
                            var c = u;
                            i = h = u = f, c && (l = mi(), o = t.apply(s, n), h || i || (n = s = null))
                        } else h = Fn(m, r)
                    },
                    g = function() {
                        h && Cn(h), i = h = u = f, (p || c !== e) && (l = mi(), o = t.apply(s, n), h || i || (n = s = null))
                    };
                return function() {
                    if (n = arguments, a = mi(), s = this, u = p && (h || !d), c === !1) var r = d && !h;
                    else {
                        i || d || (l = a);
                        var f = c - (a - l),
                            v = 0 >= f;
                        v ? (i && (i = Cn(i)), l = a, o = t.apply(s, n)) : i || (i = Fn(g, f))
                    }
                    return v && h ? h = Cn(h) : h || e === c || (h = Fn(m, e)), r && (v = !0, o = t.apply(s, n)), !v || h || i || (n = s = null), o
                }
            }

            function Vr(t) {
                if (!Ae(t)) throw new bn;
                var e = c(arguments, 1);
                return Fn(function() {
                    t.apply(f, e)
                }, 1)
            }

            function Nr(t, e) {
                if (!Ae(t)) throw new bn;
                var r = c(arguments, 2);
                return Fn(function() {
                    t.apply(f, r)
                }, e)
            }

            function jr(t, e) {
                if (!Ae(t)) throw new bn;
                var r = function() {
                    var n = r.cache,
                        i = e ? e.apply(this, arguments) : v + arguments[0];
                    return Pn.call(n, i) ? n[i] : n[i] = t.apply(this, arguments)
                };
                return r.cache = {}, r
            }

            function Ir(t) {
                var e, r;
                if (!Ae(t)) throw new bn;
                return function() {
                    return e ? r : (e = !0, r = t.apply(this, arguments), t = null, r)
                }
            }

            function Gr(t) {
                return ae(t, 16, c(arguments, 1))
            }

            function Wr(t) {
                return ae(t, 32, null, c(arguments, 1))
            }

            function Xr(t, e, r) {
                var n = !0,
                    i = !0;
                if (!Ae(t)) throw new bn;
                return r === !1 ? n = !1 : Ce(r) && (n = "leading" in r ? r.leading : n, i = "trailing" in r ? r.trailing : i), G.leading = n, G.maxWait = e, G.trailing = i, Br(t, e, G)
            }

            function qr(t, e) {
                return ae(e, 16, [t])
            }

            function Yr(t) {
                return function() {
                    return t
                }
            }

            function Kr(t, e, r) {
                var n = typeof t;
                if (null == t || "function" == n) return Z(t, e, r);
                if ("object" != n) return en(t);
                var i = ti(t),
                    o = i[0],
                    a = t[o];
                return 1 != i.length || a !== a || Ce(a) ? function(e) {
                    for (var r = i.length, n = !1; r-- && (n = ee(e[i[r]], t[i[r]], null, !0)););
                    return n
                } : function(t) {
                    var e = t[o];
                    return a === e && (0 !== a || 1 / a == 1 / e)
                }
            }

            function Zr(t) {
                return null == t ? "" : _n(t).replace(ii, se)
            }

            function Qr(t) {
                return t
            }

            function Jr(t, e, r) {
                var n = !0,
                    i = e && Te(e);
                e && (r || i.length) || (null == r && (r = e), o = m, e = t, t = d, i = Te(e)), r === !1 ? n = !1 : Ce(r) && "chain" in r && (n = r.chain);
                var o = t,
                    a = Ae(o);
                Ze(i, function(r) {
                    var i = t[r] = e[r];
                    a && (o.prototype[r] = function() {
                        var e = this.__chain__,
                            r = this.__wrapped__,
                            a = [r];
                        Dn.apply(a, arguments);
                        var s = i.apply(t, a);
                        if (n || e) {
                            if (r === s && Ce(s)) return this;
                            s = new o(s), s.__chain__ = e
                        }
                        return s
                    })
                })
            }

            function $r() {
                return r._ = Hn, this
            }

            function tn() {}

            function en(t) {
                return function(e) {
                    return e[t]
                }
            }

            function rn(t, e, r) {
                var n = null == t,
                    i = null == e;
                if (null == r && ("boolean" == typeof t && i ? (r = t, t = 1) : i || "boolean" != typeof e || (r = e, i = !0)), n && i && (e = 1), t = +t || 0, i ? (e = t, t = 0) : e = +e || 0, r || t % 1 || e % 1) {
                    var o = Yn();
                    return Xn(t + o * (e - t + parseFloat("1e-" + ((o + "").length - 1))), e)
                }
                return ne(t, e)
            }

            function nn(t, e) {
                if (t) {
                    var r = t[e];
                    return Ae(r) ? t[e]() : r
                }
            }

            function on(t, e, r) {
                var n = d.templateSettings;
                t = _n(t || ""), r = ai({}, r, n);
                var i, o = ai({}, r.imports, n.imports),
                    s = ti(o),
                    h = Ie(o),
                    u = 0,
                    l = r.interpolate || A,
                    c = "__p += '",
                    p = xn((r.escape || A).source + "|" + l.source + "|" + (l === M ? R : A).source + "|" + (r.evaluate || A).source + "|$", "g");
                t.replace(p, function(e, r, n, o, s, h) {
                    return n || (n = o), c += t.slice(u, h).replace(k, a), r && (c += "' +\n__e(" + r + ") +\n'"), s && (i = !0, c += "';\n" + s + ";\n__p += '"), n && (c += "' +\n((__t = (" + n + ")) == null ? '' : __t) +\n'"), u = h + e.length, e
                }), c += "';\n";
                var m = r.variable,
                    g = m;
                g || (m = "obj", c = "with (" + m + ") {\n" + c + "\n}\n"), c = (i ? c.replace(x, "") : c).replace(_, "$1").replace(b, "$1;"), c = "function(" + m + ") {\n" + (g ? "" : m + " || (" + m + " = {});\n") + "var __t, __p = '', __e = _.escape" + (i ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + c + "return __p\n}";
                var v = "\n/*\n//# sourceURL=" + (r.sourceURL || "/lodash/template/source[" + z++ +"]") + "\n*/";
                try {
                    var E = vn(s, "return " + c + v).apply(f, h)
                } catch (y) {
                    throw y.source = c, y
                }
                return e ? E(e) : (E.source = c, E)
            }

            function an(t, e, r) {
                t = (t = +t) > -1 ? t : 0;
                var n = -1,
                    i = dn(t);
                for (e = Z(e, r, 1); ++n < t;) i[n] = e(n);
                return i
            }

            function sn(t) {
                return null == t ? "" : _n(t).replace(ni, ce)
            }

            function hn(t) {
                var e = ++g;
                return _n(null == t ? "" : t) + e
            }

            function un(t) {
                return t = new m(t), t.__chain__ = !0, t
            }

            function ln(t, e) {
                return e(t), t
            }

            function cn() {
                return this.__chain__ = !0, this
            }

            function pn() {
                return _n(this.__wrapped__)
            }

            function fn() {
                return this.__wrapped__
            }
            r = r ? $.defaults(Y.Object(), r, $.pick(Y, L)) : Y;
            var dn = r.Array,
                mn = r.Boolean,
                gn = r.Date,
                vn = r.Function,
                En = r.Math,
                yn = r.Number,
                Tn = r.Object,
                xn = r.RegExp,
                _n = r.String,
                bn = r.TypeError,
                Rn = [],
                wn = Tn.prototype,
                Hn = r._,
                Mn = wn.toString,
                Sn = xn("^" + _n(Mn).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"),
                An = En.ceil,
                Cn = r.clearTimeout,
                kn = En.floor,
                Ln = vn.prototype.toString,
                zn = ue(zn = Tn.getPrototypeOf) && zn,
                Pn = wn.hasOwnProperty,
                Dn = Rn.push,
                Fn = r.setTimeout,
                Un = Rn.splice,
                On = Rn.unshift,
                Bn = function() {
                    try {
                        var t = {},
                            e = ue(e = Tn.defineProperty) && e,
                            r = e(t, t, t) && e
                    } catch (n) {}
                    return r
                }(),
                Vn = ue(Vn = Tn.create) && Vn,
                Nn = ue(Nn = dn.isArray) && Nn,
                jn = r.isFinite,
                In = r.isNaN,
                Gn = ue(Gn = Tn.keys) && Gn,
                Wn = En.max,
                Xn = En.min,
                qn = r.parseInt,
                Yn = En.random,
                Kn = {};
            Kn[D] = dn, Kn[F] = mn, Kn[U] = gn, Kn[O] = vn, Kn[V] = Tn, Kn[B] = yn, Kn[N] = xn, Kn[j] = _n, m.prototype = d.prototype;
            var Zn = d.support = {};
            Zn.funcDecomp = !ue(r.WinRTError) && C.test(p), Zn.funcNames = "string" == typeof vn.name, d.templateSettings = {
                escape: /<%-([\s\S]+?)%>/g,
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: M,
                variable: "",
                imports: {
                    _: d
                }
            }, Vn || (K = function() {
                function t() {}
                return function(e) {
                    if (Ce(e)) {
                        t.prototype = e;
                        var n = new t;
                        t.prototype = null
                    }
                    return n || r.Object()
                }
            }());
            var Qn = Bn ? function(t, e) {
                    W.value = e, Bn(t, "__bindData__", W)
                } : tn,
                Jn = Nn || function(t) {
                    return t && "object" == typeof t && "number" == typeof t.length && Mn.call(t) == D || !1
                },
                $n = function(t) {
                    var e, r = t,
                        n = [];
                    if (!r) return n;
                    if (!X[typeof t]) return n;
                    for (e in r) Pn.call(r, e) && n.push(e);
                    return n
                },
                ti = Gn ? function(t) {
                    return Ce(t) ? Gn(t) : []
                } : $n,
                ei = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                },
                ri = _e(ei),
                ni = xn("(" + ti(ri).join("|") + ")", "g"),
                ii = xn("[" + ti(ei).join("") + "]", "g"),
                oi = function(t, e, r) {
                    var n, i = t,
                        o = i;
                    if (!i) return o;
                    var a = arguments,
                        s = 0,
                        h = "number" == typeof r ? 2 : a.length;
                    if (h > 3 && "function" == typeof a[h - 2]) var u = Z(a[--h - 1], a[h--], 2);
                    else h > 2 && "function" == typeof a[h - 1] && (u = a[--h]);
                    for (; ++s < h;)
                        if (i = a[s], i && X[typeof i])
                            for (var l = -1, c = X[typeof i] && ti(i), p = c ? c.length : 0; ++l < p;) n = c[l], o[n] = u ? u(o[n], i[n]) : i[n];
                    return o
                },
                ai = function(t, e, r) {
                    var n, i = t,
                        o = i;
                    if (!i) return o;
                    for (var a = arguments, s = 0, h = "number" == typeof r ? 2 : a.length; ++s < h;)
                        if (i = a[s], i && X[typeof i])
                            for (var u = -1, l = X[typeof i] && ti(i), c = l ? l.length : 0; ++u < c;) n = l[u], "undefined" == typeof o[n] && (o[n] = i[n]);
                    return o
                },
                si = function(t, e, r) {
                    var n, i = t,
                        o = i;
                    if (!i) return o;
                    if (!X[typeof i]) return o;
                    e = e && "undefined" == typeof r ? e : Z(e, r, 3);
                    for (n in i)
                        if (e(i[n], n, t) === !1) return o;
                    return o
                },
                hi = function(t, e, r) {
                    var n, i = t,
                        o = i;
                    if (!i) return o;
                    if (!X[typeof i]) return o;
                    e = e && "undefined" == typeof r ? e : Z(e, r, 3);
                    for (var a = -1, s = X[typeof i] && ti(i), h = s ? s.length : 0; ++a < h;)
                        if (n = s[a], e(i[n], n, t) === !1) return o;
                    return o
                },
                ui = zn ? function(t) {
                    if (!t || Mn.call(t) != V) return !1;
                    var e = t.valueOf,
                        r = ue(e) && (r = zn(e)) && zn(r);
                    return r ? t == r || zn(t) == r : le(t)
                } : le,
                li = oe(function(t, e, r) {
                    Pn.call(t, r) ? t[r] ++ : t[r] = 1
                }),
                ci = oe(function(t, e, r) {
                    (Pn.call(t, r) ? t[r] : t[r] = []).push(e)
                }),
                pi = oe(function(t, e, r) {
                    t[r] = e
                }),
                fi = $e,
                di = qe,
                mi = ue(mi = gn.now) && mi || function() {
                    return (new gn).getTime()
                },
                gi = 8 == qn(T + "08") ? qn : function(t, e) {
                    return qn(De(t) ? t.replace(S, "") : t, e || 0)
                };
            return d.after = zr, d.assign = oi, d.at = Ge, d.bind = Pr, d.bindAll = Dr, d.bindKey = Fr, d.chain = un, d.compact = cr, d.compose = Ur, d.constant = Yr, d.countBy = li, d.create = me, d.createCallback = Kr, d.curry = Or, d.debounce = Br, d.defaults = ai, d.defer = Vr, d.delay = Nr, d.difference = pr, d.filter = qe, d.flatten = gr, d.forEach = Ze, d.forEachRight = Qe, d.forIn = si, d.forInRight = Ee, d.forOwn = hi, d.forOwnRight = ye, d.functions = Te, d.groupBy = ci, d.indexBy = pi, d.initial = Er, d.intersection = yr, d.invert = _e, d.invoke = Je, d.keys = ti, d.map = $e, d.mapValues = Ue, d.max = tr, d.memoize = jr, d.merge = Oe, d.min = er, d.omit = Be, d.once = Ir, d.pairs = Ve, d.partial = Gr, d.partialRight = Wr, d.pick = Ne, d.pluck = fi, d.property = en, d.pull = _r, d.range = br, d.reject = ir, d.remove = Rr, d.rest = wr, d.shuffle = ar, d.sortBy = ur, d.tap = ln, d.throttle = Xr, d.times = an, d.toArray = lr, d.transform = je, d.union = Mr, d.uniq = Sr, d.values = Ie, d.where = di, d.without = Ar, d.wrap = qr, d.xor = Cr, d.zip = kr, d.zipObject = Lr, d.collect = $e, d.drop = wr, d.each = Ze, d.eachRight = Qe, d.extend = oi, d.methods = Te, d.object = Lr, d.select = qe, d.tail = wr, d.unique = Sr, d.unzip = kr, Jr(d), d.clone = fe, d.cloneDeep = de, d.contains = We, d.escape = Zr, d.every = Xe, d.find = Ye, d.findIndex = fr, d.findKey = ge, d.findLast = Ke, d.findLastIndex = dr, d.findLastKey = ve, d.has = xe, d.identity = Qr, d.indexOf = vr, d.isArguments = pe, d.isArray = Jn, d.isBoolean = be, d.isDate = Re, d.isElement = we, d.isEmpty = He, d.isEqual = Me, d.isFinite = Se, d.isFunction = Ae, d.isNaN = ke, d.isNull = Le, d.isNumber = ze, d.isObject = Ce, d.isPlainObject = ui, d.isRegExp = Pe, d.isString = De, d.isUndefined = Fe, d.lastIndexOf = xr, d.mixin = Jr, d.noConflict = $r, d.noop = tn, d.now = mi, d.parseInt = gi, d.random = rn, d.reduce = rr, d.reduceRight = nr, d.result = nn, d.runInContext = p, d.size = sr, d.some = hr, d.sortedIndex = Hr, d.template = on, d.unescape = sn, d.uniqueId = hn, d.all = Xe, d.any = hr, d.detect = Ye, d.findWhere = Ye, d.foldl = rr, d.foldr = nr, d.include = We, d.inject = rr, Jr(function() {
                var t = {};
                return hi(d, function(e, r) {
                    d.prototype[r] || (t[r] = e)
                }), t
            }(), !1), d.first = mr, d.last = Tr, d.sample = or, d.take = mr, d.head = mr, hi(d, function(t, e) {
                var r = "sample" !== e;
                d.prototype[e] || (d.prototype[e] = function(e, n) {
                    var i = this.__chain__,
                        o = t(this.__wrapped__, e, n);
                    return i || null != e && (!n || r && "function" == typeof e) ? new m(o, i) : o
                })
            }), d.VERSION = "2.4.1", d.prototype.chain = cn, d.prototype.toString = pn, d.prototype.value = fn, d.prototype.valueOf = fn, Ze(["join", "pop", "shift"], function(t) {
                var e = Rn[t];
                d.prototype[t] = function() {
                    var t = this.__chain__,
                        r = e.apply(this.__wrapped__, arguments);
                    return t ? new m(r, t) : r
                }
            }), Ze(["push", "reverse", "sort", "unshift"], function(t) {
                var e = Rn[t];
                d.prototype[t] = function() {
                    return e.apply(this.__wrapped__, arguments), this
                }
            }), Ze(["concat", "slice", "splice"], function(t) {
                var e = Rn[t];
                d.prototype[t] = function() {
                    return new m(e.apply(this.__wrapped__, arguments), this.__chain__)
                }
            }), d
        }
        var f, d = [],
            m = [],
            g = 0,
            v = +new Date + "",
            E = 75,
            y = 40,
            T = " 	\f ﻿\n\r\u2028\u2029 ᠎             　",
            x = /\b__p \+= '';/g,
            _ = /\b(__p \+=) '' \+/g,
            b = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            R = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            w = /\w*$/,
            H = /^\s*function[ \n\r\t]+\w/,
            M = /<%=([\s\S]+?)%>/g,
            S = RegExp("^[" + T + "]*0+(?=.$)"),
            A = /($^)/,
            C = /\bthis\b/,
            k = /['\n\r\t\u2028\u2029\\]/g,
            L = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout"],
            z = 0,
            P = "[object Arguments]",
            D = "[object Array]",
            F = "[object Boolean]",
            U = "[object Date]",
            O = "[object Function]",
            B = "[object Number]",
            V = "[object Object]",
            N = "[object RegExp]",
            j = "[object String]",
            I = {};
        I[O] = !1, I[P] = I[D] = I[F] = I[U] = I[B] = I[V] = I[N] = I[j] = !0;
        var G = {
                leading: !1,
                maxWait: 0,
                trailing: !1
            },
            W = {
                configurable: !1,
                enumerable: !1,
                value: null,
                writable: !1
            },
            X = {
                "boolean": !1,
                "function": !0,
                object: !0,
                number: !1,
                string: !1,
                undefined: !1
            },
            q = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "	": "t",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            Y = X[typeof window] && window || this,
            K = X[typeof exports] && exports && !exports.nodeType && exports,
            Z = X[typeof module] && module && !module.nodeType && module,
            Q = Z && Z.exports === K && K,
            J = X[typeof global] && global;
        !J || J.global !== J && J.window !== J || (Y = J);
        var $ = p();
        "function" == typeof define && "object" == typeof define.amd && define.amd ? (Y._ = $, define(function() {
            return $
        })) : K && Z ? Q ? (Z.exports = $)._ = $ : K._ = $ : Y._ = $
    }.call(this), THREE.Binder = {
        bind: function(t, e) {
            return function(r, n) {
                n.__binds || (n.__binds = []);
                var i = t;
                _.isArray(r) && (i = r[0], r = r[1]);
                for (var o = /^([^.:]*(?:\.[^.:]+)*)?(?:\:(.*))?$/.exec(r), a = o[1].split(/\./g), s = a.pop(), h = o[2] || s, u = a.shift(), l = {
                        "this": n
                    }[u] || e[u] || t[u] || i; l && (r = a.shift());) l = l[r];
                if (l && (l.on || l.addEventListener)) {
                    var c = function(e) {
                        n[h] && n[h](e, t)
                    };
                    THREE.Binder._polyfill(l, ["addEventListener", "on"], function(t) {
                        l[t](s, c)
                    });
                    var p = {
                        target: l,
                        name: s,
                        callback: c
                    };
                    return n.__binds.push(p), c
                }
                throw "Cannot bind '" + r + "' in " + this.__name
            }
        },
        unbind: function() {
            return function(t) {
                t.__binds && (t.__binds.forEach(function(t) {
                    THREE.Binder._polyfill(t.target, ["removeEventListener", "off"], function(e) {
                        t.target[e](t.name, t.callback)
                    })
                }.bind(this)), t.__binds = [])
            }
        },
        apply: function(t) {
            THREE.EventDispatcher.prototype.apply(t), t.trigger = THREE.Binder._trigger, t.triggerOnce = THREE.Binder._triggerOnce, t.on = t.addEventListener, t.off = t.removeEventListener, t.dispatchEvent = t.trigger
        },
        _triggerOnce: function(t) {
            this.trigger(t), this._listeners && delete this._listeners[t.type]
        },
        _trigger: function(t) {
            if (void 0 !== this._listeners) {
                var e = t.type,
                    r = this._listeners[e];
                if (void 0 !== r) {
                    r = r.slice();
                    var n = r.length;
                    t.target = this;
                    for (var i = 0; n > i; i++) r[i].call(this, t, this)
                }
            }
        },
        _polyfill: function(t, e, r) {
            e.map(function() {
                return t.method
            }), e.length && r(e[0])
        }
    }, THREE.Api = {
        apply: function(t) {
            t.set = function(t) {
                var e = this.options || {},
                    r = _.reduce(t, function(t, r, n) {
                        return e[n] !== r && (t[n] = r), t
                    }, {});
                this.options = _.extend(e, r), this.trigger({
                    type: "change",
                    options: t,
                    changes: r
                })
            }, t.get = function() {
                return this.options
            }, t.api = function(t, e) {
                return t = t || {}, e && _.each(t, function(t, r, n) {
                    _.isFunction(t) && (n[r] = _.partialRight(t, e))
                }), t.set = this.set.bind(this), t.get = this.get.bind(this), t
            }
        }
    }, THREE.Bootstrap = function(t) {
        if (t) {
            var e = [].slice.apply(arguments);
            t = {}, e[0] instanceof Node && (node = e[0], e = e.slice(1), t.element = node), _.isString(e[0]) && (t.plugins = e), _.isArray(e[0]) && (t.plugins = e[0]), e[0] && (t = _.defaults(t, e[0]))
        }
        if (!(this instanceof THREE.Bootstrap)) return new THREE.Bootstrap(t);
        var r = {
            init: !0,
            element: document.body,
            plugins: ["core"],
            aliases: {},
            plugindb: THREE.Bootstrap.Plugins || {},
            aliasdb: THREE.Bootstrap.Aliases || {}
        };
        this.__options = _.defaults(t || {}, r), this.__inited = !1, this.__destroyed = !1, this.__installed = [];
        var n = this.__options.element;
        n === "" + n && (n = document.querySelector(n)), this.plugins = {}, this.element = n, this.__options.init && this.init()
    }, THREE.Bootstrap.prototype = {
        init: function() {
            return this.__inited ? void 0 : (this.__inited = !0, this.install(this.__options.plugins), this)
        },
        destroy: function() {
            return this.__inited && !this.__destroyed ? (this.__destroyed = !0, this.trigger({
                type: "destroy"
            }), this.uninstall(), this) : void 0
        },
        resolve: function(t) {
            function e(t, r, o) {
                if (o >= 256) throw "Plug-in alias recursion detected.";
                return t = _.filter(t, i), _.each(t, function(t) {
                    var i = n[t];
                    i ? r = r.concat(e(i, [], o + 1)) : r.push(t)
                }), r
            }
            t = _.isArray(t) ? t : [t];
            var r = this.__options,
                n = _.extend({}, r.aliasdb, r.aliases),
                i = function(t) {
                    var e = t.split(":");
                    return e[1] ? (n[e[0]] = [e[1]], !1) : !0
                };
            return t = _.filter(t, i), _.each(n, function(t, e) {
                n[e] = _.isArray(t) ? t : [t]
            }), e(t, [], 0)
        },
        install: function(t) {
            t = _.isArray(t) ? t : [t], t = this.resolve(t), _.each(t, this.__install, this), this.__ready()
        },
        uninstall: function(t) {
            t && (t = _.isArray(t) ? t : [t], t = this.resolve(t)), _.eachRight(t || this.__installed, this.__uninstall, this)
        },
        __install: function(t) {
            var e = this.__options.plugindb[t];
            if (!e) throw "[three.install] Cannot install. '" + t + "' is not registered.";
            if (this.plugins[t]) return console.warn("[three.install] " + t + " is already installed.");
            var r = e,
                n = new r(this.__options[t] || {}, t);
            return this.plugins[t] = n, flag = n.install(this), this.__installed.push(n), this.trigger({
                type: "install",
                plugin: n
            }), flag
        },
        __uninstall: function(t) {
            return (plugin = _.isString(t) ? this.plugins[t] : t) ? (t = plugin.__name, plugin.uninstall(this), this.__installed = _.without(this.__installed, plugin), delete this.plugins[t], void this.trigger({
                type: "uninstall",
                plugin: plugin
            })) : console.warn("[three.uninstall] " + t + "' is not installed.")
        },
        __ready: function() {
            this.triggerOnce({
                type: "ready"
            })
        }
    }, THREE.Binder.apply(THREE.Bootstrap.prototype), THREE.Bootstrap.Plugins = {}, THREE.Bootstrap.Aliases = {}, THREE.Bootstrap.Plugin = function(t) {
        this.options = _.defaults(t || {}, this.defaults)
    }, THREE.Bootstrap.Plugin.prototype = {
        listen: [],
        defaults: {},
        install: function() {},
        uninstall: function() {}
    }, THREE.Binder.apply(THREE.Bootstrap.Plugin.prototype), THREE.Api.apply(THREE.Bootstrap.Plugin.prototype), THREE.Bootstrap.registerPlugin = function(t, e) {
        var r = function(e) {
            THREE.Bootstrap.Plugin.call(this, e), this.__name = t
        };
        r.prototype = _.extend(new THREE.Bootstrap.Plugin, e), THREE.Bootstrap.Plugins[t] = r
    }, THREE.Bootstrap.unregisterPlugin = function(t) {
        delete THREE.Bootstrap.Plugins[t]
    }, THREE.Bootstrap.registerAlias = function(t, e) {
        THREE.Bootstrap.Aliases[t] = e
    }, THREE.Bootstrap.unregisterAlias = function(t) {
        delete THREE.Bootstrap.Aliases[t]
    }, THREE.Bootstrap.registerAlias("empty", ["fallback", "bind", "renderer", "size", "fill", "loop", "time"]), THREE.Bootstrap.registerAlias("core", ["empty", "scene", "camera", "render", "warmup"]), THREE.Bootstrap.registerAlias("VR", ["core", "cursor", "fullscreen", "render:vr"]), THREE.Bootstrap.registerPlugin("fallback", {
        defaults: {
            force: !1,
            fill: !0,
            begin: '<div class="threestrap-fallback" style="display: table; width: 100%; height: 100%;box-sizing: border-box; border: 1px dashed rgba(0, 0, 0, .25);"><div style="display: table-cell; padding: 10px; vertical-align: middle; text-align: center;">',
            end: "</div></div>",
            message: '<big><strong>This example requires WebGL</strong></big><br>Visit <a target="_blank" href="http://get.webgl.org/">get.webgl.org</a> for more info</a>'
        },
        install: function(t) {
            var e;
            try {
                if (e = document.createElement("canvas"), gl = e.getContext("webgl") || e.getContext("experimental-webgl"), !gl || this.options.force) throw "WebGL unavailable.";
                t.fallback = !1
            } catch (r) {
                var n = this.options.message,
                    i = this.options.begin,
                    o = this.options.end,
                    a = this.options.fill,
                    s = document.createElement("div");
                for (s.innerHTML = i + n + o, this.children = []; s.childNodes.length > 0;) this.children.push(s.firstChild), t.element.appendChild(s.firstChild);
                return a && t.install("fill"), this.div = s, t.fallback = !0, !1
            }
        },
        uninstall: function(t) {
            this.children && (this.children.forEach(function(t) {
                t.parentNode.removeChild(t)
            }), this.children = null), delete t.fallback
        }
    }), THREE.Bootstrap.registerPlugin("renderer", {
        defaults: {
            klass: THREE.WebGLRenderer,
            parameters: {
                depth: !0,
                stencil: !0,
                preserveDrawingBuffer: !0,
                antialias: !0
            }
        },
        listen: ["resize"],
        install: function(t) {
            var e = t.renderer = new this.options.klass(this.options.parameters);
            t.canvas = e.domElement, t.element.appendChild(e.domElement)
        },
        uninstall: function(t) {
            t.element.removeChild(t.renderer.domElement), delete t.renderer, delete t.canvas
        },
        resize: function(t, e) {
            var r = e.renderer,
                n = r.domElement;
            n && "CANVAS" == n.tagName ? r.setSize(t.renderWidth, t.renderHeight, !1) : (r.setRenderSize && r.setRenderSize(t.renderWidth, t.renderHeight), r.setSize(t.viewWidth, t.viewHeight, !1))
        }
    }), THREE.Bootstrap.registerPlugin("bind", {
        install: function(t) {
            var e = {
                three: t,
                window: window
            };
            t.bind = THREE.Binder.bind(t, e), t.unbind = THREE.Binder.unbind(t), t.bind("install:bind", this), t.bind("uninstall:unbind", this)
        },
        uninstall: function(t) {
            t.unbind(this), delete t.bind, delete t.unbind
        },
        bind: function(t, e) {
            var r = t.plugin,
                n = r.listen;
            n && n.forEach(function(t) {
                e.bind(t, r)
            })
        },
        unbind: function(t, e) {
            e.unbind(t.plugin)
        }
    }), THREE.Bootstrap.registerPlugin("size", {
        defaults: {
            width: null,
            height: null,
            aspect: null,
            scale: 1,
            maxRenderWidth: 1 / 0,
            maxRenderHeight: 1 / 0
        },
        listen: ["window.resize:queue", "element.resize:queue", "this.change:queue", "ready:resize", "pre:pre"],
        install: function(t) {
            t.Size = this.api({
                renderWidth: 0,
                renderHeight: 0,
                viewWidth: 0,
                viewHeight: 0
            }), this.resized = !1
        },
        uninstall: function(t) {
            delete t.Size
        },
        queue: function() {
            this.resized = !0
        },
        pre: function(t, e) {
            this.resized && (this.resized = !1, this.resize(t, e))
        },
        resize: function(t, e) {
            var r, n, i, o, a, s, h, u, l = this.options,
                c = e.element,
                p = e.renderer,
                f = 0,
                d = 0;
            r = i = void 0 === l.width || null == l.width ? c.offsetWidth || c.innerWidth || 0 : l.width, n = o = void 0 === l.height || null == l.height ? c.offsetHeight || c.innerHeight || 0 : l.height, h = r / n, l.aspect && (l.aspect > h ? (n = Math.round(r / l.aspect), d = Math.floor((o - n) / 2)) : (r = Math.round(n * l.aspect), f = Math.floor((i - r) / 2)), h = r / n), a = Math.min(r * l.scale, l.maxRenderWidth), s = Math.min(n * l.scale, l.maxRenderHeight), raspect = a / s, raspect > h ? a = Math.round(s * h) : s = Math.round(a / h), u = p.domElement.style, u.width = r + "px", u.height = n + "px", u.marginLeft = f + "px", u.marginTop = d + "px", _.extend(e.Size, {
                renderWidth: a,
                renderHeight: s,
                viewWidth: r,
                viewHeight: n,
                aspect: h
            }), e.trigger({
                type: "resize",
                renderWidth: a,
                renderHeight: s,
                viewWidth: r,
                viewHeight: n,
                aspect: h
            })
        }
    }), THREE.Bootstrap.registerPlugin("fill", {
        defaults: {
            block: !0,
            body: !0,
            layout: !0
        },
        install: function(t) {
            function e(t) {
                var e = t.style.height;
                return "auto" == e || "" == e
            }

            function r(t) {
                return t.style.height = "100%", t.style.margin = 0, t.style.padding = 0, t
            }
            if (this.options.body && t.element == document.body && (this.applied = [t.element, document.documentElement].filter(e).map(r)), this.options.block && t.canvas && (t.canvas.style.display = "block", this.block = !0), this.options.layout && t.element) {
                var n = window.getComputedStyle(t.element);
                "static" == n.position && (t.element.style.position = "relative", this.layout = !0)
            }
        },
        uninstall: function(t) {
            function e(t) {
                return t.style.height = "", t.style.margin = "", t.style.padding = "", t
            }
            this.applied && (this.applied.map(e), delete this.applied), this.block && t.canvas && (t.canvas.style.display = "", delete this.block), this.layout && t.element && (t.element.style.position = "", delete this.layout)
        },
        change: function(t) {
            this.uninstall(t), this.install(t)
        }
    }), THREE.Bootstrap.registerPlugin("loop", {
        defaults: {
            start: !0
        },
        listen: ["ready"],
        install: function(t) {
            this.running = !1, t.Loop = this.api({
                start: this.start.bind(this),
                stop: this.stop.bind(this),
                running: !1
            }, t), this.events = ["pre", "update", "render", "post"].map(function(t) {
                return {
                    type: t
                }
            })
        },
        uninstall: function(t) {
            this.stop(t)
        },
        ready: function(t, e) {
            this.options.start && this.start(e)
        },
        start: function(t) {
            if (!this.running) {
                t.Loop.running = this.running = !0;
                var e = t.trigger.bind(t),
                    r = function() {
                        this.running && requestAnimationFrame(r), this.events.map(e)
                    }.bind(this);
                requestAnimationFrame(r), t.trigger({
                    type: "start"
                })
            }
        },
        stop: function(t) {
            this.running && (t.Loop.running = this.running = !1, t.trigger({
                type: "stop"
            }))
        }
    }), THREE.Bootstrap.registerPlugin("time", {
        defaults: {
            speed: 1
        },
        listen: ["pre:tick", "this.change"],
        now: function() {
            return +new Date / 1e3
        },
        install: function(t) {
            t.Time = this.api({
                now: this.now(),
                clock: 0,
                step: 1 / 60,
                frames: 0,
                delta: 1 / 60,
                average: 0,
                fps: 0
            }), this.last = 0, this.clock = 0
        },
        tick: function(t, e) {
            var r = this.options.speed,
                n = e.Time,
                i = n.now = this.now(),
                o = this.last,
                a = this.clock;
            if (o) {
                var s = n.delta = i - o,
                    h = n.average || s,
                    u = s * r;
                a += u, n.frames > 0 && (n.average = h + .1 * (s - h), n.fps = 1 / h), n.step = u, n.clock = a, n.frames++
            }
            this.last = i, this.clock = a
        },
        uninstall: function(t) {
            delete t.Time
        }
    }), THREE.Bootstrap.registerPlugin("scene", {
        install: function(t) {
            t.scene = new THREE.Scene
        },
        uninstall: function(t) {
            delete t.scene
        }
    }), THREE.Bootstrap.registerPlugin("camera", {
        defaults: {
            near: .1,
            far: 1e4,
            type: "perspective",
            fov: 60,
            aspect: null,
            left: -1,
            right: 1,
            bottom: -1,
            top: 1,
            klass: null,
            parameters: null
        },
        listen: ["resize", "this.change"],
        install: function(t) {
            t.Camera = this.api(), t.camera = null, this.aspect = 1, this.change({}, t)
        },
        uninstall: function(t) {
            delete t.Camera, delete t.camera
        },
        change: function(t, e) {
            var r = this.options,
                n = e.camera;
            if (!e.camera || t.changes.type || t.changes.klass) {
                var i = r.klass || {
                    perspective: THREE.PerspectiveCamera,
                    orthographic: THREE.OrthographicCamera
                }[r.type] || THREE.Camera;
                e.camera = r.parameters ? new i(r.parameters) : new i
            }
            _.each(r, function(t, n) {
                e.camera.hasOwnProperty(n) && (e.camera[n] = r[n])
            }.bind(this)), this.update(e), n === e.camera || e.trigger({
                type: "camera",
                camera: e.camera
            })
        },
        resize: function(t, e) {
            this.aspect = t.viewWidth / Math.max(1, t.viewHeight), this.update(e)
        },
        update: function(t) {
            t.camera.aspect = this.options.aspect || this.aspect, t.camera.updateProjectionMatrix()
        }
    }), THREE.Bootstrap.registerPlugin("render", {
        listen: ["render"],
        render: function(t, e) {
            e.scene && e.camera && e.renderer.render(e.scene, e.camera)
        }
    }), THREE.Bootstrap.registerPlugin("warmup", {
        defaults: {
            delay: 2
        },
        listen: ["ready", "post"],
        ready: function(t, e) {
            e.renderer.domElement.style.visibility = "hidden", this.frame = 0, this.hidden = !0
        },
        post: function(t, e) {
            this.hidden && this.frame >= this.options.delay && (e.renderer.domElement.style.visibility = "visible", this.hidden = !1), this.frame++
        }
    }), THREE.Stats = function() {
        var t = Date.now(),
            e = t,
            r = 0,
            n = 1 / 0,
            i = 0,
            o = 0,
            a = 1 / 0,
            s = 0,
            h = 0,
            u = 0,
            l = document.createElement("div");
        l.id = "stats", l.addEventListener("mousedown", function(t) {
            t.preventDefault(), E(++u % 2)
        }, !1), l.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
        var c = document.createElement("div");
        c.id = "fps", c.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", l.appendChild(c);
        var p = document.createElement("div");
        p.id = "fpsText", p.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", p.innerHTML = "FPS", c.appendChild(p);
        var f = document.createElement("div");
        for (f.id = "fpsGraph", f.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", c.appendChild(f); 74 > f.children.length;) {
            var d = document.createElement("span");
            d.style.cssText = "width:1px;height:30px;float:left;background-color:#113", f.appendChild(d)
        }
        var m = document.createElement("div");
        m.id = "ms", m.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", l.appendChild(m);
        var g = document.createElement("div");
        g.id = "msText", g.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", g.innerHTML = "MS", m.appendChild(g);
        var v = document.createElement("div");
        for (v.id = "msGraph", v.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", m.appendChild(v); 74 > v.children.length;) d = document.createElement("span"), d.style.cssText = "width:1px;height:30px;float:left;background-color:#131", v.appendChild(d);
        var E = function(t) {
            switch (u = t) {
                case 0:
                    c.style.display = "block", m.style.display = "none";
                    break;
                case 1:
                    c.style.display = "none", m.style.display = "block"
            }
        };
        return {
            REVISION: 11,
            domElement: l,
            setMode: E,
            begin: function() {
                t = Date.now()
            },
            end: function() {
                var u = Date.now();
                r = u - t, n = Math.min(n, r), i = Math.max(i, r), g.textContent = r + " MS (" + n + "-" + i + ")";
                var l = Math.min(30, 30 - 30 * (r / 200));
                return v.appendChild(v.firstChild).style.height = l + "px", h++, u > e + 1e3 && (o = Math.round(1e3 * h / (u - e)), a = Math.min(a, o), s = Math.max(s, o), p.textContent = o + " FPS (" + a + "-" + s + ")", l = Math.min(30, 30 - 30 * (o / 100)), f.appendChild(f.firstChild).style.height = l + "px", e = u, h = 0), u
            },
            update: function() {
                t = this.end()
            }
        }
    }, THREE.DeviceOrientationControls = function(t) {
        var e = this;
        this.object = t, this.object.rotation.reorder("YXZ"), this.freeze = !0, this.deviceOrientation = {}, this.screenOrientation = 0;
        var r = function(t) {
                e.deviceOrientation = t
            },
            n = function() {
                e.screenOrientation = window.orientation || 0
            },
            i = function() {
                var t = new THREE.Vector3(0, 0, 1),
                    e = new THREE.Euler,
                    r = new THREE.Quaternion,
                    n = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
                return function(i, o, a, s, h) {
                    e.set(a, o, -s, "YXZ"), i.setFromEuler(e), i.multiply(n), i.multiply(r.setFromAxisAngle(t, -h))
                }
            }();
        this.connect = function() {
            n(), window.addEventListener("orientationchange", n, !1), window.addEventListener("deviceorientation", r, !1), e.freeze = !1
        }, this.disconnect = function() {
            e.freeze = !0, window.removeEventListener("orientationchange", n, !1), window.removeEventListener("deviceorientation", r, !1)
        }, this.update = function() {
            if (!e.freeze) {
                var t = e.deviceOrientation.gamma ? THREE.Math.degToRad(e.deviceOrientation.alpha) : 0,
                    r = e.deviceOrientation.beta ? THREE.Math.degToRad(e.deviceOrientation.beta) : 0,
                    n = e.deviceOrientation.gamma ? THREE.Math.degToRad(e.deviceOrientation.gamma) : 0,
                    o = e.screenOrientation ? THREE.Math.degToRad(e.screenOrientation) : 0;
                i(e.object.quaternion, t, r, n, o)
            }
        }
    }, THREE.FirstPersonControls = function(t, e) {
        function r(t, e) {
            return function() {
                e.apply(t, arguments)
            }
        }
        this.object = t, this.target = new THREE.Vector3(0, 0, 0), this.domElement = void 0 !== e ? e : document, this.movementSpeed = 1, this.lookSpeed = .005, this.lookVertical = !0, this.autoForward = !1, this.activeLook = !0, this.heightSpeed = !1, this.heightCoef = 1, this.heightMin = 0, this.heightMax = 1, this.constrainVertical = !1, this.verticalMin = 0, this.verticalMax = Math.PI, this.autoSpeedFactor = 0, this.mouseX = 0, this.mouseY = 0, this.lat = 0, this.lon = 0, this.phi = 0, this.theta = 0, this.moveForward = !1, this.moveBackward = !1, this.moveLeft = !1, this.moveRight = !1, this.freeze = !1, this.mouseDragOn = !1, this.viewHalfX = 0, this.viewHalfY = 0, this.domElement !== document && this.domElement.setAttribute("tabindex", -1), this.handleResize = function() {
            this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, this.viewHalfY = this.domElement.offsetHeight / 2)
        }, this.onMouseDown = function(t) {
            if (this.domElement !== document && this.domElement.focus(), t.preventDefault(), t.stopPropagation(), this.activeLook) switch (t.button) {
                case 0:
                    this.moveForward = !0;
                    break;
                case 2:
                    this.moveBackward = !0
            }
            this.mouseDragOn = !0
        }, this.onMouseUp = function(t) {
            if (t.preventDefault(), t.stopPropagation(), this.activeLook) switch (t.button) {
                case 0:
                    this.moveForward = !1;
                    break;
                case 2:
                    this.moveBackward = !1
            }
            this.mouseDragOn = !1
        }, this.onMouseMove = function(t) {
            this.domElement === document ? (this.mouseX = t.pageX - this.viewHalfX, this.mouseY = t.pageY - this.viewHalfY) : (this.mouseX = t.pageX - this.domElement.offsetLeft - this.viewHalfX, this.mouseY = t.pageY - this.domElement.offsetTop - this.viewHalfY)
        }, this.onKeyDown = function(t) {
            switch (t.keyCode) {
                case 38:
                case 87:
                    this.moveForward = !0;
                    break;
                case 37:
                case 65:
                    this.moveLeft = !0;
                    break;
                case 40:
                case 83:
                    this.moveBackward = !0;
                    break;
                case 39:
                case 68:
                    this.moveRight = !0;
                    break;
                case 82:
                    this.moveUp = !0;
                    break;
                case 70:
                    this.moveDown = !0;
                    break;
                case 81:
                    this.freeze = !this.freeze
            }
        }, this.onKeyUp = function(t) {
            switch (t.keyCode) {
                case 38:
                case 87:
                    this.moveForward = !1;
                    break;
                case 37:
                case 65:
                    this.moveLeft = !1;
                    break;
                case 40:
                case 83:
                    this.moveBackward = !1;
                    break;
                case 39:
                case 68:
                    this.moveRight = !1;
                    break;
                case 82:
                    this.moveUp = !1;
                    break;
                case 70:
                    this.moveDown = !1
            }
        }, this.update = function(t) {
            if (!this.freeze) {
                if (this.heightSpeed) {
                    var e = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax),
                        r = e - this.heightMin;
                    this.autoSpeedFactor = t * r * this.heightCoef
                } else this.autoSpeedFactor = 0;
                var n = t * this.movementSpeed;
                (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(n + this.autoSpeedFactor)), this.moveBackward && this.object.translateZ(n), this.moveLeft && this.object.translateX(-n), this.moveRight && this.object.translateX(n), this.moveUp && this.object.translateY(n), this.moveDown && this.object.translateY(-n);
                var i = t * this.lookSpeed;
                this.activeLook || (i = 0);
                var o = 1;
                this.constrainVertical && (o = Math.PI / (this.verticalMax - this.verticalMin)), this.lon += this.mouseX * i, this.lookVertical && (this.lat -= this.mouseY * i * o), this.lat = Math.max(-85, Math.min(85, this.lat)), this.phi = THREE.Math.degToRad(90 - this.lat), this.theta = THREE.Math.degToRad(this.lon), this.constrainVertical && (this.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax));
                var a = this.target,
                    s = this.object.position;
                a.x = s.x + 100 * Math.sin(this.phi) * Math.cos(this.theta), a.y = s.y + 100 * Math.cos(this.phi), a.z = s.z + 100 * Math.sin(this.phi) * Math.sin(this.theta), this.object.lookAt(a)
            }
        }, this.domElement.addEventListener("contextmenu", function(t) {
            t.preventDefault()
        }, !1), this.domElement.addEventListener("mousemove", r(this, this.onMouseMove), !1), this.domElement.addEventListener("mousedown", r(this, this.onMouseDown), !1), this.domElement.addEventListener("mouseup", r(this, this.onMouseUp), !1), this.domElement.addEventListener("keydown", r(this, this.onKeyDown), !1), this.domElement.addEventListener("keyup", r(this, this.onKeyUp), !1), this.handleResize()
    }, THREE.OrbitControls = function(t, e) {
        function r() {
            return 2 * Math.PI / 60 / 60 * p.autoRotateSpeed
        }

        function n() {
            return Math.pow(.95, p.zoomSpeed)
        }

        function i(t) {
            if (p.enabled !== !1) {
                if (t.preventDefault(), 0 === t.button) {
                    if (p.noRotate === !0) return;
                    k = C.ROTATE, d.set(t.clientX, t.clientY)
                } else if (1 === t.button) {
                    if (p.noZoom === !0) return;
                    k = C.DOLLY, _.set(t.clientX, t.clientY)
                } else if (2 === t.button) {
                    if (p.noPan === !0) return;
                    k = C.PAN, v.set(t.clientX, t.clientY)
                }
                document.documentElement.addEventListener("mousemove", o, !1), document.documentElement.addEventListener("mouseup", a, !1), p.dispatchEvent(D)
            }
        }

        function o(t) {
            if (p.enabled !== !1) {
                t.preventDefault();
                var e = p.domElement === document ? p.domElement.body : p.domElement;
                if (k === C.ROTATE) {
                    if (p.noRotate === !0) return;
                    m.set(t.clientX, t.clientY), g.subVectors(m, d), p.rotateLeft(2 * Math.PI * g.x / e.clientWidth * p.rotateSpeed), p.rotateUp(2 * Math.PI * g.y / e.clientHeight * p.rotateSpeed), d.copy(m)
                } else if (k === C.DOLLY) {
                    if (p.noZoom === !0) return;
                    b.set(t.clientX, t.clientY), R.subVectors(b, _), R.y > 0 ? p.dollyIn() : p.dollyOut(), _.copy(b)
                } else if (k === C.PAN) {
                    if (p.noPan === !0) return;
                    E.set(t.clientX, t.clientY), y.subVectors(E, v), p.pan(y.x, y.y), v.copy(E)
                }
                p.update()
            }
        }

        function a() {
            p.enabled !== !1 && (document.documentElement.removeEventListener("mousemove", o, !1), document.documentElement.removeEventListener("mouseup", a, !1), p.dispatchEvent(F), k = C.NONE)
        }

        function s(t) {
            if (p.enabled !== !1 && p.noZoom !== !0) {
                t.preventDefault(), t.stopPropagation();
                var e = 0;
                void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), e > 0 ? p.dollyOut() : p.dollyIn(), p.update(), p.dispatchEvent(D), p.dispatchEvent(F)
            }
        }

        function h(t) {
            if (p.enabled !== !1 && p.noKeys !== !0 && p.noPan !== !0) switch (t.keyCode) {
                case p.keys.UP:
                    p.pan(0, p.keyPanSpeed), p.update();
                    break;
                case p.keys.BOTTOM:
                    p.pan(0, -p.keyPanSpeed), p.update();
                    break;
                case p.keys.LEFT:
                    p.pan(p.keyPanSpeed, 0), p.update();
                    break;
                case p.keys.RIGHT:
                    p.pan(-p.keyPanSpeed, 0), p.update()
            }
        }

        function u(t) {
            if (p.enabled !== !1) {
                switch (t.touches.length) {
                    case 1:
                        if (p.noRotate === !0) return;
                        k = C.TOUCH_ROTATE, d.set(t.touches[0].pageX, t.touches[0].pageY);
                        break;
                    case 2:
                        if (p.noZoom === !0) return;
                        k = C.TOUCH_DOLLY;
                        var e = t.touches[0].pageX - t.touches[1].pageX,
                            r = t.touches[0].pageY - t.touches[1].pageY,
                            n = Math.sqrt(e * e + r * r);
                        _.set(0, n);
                        break;
                    case 3:
                        if (p.noPan === !0) return;
                        k = C.TOUCH_PAN, v.set(t.touches[0].pageX, t.touches[0].pageY);
                        break;
                    default:
                        k = C.NONE
                }
                p.dispatchEvent(D)
            }
        }

        function l(t) {
            if (p.enabled !== !1) {
                t.preventDefault(), t.stopPropagation();
                var e = p.domElement === document ? p.domElement.body : p.domElement;
                switch (t.touches.length) {
                    case 1:
                        if (p.noRotate === !0) return;
                        if (k !== C.TOUCH_ROTATE) return;
                        m.set(t.touches[0].pageX, t.touches[0].pageY), g.subVectors(m, d), p.rotateLeft(2 * Math.PI * g.x / e.clientWidth * p.rotateSpeed), p.rotateUp(2 * Math.PI * g.y / e.clientHeight * p.rotateSpeed), d.copy(m), p.update();
                        break;
                    case 2:
                        if (p.noZoom === !0) return;
                        if (k !== C.TOUCH_DOLLY) return;
                        var r = t.touches[0].pageX - t.touches[1].pageX,
                            n = t.touches[0].pageY - t.touches[1].pageY,
                            i = Math.sqrt(r * r + n * n);
                        b.set(0, i), R.subVectors(b, _), R.y > 0 ? p.dollyOut() : p.dollyIn(), _.copy(b), p.update();
                        break;
                    case 3:
                        if (p.noPan === !0) return;
                        if (k !== C.TOUCH_PAN) return;
                        E.set(t.touches[0].pageX, t.touches[0].pageY), y.subVectors(E, v), p.pan(y.x, y.y), v.copy(E), p.update();
                        break;
                    default:
                        k = C.NONE
                }
            }
        }

        function c() {
            p.enabled !== !1 && (p.dispatchEvent(F), k = C.NONE)
        }
        this.object = t, this.domElement = void 0 !== e ? e : document, this.enabled = !0, this.target = new THREE.Vector3, this.center = this.target, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.noRotate = !1, this.rotateSpeed = 1, this.noPan = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.noKeys = !1, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        };
        var p = this,
            f = 1e-6,
            d = new THREE.Vector2,
            m = new THREE.Vector2,
            g = new THREE.Vector2,
            v = new THREE.Vector2,
            E = new THREE.Vector2,
            y = new THREE.Vector2,
            T = new THREE.Vector3,
            x = new THREE.Vector3,
            _ = new THREE.Vector2,
            b = new THREE.Vector2,
            R = new THREE.Vector2,
            w = 0,
            H = 0,
            M = 1,
            S = new THREE.Vector3,
            A = new THREE.Vector3,
            C = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            },
            k = C.NONE;
        this.target0 = this.target.clone(), this.position0 = this.object.position.clone();
        var L = (new THREE.Quaternion).setFromUnitVectors(t.up, new THREE.Vector3(0, 1, 0)),
            z = L.clone().inverse(),
            P = {
                type: "change"
            },
            D = {
                type: "start"
            },
            F = {
                type: "end"
            };
        this.rotateLeft = function(t) {
            void 0 === t && (t = r()), H -= t
        }, this.rotateUp = function(t) {
            void 0 === t && (t = r()), w -= t
        }, this.panLeft = function(t) {
            var e = this.object.matrix.elements;
            T.set(e[0], e[1], e[2]), T.multiplyScalar(-t), S.add(T)
        }, this.panUp = function(t) {
            var e = this.object.matrix.elements;
            T.set(e[4], e[5], e[6]), T.multiplyScalar(t), S.add(T)
        }, this.pan = function(t, e) {
            var r = p.domElement === document ? p.domElement.body : p.domElement;
            if (void 0 !== p.object.fov) {
                var n = p.object.position,
                    i = n.clone().sub(p.target),
                    o = i.length();
                o *= Math.tan(p.object.fov / 2 * Math.PI / 180), p.panLeft(2 * t * o / r.clientHeight), p.panUp(2 * e * o / r.clientHeight)
            } else void 0 !== p.object.top ? (p.panLeft(t * (p.object.right - p.object.left) / r.clientWidth), p.panUp(e * (p.object.top - p.object.bottom) / r.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
        }, this.dollyIn = function(t) {
            void 0 === t && (t = n()), M /= t
        }, this.dollyOut = function(t) {
            void 0 === t && (t = n()), M *= t
        }, this.update = function() {
            var t = this.object.position;
            x.copy(t).sub(this.target), x.applyQuaternion(L);
            var e = Math.atan2(x.x, x.z),
                n = Math.atan2(Math.sqrt(x.x * x.x + x.z * x.z), x.y);
            this.autoRotate && this.rotateLeft(r()), e += H, n += w, n = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, n)), n = Math.max(f, Math.min(Math.PI - f, n));
            var i = x.length() * M;
            i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(S), x.x = i * Math.sin(n) * Math.sin(e), x.y = i * Math.cos(n), x.z = i * Math.sin(n) * Math.cos(e), x.applyQuaternion(z), t.copy(this.target).add(x), this.object.lookAt(this.target), H = 0, w = 0, M = 1, S.set(0, 0, 0), A.distanceToSquared(this.object.position) > f && (this.dispatchEvent(P), A.copy(this.object.position))
        }, this.reset = function() {
            k = C.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.update()
        }, this.domElement.addEventListener("contextmenu", function(t) {
            t.preventDefault()
        }, !1), this.domElement.addEventListener("mousedown", i, !1), this.domElement.addEventListener("mousewheel", s, !1), this.domElement.addEventListener("DOMMouseScroll", s, !1), this.domElement.addEventListener("touchstart", u, !1), this.domElement.addEventListener("touchend", c, !1), this.domElement.addEventListener("touchmove", l, !1), window.addEventListener("keydown", h, !1), this.update()
    }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.VRControls = function(t, e) {
        var r = 1e-5,
            n = this.dummy = new THREE.Object3D;
        this.object = t, this.device = new THREE.DeviceOrientationControls(n, e), this.orbit = new THREE.OrbitControls(n, e), this.orbit.target.copy(t.position), this.orbit.target.z += r, this.orbit.rotateSpeed = -.25, this.supported = !1;
        var i = function(t) {
            this.supported = t && t.alpha == +t.alpha, window.removeEventListener("deviceorientation", i, !1)
        }.bind(this);
        window.addEventListener("deviceorientation", i, !1)
    }, THREE.VRControls.prototype.vr = function(t) {
        this.vrstate = t
    }, THREE.VRControls.prototype.update = function(t) {
        var e = !1;
        this.vrstate && this.vrstate.orientation ? (e = !0, this.object.quaternion.copy(this.vrstate.orientation), this.object.position.copy(this.vrstate.position), this.device.object = this.dummy, this.orbit.object = this.dummy) : this.vrstate && this.supported ? (this.device.freeze && this.device.connect(), this.device.object = this.object, this.orbit.object = this.dummy, this.device.update(t)) : (e = !0, this.device.object = this.dummy, this.orbit.object = this.object, this.orbit.update(t)), e && !this.device.freeze && this.device.disconnect()
    }, THREE.Bootstrap.registerPlugin("stats", {
        listen: ["pre", "post"],
        install: function(t) {
            var e = this.stats = new THREE.Stats,
                r = e.domElement.style;
            r.position = "absolute", r.top = r.left = 0, t.element.appendChild(e.domElement), t.stats = e
        },
        uninstall: function(t) {
            document.body.removeChild(this.stats.domElement), delete t.stats
        },
        pre: function() {
            this.stats.begin()
        },
        post: function() {
            this.stats.end()
        }
    }), THREE.Bootstrap.registerPlugin("controls", {
        listen: ["update", "resize", "camera", "this.change"],
        defaults: {
            klass: null,
            parameters: {}
        },
        install: function(t) {
            if (!this.options.klass) throw "Must provide class for `controls.klass`";
            t.controls = null, this._camera = t.camera || new THREE.PerspectiveCamera, this.change(null, t)
        },
        uninstall: function(t) {
            delete t.controls
        },
        change: function(t, e) {
            this.options.klass ? ((!t || t.changes.klass) && (e.controls = new this.options.klass(this._camera, e.renderer.domElement)), _.extend(e.controls, this.options.parameters)) : e.controls = null
        },
        update: function(t, e) {
            var r = e.Time && e.Time.delta || 1 / 60,
                n = e.VR && e.VR.state;
            e.controls.vr && e.controls.vr(n), e.controls.update(r)
        },
        camera: function(t, e) {
            e.controls.object = this._camera = t.camera
        },
        resize: function(t, e) {
            e.controls.handleResize && e.controls.handleResize()
        }
    }), THREE.Bootstrap.registerPlugin("cursor", {
        listen: ["update", "this.change", "install:change", "uninstall:change", "element.mousemove", "vr"],
        defaults: {
            cursor: null,
            hide: !1,
            timeout: 3
        },
        install: function(t) {
            this.timeout = this.options.timeout, this.element = t.element, this.change(null, t)
        },
        uninstall: function(t) {
            delete t.controls
        },
        change: function(t, e) {
            this.applyCursor(e)
        },
        mousemove: function(t, e) {
            this.options.hide && (this.applyCursor(e), this.timeout = +this.options.timeout || 0)
        },
        update: function(t, e) {
            var r = e.Time && e.Time.delta || 1 / 60;
            this.options.hide && (this.timeout -= r, this.timeout < 0 && this.applyCursor(e, "none"))
        },
        vr: function(t, e) {
            this.hide = t.active && !t.hmd.fake, this.applyCursor(e)
        },
        applyCursor: function(t, e) {
            var r = t.controls ? "move" : "";
            e = e || this.options.cursor || r, this.hide && (e = "none"), this.cursor != e && (this.element.style.cursor = e)
        }
    }), THREE.Bootstrap.registerPlugin("fullscreen", {
        defaults: {
            key: "f"
        },
        listen: ["ready", "update"],
        install: function(t) {
            t.Fullscreen = this.api({
                active: !1,
                toggle: this.toggle.bind(this)
            }, t)
        },
        uninstall: function(t) {
            delete t.Fullscreen
        },
        ready: function(t, e) {
            document.body.addEventListener("keypress", function(t) {
                this.options.key && t.charCode == this.options.key.charCodeAt(0) && this.toggle(e)
            }.bind(this));
            var r = function() {
                var t = !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
                e.Fullscreen.active = this.active = t, e.trigger({
                    type: "fullscreen",
                    active: t
                })
            }.bind(this);
            document.addEventListener("fullscreenchange", r, !1), document.addEventListener("webkitfullscreenchange", r, !1), document.addEventListener("mozfullscreenchange", r, !1)
        },
        toggle: function(t) {
            var e = t.canvas,
                r = t.VR && t.VR.active ? {
                    vrDisplay: t.VR.hmd
                } : {};
            this.active ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen && document.mozCancelFullScreen() : e.requestFullScreen ? e.requestFullScreen(r) : e.msRequestFullScreen ? e.msRequestFullscreen(r) : e.webkitRequestFullscreen ? e.webkitRequestFullscreen(r) : e.mozRequestFullScreen && e.mozRequestFullScreen(r)
        }
    }), THREE.Bootstrap.registerPlugin("vr", {
        defaults: {
            mode: "auto",
            device: null,
            fov: 80
        },
        listen: ["window.load", "pre", "render", "resize", "this.change"],
        install: function(t) {
            t.VR = this.api({
                active: !1,
                devices: [],
                hmd: null,
                sensor: null,
                renderer: null,
                state: null
            }, t)
        },
        uninstall: function(t) {
            delete t.VR
        },
        mocks: function(t, e, r) {
            var n = .03,
                i = function(t) {
                    return {
                        left: {
                            x: -n,
                            y: 0,
                            z: 0
                        },
                        right: {
                            x: n,
                            y: 0,
                            z: 0
                        }
                    }[t]
                },
                o = function(n) {
                    var i = t.camera,
                        o = i && i.aspect || 16 / 9,
                        a = (e || i && i.fov || r) / 2,
                        s = 180 * Math.atan(Math.tan(a * Math.PI / 180) * o / 2) / Math.PI,
                        h = a;
                    return {
                        left: {
                            rightDegrees: s,
                            leftDegrees: s,
                            downDegrees: h,
                            upDegrees: h
                        },
                        right: {
                            rightDegrees: s,
                            leftDegrees: s,
                            downDegrees: h,
                            upDegrees: h
                        }
                    }[n]
                },
                a = function() {
                    return {}
                };
            return [{
                fake: !0,
                force: 1,
                deviceId: "emu",
                deviceName: "Emulated",
                getEyeTranslation: i,
                getRecommendedEyeFieldOfView: o
            }, {
                force: 2,
                getState: a
            }]
        },
        load: function(t, e) {
            var r = function(t) {
                this.callback(t, e)
            }.bind(this);
            navigator.getVRDevices ? navigator.getVRDevices().then(r) : navigator.mozGetVRDevices ? navigator.mozGetVRDevices(r) : (console.warn("No native VR support detected."), r(this.mocks(e, this.options.fov, this.defaults.fov), e))
        },
        callback: function(t, e) {
            var r, n, i = window.HMDVRDevice || function() {},
                o = window.PositionSensorVRDevice || function() {};
            t = e.VR.devices = t || e.VR.devices;
            for (var a = this.options.device, s = 0; s < t.length; ++s) {
                var h = t[s];
                if (1 == h.force || h instanceof i) {
                    if (a && a != h.deviceId) continue;
                    r = h;
                    break
                }
            }
            if (r) {
                for (var s = 0; s < t.length; ++s) {
                    var h = t[s];
                    if (2 == h.force || h instanceof o && h.hardwareUnitId == r.hardwareUnitId) {
                        n = h;
                        break
                    }
                }
                this.hookup(r, n, e)
            }
        },
        hookup: function(t, e, r) {
            THREE.VRRenderer || console.log("THREE.VRRenderer not found");
            var n = THREE.VRRenderer || function() {};
            this.renderer = new n(r.renderer, t), this.hmd = t, this.sensor = e, r.VR.renderer = this.renderer, r.VR.hmd = t, r.VR.sensor = e, console.log("THREE.VRRenderer", t.deviceName)
        },
        change: function(t, e) {
            t.changes.device && this.callback(null, e), this.pre(t, e)
        },
        pre: function(t, e) {
            var r = this.active,
                n = this.active = this.renderer && "2d" != this.options.mode;
            if (e.VR.active = n, n && this.sensor) {
                var i = this.sensor.getState();
                e.VR.state = i
            } else e.VR.state = null;
            r != this.active && e.trigger({
                type: "vr",
                active: n,
                hmd: this.hmd,
                sensor: this.sensor
            })
        },
        resize: function() {
            this.active && this.renderer.initialize()
        },
        render: function(t, e) {
            if (e.scene && e.camera) {
                var r = this.active ? this.renderer : e.renderer;
                if (this.last != r && r == e.renderer) {
                    var n = r.devicePixelRatio,
                        i = r.domElement.width / n,
                        o = r.domElement.height / n;
                    r.enableScissorTest(!1), r.setViewport(0, 0, i, o)
                }
                this.last = r, r.render(e.scene, e.camera)
            }
        }
    }), THREE.Bootstrap.registerPlugin("ui", {
        defaults: {
            theme: "white",
            style: ".threestrap-ui { position: absolute; bottom: 5px; right: 5px; float: left; }.threestrap-ui button { border: 0; background: none;  vertical-align: middle; font-weight: bold; } .threestrap-ui .glyphicon { top: 2px; font-weight: bold; } @media (max-width: 640px) { .threestrap-ui button { font-size: 120% } }.threestrap-white button { color: #fff; text-shadow: 0 1px 1px rgba(0, 0, 0, 1), 0 1px 3px rgba(0, 0, 0, 1); }.threestrap-black button { color: #000; text-shadow: 0 0px 1px rgba(255, 255, 255, 1), 0 0px 2px rgba(255, 255, 255, 1), 0 0px 2px rgba(255, 255, 255, 1) }"
        },
        listen: ["fullscreen"],
        markup: function(t, e, r) {
            var n = "//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css";
            location.href.match(/^file:\/\//) && (n = "http://" + n);
            var i = [];
            return t.Fullscreen && i.push('<button class="fullscreen" title="Full Screen"><span class="glyphicon glyphicon-fullscreen"></span></button>'), t.VR && i.push('<button class="vr" title="VR Headset">VR</button>'), '<style type="text/css">@import url("' + n + '"); ' + r + '</style><div class="threestrap-ui threestrap-' + e + '">' + i.join("\n") + "</div>"
        },
        install: function(t) {
            var e = this.ui = document.createElement("div");
            e.innerHTML = this.markup(t, this.options.theme, this.options.style), document.body.appendChild(e);
            var r = this.ui.fullscreen = e.querySelector("button.fullscreen");
            r && t.bind([r, "click:goFullscreen"], this);
            var n = this.ui.vr = e.querySelector("button.vr");
            n && (t.VR.set({
                mode: "2d"
            }), t.bind([n, "click:goVR"], this))
        },
        uninstall: function() {
            document.body.removeChild(ui)
        },
        fullscreen: function(t, e) {
            this.ui.style.display = t.active ? "none" : "block", t.active || e.VR.set({
                mode: "2d"
            })
        },
        goFullscreen: function(t, e) {
            e.Fullscreen && e.Fullscreen.toggle()
        },
        goVR: function(t, e) {
            e.VR && (e.VR.set({
                mode: "auto"
            }), e.Fullscreen.toggle())
        },
        uninstall: function() {
            document.body.removeChild(this.ui)
        }
    }), THREE.VRRenderer = function(t, e) {
        var r = this;
        r.initialize = function() {
            var t = e.getEyeTranslation("left");
            r.halfIPD = new THREE.Vector3(t.x, t.y, t.z).length(), r.fovLeft = e.getRecommendedEyeFieldOfView("left"), r.fovRight = e.getRecommendedEyeFieldOfView("right")
        }, r.FovToNDCScaleOffset = function(t) {
            var e = 2 / (t.leftTan + t.rightTan),
                r = (t.leftTan - t.rightTan) * e * .5,
                n = 2 / (t.upTan + t.downTan),
                i = (t.upTan - t.downTan) * n * .5;
            return {
                scale: [e, n],
                offset: [r, i]
            }
        }, r.FovPortToProjection = function(t, e, n, i, o) {
            n = void 0 === n ? !0 : n, i = void 0 === i ? .01 : i, o = void 0 === o ? 1e4 : o;
            var a = n ? -1 : 1,
                s = t.elements,
                h = r.FovToNDCScaleOffset(e);
            s[0] = h.scale[0], s[1] = 0, s[2] = h.offset[0] * a, s[3] = 0, s[4] = 0, s[5] = h.scale[1], s[6] = -h.offset[1] * a, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = o / (i - o) * -a, s[11] = o * i / (i - o), s[12] = 0, s[13] = 0, s[14] = a, s[15] = 0, t.transpose()
        }, r.FovToProjection = function(t, e, n, i, o) {
            var a = {
                upTan: Math.tan(e.upDegrees * Math.PI / 180),
                downTan: Math.tan(e.downDegrees * Math.PI / 180),
                leftTan: Math.tan(e.leftDegrees * Math.PI / 180),
                rightTan: Math.tan(e.rightDegrees * Math.PI / 180)
            };
            return r.FovPortToProjection(t, a, n, i, o)
        };
        var n = new THREE.Vector3,
            i = new THREE.PerspectiveCamera,
            o = new THREE.PerspectiveCamera;
        r.render = function(e, a) {
            r.FovToProjection(i.projectionMatrix, r.fovLeft, !0, a.near, a.far), r.FovToProjection(o.projectionMatrix, r.fovRight, !0, a.near, a.far), n.set(r.halfIPD, 0, 0), n.applyQuaternion(a.quaternion), i.position.copy(a.position).sub(n), o.position.copy(a.position).add(n), i.quaternion.copy(a.quaternion), o.quaternion.copy(a.quaternion);
            var s = t.devicePixelRatio,
                h = t.domElement.width / 2 / s,
                u = t.domElement.height / s;
            t.enableScissorTest(!0), t.setViewport(0, 0, h, u), t.setScissor(0, 0, h, u), t.render(e, i), t.setViewport(h, 0, h, u), t.setScissor(h, 0, h, u), t.render(e, o)
        }, r.initialize()
    }, THREE.VRControls = function(t, e) {
        var r = 1e-5,
            n = this.dummy = new THREE.Object3D;
        this.object = t, this.device = new THREE.DeviceOrientationControls(n, e), this.orbit = new THREE.OrbitControls(n, e), this.orbit.target.copy(t.position), this.orbit.target.z += r, this.orbit.rotateSpeed = -.25, this.supported = !1;
        var i = function(t) {
            this.supported = t && t.alpha == +t.alpha, window.removeEventListener("deviceorientation", i, !1)
        }.bind(this);
        window.addEventListener("deviceorientation", i, !1)
    }, THREE.VRControls.prototype.vr = function(t) {
        this.vrstate = t
    }, THREE.VRControls.prototype.update = function(t) {
        var e = !1;
        this.vrstate && this.vrstate.orientation ? (e = !0, this.object.quaternion.copy(this.vrstate.orientation), this.object.position.copy(this.vrstate.position), this.device.object = this.dummy, this.orbit.object = this.dummy) : this.vrstate && this.supported ? (this.device.freeze && this.device.connect(), this.device.object = this.object, this.orbit.object = this.dummy, this.device.update(t)) : (e = !0, this.device.object = this.dummy, this.orbit.object = this.object, this.orbit.update(t)), e && !this.device.freeze && this.device.disconnect()
    }, THREE.OrbitControls = function(t, e) {
        function r() {
            return 2 * Math.PI / 60 / 60 * p.autoRotateSpeed
        }

        function n() {
            return Math.pow(.95, p.zoomSpeed)
        }

        function i(t) {
            if (p.enabled !== !1) {
                if (t.preventDefault(), 0 === t.button) {
                    if (p.noRotate === !0) return;
                    k = C.ROTATE, d.set(t.clientX, t.clientY)
                } else if (1 === t.button) {
                    if (p.noZoom === !0) return;
                    k = C.DOLLY, _.set(t.clientX, t.clientY)
                } else if (2 === t.button) {
                    if (p.noPan === !0) return;
                    k = C.PAN, v.set(t.clientX, t.clientY)
                }
                document.documentElement.addEventListener("mousemove", o, !1), document.documentElement.addEventListener("mouseup", a, !1), p.dispatchEvent(D)
            }
        }

        function o(t) {
            if (p.enabled !== !1) {
                t.preventDefault();
                var e = p.domElement === document ? p.domElement.body : p.domElement;
                if (k === C.ROTATE) {
                    if (p.noRotate === !0) return;
                    m.set(t.clientX, t.clientY), g.subVectors(m, d), p.rotateLeft(2 * Math.PI * g.x / e.clientWidth * p.rotateSpeed), p.rotateUp(2 * Math.PI * g.y / e.clientHeight * p.rotateSpeed), d.copy(m)
                } else if (k === C.DOLLY) {
                    if (p.noZoom === !0) return;
                    b.set(t.clientX, t.clientY), R.subVectors(b, _), R.y > 0 ? p.dollyIn() : p.dollyOut(), _.copy(b)
                } else if (k === C.PAN) {
                    if (p.noPan === !0) return;
                    E.set(t.clientX, t.clientY), y.subVectors(E, v), p.pan(y.x, y.y), v.copy(E)
                }
                p.update()
            }
        }

        function a() {
            p.enabled !== !1 && (document.documentElement.removeEventListener("mousemove", o, !1), document.documentElement.removeEventListener("mouseup", a, !1), p.dispatchEvent(F), k = C.NONE)
        }

        function s(t) {
            if (p.enabled !== !1 && p.noZoom !== !0) {
                t.preventDefault(), t.stopPropagation();
                var e = 0;
                void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), e > 0 ? p.dollyOut() : p.dollyIn(), p.update(), p.dispatchEvent(D), p.dispatchEvent(F)
            }
        }

        function h(t) {
            if (p.enabled !== !1 && p.noKeys !== !0 && p.noPan !== !0) switch (t.keyCode) {
                case p.keys.UP:
                    p.pan(0, p.keyPanSpeed), p.update();
                    break;
                case p.keys.BOTTOM:
                    p.pan(0, -p.keyPanSpeed), p.update();
                    break;
                case p.keys.LEFT:
                    p.pan(p.keyPanSpeed, 0), p.update();
                    break;
                case p.keys.RIGHT:
                    p.pan(-p.keyPanSpeed, 0), p.update()
            }
        }

        function u(t) {
            if (p.enabled !== !1) {
                switch (t.touches.length) {
                    case 1:
                        if (p.noRotate === !0) return;
                        k = C.TOUCH_ROTATE, d.set(t.touches[0].pageX, t.touches[0].pageY);
                        break;
                    case 2:
                        if (p.noZoom === !0) return;
                        k = C.TOUCH_DOLLY;
                        var e = t.touches[0].pageX - t.touches[1].pageX,
                            r = t.touches[0].pageY - t.touches[1].pageY,
                            n = Math.sqrt(e * e + r * r);
                        _.set(0, n);
                        break;
                    case 3:
                        if (p.noPan === !0) return;
                        k = C.TOUCH_PAN, v.set(t.touches[0].pageX, t.touches[0].pageY);
                        break;
                    default:
                        k = C.NONE
                }
                p.dispatchEvent(D)
            }
        }

        function l(t) {
            if (p.enabled !== !1) {
                t.preventDefault(), t.stopPropagation();
                var e = p.domElement === document ? p.domElement.body : p.domElement;
                switch (t.touches.length) {
                    case 1:
                        if (p.noRotate === !0) return;
                        if (k !== C.TOUCH_ROTATE) return;
                        m.set(t.touches[0].pageX, t.touches[0].pageY), g.subVectors(m, d), p.rotateLeft(2 * Math.PI * g.x / e.clientWidth * p.rotateSpeed), p.rotateUp(2 * Math.PI * g.y / e.clientHeight * p.rotateSpeed), d.copy(m), p.update();
                        break;
                    case 2:
                        if (p.noZoom === !0) return;
                        if (k !== C.TOUCH_DOLLY) return;
                        var r = t.touches[0].pageX - t.touches[1].pageX,
                            n = t.touches[0].pageY - t.touches[1].pageY,
                            i = Math.sqrt(r * r + n * n);
                        b.set(0, i), R.subVectors(b, _), R.y > 0 ? p.dollyOut() : p.dollyIn(), _.copy(b), p.update();
                        break;
                    case 3:
                        if (p.noPan === !0) return;
                        if (k !== C.TOUCH_PAN) return;
                        E.set(t.touches[0].pageX, t.touches[0].pageY), y.subVectors(E, v), p.pan(y.x, y.y), v.copy(E), p.update();
                        break;
                    default:
                        k = C.NONE
                }
            }
        }

        function c() {
            p.enabled !== !1 && (p.dispatchEvent(F), k = C.NONE)
        }
        this.object = t, this.domElement = void 0 !== e ? e : document, this.enabled = !0, this.target = new THREE.Vector3, this.center = this.target, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.noRotate = !1, this.rotateSpeed = 1, this.noPan = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.noKeys = !1, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        };
        var p = this,
            f = 1e-6,
            d = new THREE.Vector2,
            m = new THREE.Vector2,
            g = new THREE.Vector2,
            v = new THREE.Vector2,
            E = new THREE.Vector2,
            y = new THREE.Vector2,
            T = new THREE.Vector3,
            x = new THREE.Vector3,
            _ = new THREE.Vector2,
            b = new THREE.Vector2,
            R = new THREE.Vector2,
            w = 0,
            H = 0,
            M = 1,
            S = new THREE.Vector3,
            A = new THREE.Vector3,
            C = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            },
            k = C.NONE;
        this.target0 = this.target.clone(), this.position0 = this.object.position.clone();
        var L = (new THREE.Quaternion).setFromUnitVectors(t.up, new THREE.Vector3(0, 1, 0)),
            z = L.clone().inverse(),
            P = {
                type: "change"
            },
            D = {
                type: "start"
            },
            F = {
                type: "end"
            };
        this.rotateLeft = function(t) {
            void 0 === t && (t = r()), H -= t
        }, this.rotateUp = function(t) {
            void 0 === t && (t = r()), w -= t
        }, this.panLeft = function(t) {
            var e = this.object.matrix.elements;
            T.set(e[0], e[1], e[2]), T.multiplyScalar(-t), S.add(T)
        }, this.panUp = function(t) {
            var e = this.object.matrix.elements;
            T.set(e[4], e[5], e[6]), T.multiplyScalar(t), S.add(T)
        }, this.pan = function(t, e) {
            var r = p.domElement === document ? p.domElement.body : p.domElement;
            if (void 0 !== p.object.fov) {
                var n = p.object.position,
                    i = n.clone().sub(p.target),
                    o = i.length();
                o *= Math.tan(p.object.fov / 2 * Math.PI / 180), p.panLeft(2 * t * o / r.clientHeight), p.panUp(2 * e * o / r.clientHeight)
            } else void 0 !== p.object.top ? (p.panLeft(t * (p.object.right - p.object.left) / r.clientWidth), p.panUp(e * (p.object.top - p.object.bottom) / r.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
        }, this.dollyIn = function(t) {
            void 0 === t && (t = n()), M /= t
        }, this.dollyOut = function(t) {
            void 0 === t && (t = n()), M *= t
        }, this.update = function() {
            var t = this.object.position;
            x.copy(t).sub(this.target), x.applyQuaternion(L);
            var e = Math.atan2(x.x, x.z),
                n = Math.atan2(Math.sqrt(x.x * x.x + x.z * x.z), x.y);
            this.autoRotate && this.rotateLeft(r()), e += H, n += w, n = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, n)), n = Math.max(f, Math.min(Math.PI - f, n));
            var i = x.length() * M;
            i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(S), x.x = i * Math.sin(n) * Math.sin(e), x.y = i * Math.cos(n), x.z = i * Math.sin(n) * Math.cos(e), x.applyQuaternion(z), t.copy(this.target).add(x), this.object.lookAt(this.target), H = 0, w = 0, M = 1, S.set(0, 0, 0), A.distanceToSquared(this.object.position) > f && (this.dispatchEvent(P), A.copy(this.object.position))
        }, this.reset = function() {
            k = C.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.update()
        }, this.domElement.addEventListener("contextmenu", function(t) {
            t.preventDefault()
        }, !1), this.domElement.addEventListener("mousedown", i, !1), this.domElement.addEventListener("mousewheel", s, !1), this.domElement.addEventListener("DOMMouseScroll", s, !1), this.domElement.addEventListener("touchstart", u, !1), this.domElement.addEventListener("touchend", c, !1), this.domElement.addEventListener("touchmove", l, !1), window.addEventListener("keydown", h, !1), this.update()
    }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.DeviceOrientationControls = function(t) {
        var e = this;
        this.object = t, this.object.rotation.reorder("YXZ"), this.freeze = !0, this.deviceOrientation = {}, this.screenOrientation = 0;
        var r = function(t) {
                e.deviceOrientation = t
            },
            n = function() {
                e.screenOrientation = window.orientation || 0
            },
            i = function() {
                var t = new THREE.Vector3(0, 0, 1),
                    e = new THREE.Euler,
                    r = new THREE.Quaternion,
                    n = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
                return function(i, o, a, s, h) {
                    e.set(a, o, -s, "YXZ"), i.setFromEuler(e), i.multiply(n), i.multiply(r.setFromAxisAngle(t, -h))
                }
            }();
        this.connect = function() {
            n(), window.addEventListener("orientationchange", n, !1), window.addEventListener("deviceorientation", r, !1), e.freeze = !1
        }, this.disconnect = function() {
            e.freeze = !0, window.removeEventListener("orientationchange", n, !1), window.removeEventListener("deviceorientation", r, !1)
        }, this.update = function() {
            if (!e.freeze) {
                var t = e.deviceOrientation.gamma ? THREE.Math.degToRad(e.deviceOrientation.alpha) : 0,
                    r = e.deviceOrientation.beta ? THREE.Math.degToRad(e.deviceOrientation.beta) : 0,
                    n = e.deviceOrientation.gamma ? THREE.Math.degToRad(e.deviceOrientation.gamma) : 0,
                    o = e.screenOrientation ? THREE.Math.degToRad(e.screenOrientation) : 0;
                i(e.object.quaternion, t, r, n, o)
            }
        }
    },
    function t(e, r, n) {
        function i(a, s) {
            if (!r[a]) {
                if (!e[a]) {
                    var h = "function" == typeof require && require;
                    if (!s && h) return h(a, !0);
                    if (o) return o(a, !0);
                    throw new Error("Cannot find module '" + a + "'")
                }
                var u = r[a] = {
                    exports: {}
                };
                e[a][0].call(u.exports, function(t) {
                    var r = e[a][1][t];
                    return i(r ? r : t)
                }, u, u.exports, t, e, r, n)
            }
            return r[a].exports
        }
        for (var o = "function" == typeof require && require, a = 0; a < n.length; a++) i(n[a]);
        return i
    }({
        1: [function(t, e) {
            var r;
            r = function() {
                function t(e, r) {
                    this.parent = null != r ? r : null, this.id = t.id(), this.nodes = [], e && this.add(e)
                }
                return t.index = 0, t.id = function() {
                    return ++t.index
                }, t.IN = 0, t.OUT = 1, t.prototype.inputs = function() {
                    var t, e, r, n, i, o, a, s, h;
                    for (t = [], s = this.nodes, n = 0, o = s.length; o > n; n++)
                        for (e = s[n], h = e.inputs, i = 0, a = h.length; a > i; i++) r = h[i], null === r.input && t.push(r);
                    return t
                }, t.prototype.outputs = function() {
                    var t, e, r, n, i, o, a, s, h;
                    for (r = [], s = this.nodes, n = 0, o = s.length; o > n; n++)
                        for (t = s[n], h = t.outputs, i = 0, a = h.length; a > i; i++) e = h[i], 0 === e.output.length && r.push(e);
                    return r
                }, t.prototype.getIn = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.inputs(), o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.getOut = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.outputs(), o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.add = function(t, e) {
                    var r, n, i; {
                        if (!t.length) {
                            if (t.graph && !e) throw "Adding node to two graphs at once";
                            return t.graph = this, this.nodes.push(t)
                        }
                        for (r = 0, n = t.length; n > r; r++) i = t[r], this.add(i)
                    }
                }, t.prototype.remove = function(t, e) {
                    var r, n, i; {
                        if (!t.length) {
                            if (t.graph !== this) throw "Removing node from wrong graph.";
                            return e || t.disconnect(), this.nodes.splice(this.nodes.indexOf(t), 1), t.graph = null
                        }
                        for (r = 0, n = t.length; n > r; r++) i = t[r], this.remove(i)
                    }
                }, t.prototype.adopt = function(t) {
                    var e, r, n; {
                        if (!t.length) return t.graph.remove(t, !0), this.add(t, !0);
                        for (e = 0, r = t.length; r > e; e++) n = t[e], this.adopt(n)
                    }
                }, t
            }(), e.exports = r
        }, {}],
        2: [function(t, e, r) {
            r.Graph = t("./graph"), r.Node = t("./node"), r.Outlet = t("./outlet"), r.IN = r.Graph.IN, r.OUT = r.Graph.OUT
        }, {
            "./graph": 1,
            "./node": 3,
            "./outlet": 4
        }],
        3: [function(t, e) {
            var r, n, i;
            r = t("./graph"), i = t("./outlet"), n = function() {
                function t(e, r) {
                    this.owner = e, this.graph = null, this.inputs = [], this.outputs = [], this.outlets = null, this.id = t.id(), this.setOutlets(r)
                }
                return t.index = 0, t.id = function() {
                    return ++t.index
                }, t.prototype.getIn = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.inputs, o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.getOut = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.outputs, o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.get = function(t) {
                    return this.getIn(t) || this.getOut(t)
                }, t.prototype.setOutlets = function(t) {
                    var e, r, n, o, a, s, h, u, l, c, p, f, d;
                    if (o = function(t) {
                            return new i(t.inout, t.name, t.hint, t.type, t.meta)
                        }, null != t) {
                        if (null == this.outlets) {
                            for (this.outlets = {}, h = 0, c = t.length; c > h; h++) s = t[h], this._add(o(s));
                            return
                        }
                        for (r = function(t) {
                                return [t.name, t.inout, t.type].join("-")
                            }, a = {}, u = 0, p = t.length; p > u; u++) s = t[u], a[r(s)] = !0;
                        d = this.outlets;
                        for (n in d) s = d[n], n = r(s), a[n] ? a[n] = s : this._remove(s);
                        for (l = 0, f = t.length; f > l; l++) s = t[l], e = a[r(s)], e instanceof i ? this._morph(e, s) : this._add(o(s))
                    }
                    return this.outlets
                }, t.prototype.connect = function(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d;
                    for (s = {}, i = {}, f = t.inputs, u = 0, c = f.length; c > u; u++) a = f[u], (r || !a.input) && (h = a.type, n = [h, a.hint].join("-"), i[n] || (i[n] = a), s[h] = s[h] || [], s[h].push(a));
                    for (d = this.outputs, l = 0, p = d.length; p > l; l++) a = d[l], e && a.output.length || (h = a.type, n = [h, a.hint].join("-"), o = s[h], i[n] ? (i[n].connect(a), delete i[n], o.splice(o.indexOf(a), 1)) : o && o.length && o.shift().connect(a));
                    return this
                }, t.prototype.disconnect = function() {
                    var t, e, r, n, i, o, a;
                    for (o = this.inputs, e = 0, n = o.length; n > e; e++) t = o[e], t.disconnect();
                    for (a = this.outputs, r = 0, i = a.length; i > r; r++) t = a[r], t.disconnect();
                    return this
                }, t.prototype._key = function(t) {
                    return [t.name, t.inout].join("-")
                }, t.prototype._add = function(t) {
                    var e;
                    if (e = this._key(t), t.node) throw "Adding outlet to two nodes at once.";
                    if (this.outlets[e]) throw "Adding two identical outlets to same node. (" + e + ")";
                    return t.node = this, t.inout === r.IN && this.inputs.push(t), t.inout === r.OUT && this.outputs.push(t), this.outlets[e] = t
                }, t.prototype._morph = function(t, e) {
                    var r;
                    return r = this._key(e), delete this.outlets[r], t.morph(e), r = this._key(e), this.outlets[r] = e
                }, t.prototype._remove = function(t) {
                    var e, n;
                    if (n = this._key(t), e = t.inout, t.node !== this) throw "Removing outlet from wrong node.";
                    return t.disconnect(), t.node = null, delete this.outlets[n], t.inout === r.IN && this.inputs.splice(this.inputs.indexOf(t), 1), t.inout === r.OUT && this.outputs.splice(this.outputs.indexOf(t), 1), this
                }, t
            }(), e.exports = n
        }, {
            "./graph": 1,
            "./outlet": 4
        }],
        4: [function(t, e) {
            var r, n;
            r = t("./graph"), n = function() {
                function t(e, r, n, i, o) {
                    this.inout = e, this.name = r, this.hint = n, this.type = i, this.meta = o, null == this.hint && (this.hint = t.hint(r)), this.node = null, this.input = null, this.output = [], this.id = t.id(this.hint)
                }
                return t.index = 0, t.id = function(e) {
                    return "_io_" + ++t.index + "_" + e
                }, t.hint = function(t) {
                    return t = t.replace(/^(_io_[0-9]+_)/, ""), t = t.replace(/(In|Out|Inout|InOut)$/, "")
                }, t.prototype.morph = function(t) {
                    return this.inout = t.inout, this.name = t.name, this.hint = t.hint, this.type = t.type, this.meta = t.meta
                }, t.prototype.dupe = function(t) {
                    var e, r, n, i;
                    return null == t && (t = this.id), r = this.inout, e = this.hint, i = this.type, n = this.meta, {
                        inout: r,
                        hint: e,
                        type: i,
                        meta: n,
                        name: t
                    }
                }, t.prototype.connect = function(t) {
                    if (this.inout === r.IN && t.inout === r.OUT) return t.connect(this);
                    if (this.inout !== r.OUT || t.inout !== r.IN) throw "Can only connect out to in.";
                    if (t.input !== this) return t.disconnect(), t.input = this, this.output.push(t)
                }, t.prototype.disconnect = function(t) {
                    var e, r, n, i;
                    if (this.input && this.input.disconnect(this), this.output.length) {
                        if (!t) {
                            for (i = this.output, r = 0, n = i.length; n > r; r++) t = i[r], t.input = null;
                            return this.output = []
                        }
                        if (e = this.output.indexOf(t), e >= 0) return this.output.splice(e, 1), t.input = null
                    }
                }, t
            }(), e.exports = n
        }, {
            "./graph": 1
        }],
        5: [function(t, e) {
            var r, n, i, o, a;
            n = t("../graph"), o = t("../linker").Program, i = t("../linker").Layout, a = !1, r = function() {
                function t() {
                    var t;
                    null == this.namespace && (this.namespace = o.entry()), this.node = new n.Node(this, null != (t = "function" == typeof this.makeOutlets ? this.makeOutlets() : void 0) ? t : {})
                }
                return t.previous = function(t) {
                    var e;
                    return null != (e = t.input) ? e.node.owner : void 0
                }, t.prototype.refresh = function() {
                    var t;
                    return this.node.setOutlets(null != (t = "function" == typeof this.makeOutlets ? this.makeOutlets() : void 0) ? t : {})
                }, t.prototype.clone = function() {
                    return new t
                }, t.prototype.compile = function(t, e) {
                    var r;
                    return r = new o(t, null != e ? e : o.entry()), this.call(r, 0), r.assemble()
                }, t.prototype.link = function(t, e) {
                    var r, n;
                    return n = this.compile(t, e), r = new i(t), this._include(n, r, 0), this["export"](r, 0), r.link(n)
                }, t.prototype.call = function() {}, t.prototype.callback = function() {}, t.prototype["export"] = function() {}, t.prototype._call = function(t, e, r) {
                    return e.call(this.node, t, r)
                }, t.prototype._inputs = function(e, r, n) {
                    var i, o, a, s, h, u, l;
                    for (h = e.main.signature, l = [], a = 0, s = h.length; s > a; a++) i = h[a], o = this.node.get(i.name), l.push(null != (u = t.previous(o)) ? u.call(r, n + 1) : void 0);
                    return l
                }, t.prototype._callback = function(t, e, r, n, i, o) {
                    return e.callback(this.node, t, r, n, i, o)
                }, t.prototype._include = function(t, e, r) {
                    return e.include(this.node, t, r)
                }, t.prototype._link = function(e, r, n) {
                    var i, o, s, h, u, l, c;
                    a && console.log("block::_link", this.toString(), e.namespace), h = e.externals, c = [];
                    for (o in h) i = h[o], s = this.node.get(i.name), a && console.log("callback -> ", this.toString(), i.name, s), null != (u = t.previous(s)) && u.callback(r, n + 1, o, i, s.input), c.push(null != (l = t.previous(s)) ? l["export"](r, n + 1) : void 0);
                    return c
                }, t.prototype._trace = function(e, r, n) {
                    var i, o, s, h, u, l, c;
                    for (a && console.log("block::_trace", this.toString(), e.namespace), u = e.main.signature, c = [], s = 0, h = u.length; h > s; s++) i = u[s], o = this.node.get(i.name), c.push(null != (l = t.previous(o)) ? l["export"](r, n + 1) : void 0);
                    return c
                }, t
            }(), e.exports = r
        }, {
            "../graph": 25,
            "../linker": 30
        }],
        6: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./block"), n = function(t) {
                function e(t) {
                    this.snippet = t, this.namespace = this.snippet.namespace, e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.prototype.clone = function() {
                    return new e(this.snippet)
                }, e.prototype.makeOutlets = function() {
                    var t, e, r, n;
                    r = [], r = r.concat(this.snippet.main.signature), n = this.snippet.externals;
                    for (e in n) t = n[e], r.push(t);
                    return r
                }, e.prototype.call = function(t, e) {
                    return this._call(this.snippet, t, e), this._inputs(this.snippet, t, e)
                }, e.prototype["export"] = function(t, e) {
                    return t.visit(this.namespace, e) ? (this._link(this.snippet, t, e), this._trace(this.snippet, t, e)) : void 0
                }, e
            }(r), e.exports = n
        }, {
            "./block": 5
        }],
        7: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("../graph"), r = t("./block"), o = function(t) {
                return "(" === t.type[0]
            }, n = function(t) {
                function e(t) {
                    this.graph = t, e.__super__.constructor.apply(this, arguments)
                }
                return s(e, t), e.prototype.refresh = function() {
                    return e.__super__.refresh.apply(this, arguments), delete this.subroutine
                }, e.prototype.clone = function() {
                    return new e(this.graph)
                }, e.prototype.makeOutlets = function() {
                    var t, e, r, n, a, s, h, u, l, c, p, f;
                    for (n = [], e = [], a = [], t = function() {
                            return function(t, e) {
                                return o(t) ? t.inout === i.IN ? n.push(t.dupe(t.name)) : void 0 : e.push(t.type)
                            }
                        }(this), p = this.graph.inputs(), h = 0, l = p.length; l > h; h++) r = p[h], t(r, e);
                    for (f = this.graph.outputs(), u = 0, c = f.length; c > u; u++) r = f[u], t(r, a);
                    return e = e.join(","), a = a.join(","), s = "(" + e + ")(" + a + ")", n.push({
                        name: "callback",
                        type: s,
                        inout: i.OUT
                    }), n
                }, e.prototype.make = function() {
                    return this.subroutine = this.graph.compile(this.namespace)
                }, e.prototype.fetch = function() {
                    return null == this.subroutine && this.make(), this.subroutine
                }, e.prototype["export"] = function(t, e) {
                    return t.visit(this.namespace, e) ? (null == this.subroutine && this.make(), this._link(this.subroutine, t, e), this.graph["export"](t, e)) : void 0
                }, e.prototype.callback = function(t, e, r, n, i) {
                    return null == this.subroutine && this.make(), this._include(this.subroutine, t, e), this._callback(this.subroutine, t, e, r, n, i)
                }, e
            }(r), e.exports = n
        }, {
            "../graph": 25,
            "./block": 5
        }],
        8: [function(t, e, r) {
            r.Block = t("./block"), r.Call = t("./call"), r.Callback = t("./callback"), r.Isolate = t("./isolate"), r.Join = t("./join")
        }, {
            "./block": 5,
            "./call": 6,
            "./callback": 7,
            "./isolate": 9,
            "./join": 10
        }],
        9: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../graph"), r = t("./block"), o = function(t) {
                return "(" === t.type[0]
            }, i = function(t) {
                function e(t) {
                    this.graph = t, e.__super__.constructor.apply(this, arguments)
                }
                return s(e, t), e.prototype.refresh = function() {
                    return e.__super__.refresh.apply(this, arguments), delete this.subroutine
                }, e.prototype.clone = function() {
                    return new e(this.graph)
                }, e.prototype.makeOutlets = function() {
                    var t, e, r, n, i, a, s, h, u, l, c;
                    for (n = [], e = null, l = ["inputs", "outputs"], a = 0, h = l.length; h > a; a++)
                        for (i = l[a], c = this.graph[i](), s = 0, u = c.length; u > s; s++) r = c[s], t = void 0, "return" === r.hint && (t = "return"), o(r) && (t = r.name), n.push(r.dupe(t));
                    return n
                }, e.prototype.make = function() {
                    return this.subroutine = this.graph.compile(this.namespace)
                }, e.prototype.fetch = function(t) {
                    return t = t.inout === n.IN ? this.graph.getIn(t.name) : this.graph.getOut(t.name), null != t ? t.node.owner.fetch(t) : void 0
                }, e.prototype.call = function(t, e) {
                    return null == this.subroutine && this.make(), this._call(this.subroutine, t, e), this._inputs(this.subroutine, t, e)
                }, e.prototype["export"] = function(t, e) {
                    var r, i, a, s, h, u, l;
                    if (t.visit(this.namespace, e)) {
                        for (null == this.subroutine && this.make(), this._link(this.subroutine, t, e), this._trace(this.subroutine, t, e), this.graph["export"](t, e), r = this.subroutine.externals, u = this.node.inputs, l = [], s = 0, h = u.length; h > s; s++) a = u[s], o(a) && a.inout === n.IN && null != a.input && null == r[a.name] && (i = this.fetch(a), t.visit(i.namespace + "__shadow", e) && l.push(this._link(i, t, e)));
                        return l
                    }
                }, e.prototype.callback = function(t, e, r, n, i) {
                    var o;
                    return o = this.fetch(i), this._include(o, t, e), this._callback(o, t, e, r, n, i)
                }, e
            }(r), e.exports = i
        }, {
            "../graph": 25,
            "./block": 5
        }],
        10: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./block"), n = function(t) {
                function e(t) {
                    this.nodes = t, e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.prototype.clone = function() {
                    return new e(this.nodes)
                }, e.prototype.makeOutlets = function() {
                    return []
                }, e.prototype.call = function(t, e) {
                    var r, n, i, o, a, s;
                    for (a = this.nodes, s = [], i = 0, o = a.length; o > i; i++) n = a[i], r = n.owner, s.push(r.call(t, e));
                    return s
                }, e.prototype["export"] = function(t, e) {
                    var r, n, i, o, a, s;
                    for (a = this.nodes, s = [], i = 0, o = a.length; o > i; i++) n = a[i], r = n.owner, s.push(r["export"](t, e));
                    return s
                }, e
            }(r), e.exports = n
        }, {
            "./block": 5
        }],
        11: [function(t, e) {
            var r, n, i;
            i = t("./queue"), n = t("./hash"), r = function(t) {
                var e, r;
                return e = {}, r = i(100),
                    function(i) {
                        var o, a;
                        return a = i.length > 32 ? "##" + n(i).toString(16) : i, o = r(a), null != o && delete e[o], null == e[a] && (e[a] = t(i)), e[a].clone()
                    }
            }, e.exports = r
        }, {
            "./hash": 13,
            "./queue": 17
        }],
        12: [function(t, e) {
            var r, n, i, o, a;
            i = t("../graph").Graph, r = t("../block"), a = t("../visualize"), n = function() {
                function t(t, e, r) {
                    this.language = t, this.fetch = e, this.config = r, this.graph()
                }
                return t.prototype.pipe = function(e, r, n, i) {
                    return e instanceof t ? this._concat(e) : this._call(e, r, n, i), this
                }, t.prototype.call = function(t, e, r, n) {
                    return this.pipe(t, e, r, n)
                }, t.prototype.require = function(e, r, n, i) {
                    return e instanceof t ? this._import(e) : (this.callback(), this._call(e, r, n, i), this.join()), this
                }, t.prototype["import"] = function(t, e, r, n) {
                    return this.require(t, e, r, n)
                }, t.prototype.split = function() {
                    return this._group("_combine", !0), this
                }, t.prototype.fan = function() {
                    return this._group("_combine", !1), this
                }, t.prototype.isolate = function() {
                    return this._group("_isolate"), this
                }, t.prototype.callback = function() {
                    return this._group("_callback"), this
                }, t.prototype.next = function() {
                    return this._next(), this
                }, t.prototype.pass = function() {
                    var t;
                    return t = this._stack[2].end, this.join(), this._state.end = this._state.end.concat(t), this
                }, t.prototype.end = function() {
                    var t, e, r, n;
                    return n = this._exit(), r = n[0], t = n[1], e = r.op, this[e] && this[e](r, t), this
                }, t.prototype.join = function() {
                    return this.end()
                }, t.prototype.graph = function() {
                    for (var t, e;
                        (null != (e = this._stack) ? e.length : void 0) > 1;) this.join();
                    return this._graph && this._tail(this._state, this._graph), t = this._graph, this._graph = new i, this._state = new o, this._stack = [this._state], t
                }, t.prototype.compile = function(t) {
                    return null == t && (t = "main"), this.graph().compile(t)
                }, t.prototype.link = function(t) {
                    return null == t && (t = "main"), this.graph().link(t)
                }, t.prototype.serialize = function() {
                    return a.serialize(this._graph)
                }, t.prototype._concat = function(t) {
                    var e;
                    return e = new r.Isolate(t._graph), this._tail(t._state, t._graph), this._auto(e), this
                }, t.prototype._import = function(t) {
                    var e;
                    return e = new r.Callback(t._graph), this._tail(t._state, t._graph), this._auto(e), this
                }, t.prototype._combine = function(t, e) {
                    var r, n, i, o, a, s, h, u;
                    for (h = t.start, i = 0, a = h.length; a > i; i++)
                        for (n = h[i], u = e.end, o = 0, s = u.length; s > o; o++) r = u[o], r.connect(n, t.empty);
                    return e.end = t.end, e.nodes = e.nodes.concat(t.nodes)
                }, t.prototype._isolate = function(t) {
                    var e, n;
                    return t.nodes.length ? (n = this._subgraph(t), e = new r.Isolate(n), this._tail(t, n), this._auto(e)) : void 0
                }, t.prototype._callback = function(t) {
                    var e, n;
                    return t.nodes.length ? (n = this._subgraph(t), e = new r.Callback(n), this._tail(t, n), this._auto(e)) : void 0
                }, t.prototype._call = function(t, e, n, i) {
                    var o, a;
                    return a = this.fetch(t), a.bind(this.config, e, n, i), o = new r.Call(a), this._auto(o)
                }, t.prototype._subgraph = function(t) {
                    var e;
                    return e = new i, e.adopt(t.nodes), e
                }, t.prototype._tail = function(t, e) {
                    var n;
                    if (n = t.end.concat(t.tail), n = n.filter(function(t, e) {
                            return n.indexOf(t) === e
                        }), n.length > 1 && (n = new r.Join(n), n = [n.node]), e.tail = n[0], t.end = n, t.tail = [], !e.tail) throw "Cannot finalize empty graph";
                    return e.compile = function(t) {
                        return function(r) {
                            return null == r && (r = "main"), e.tail.owner.compile(t.language, r)
                        }
                    }(this), e.link = function(t) {
                        return function(r) {
                            return null == r && (r = "main"), e.tail.owner.link(t.language, r)
                        }
                    }(this), e["export"] = function() {
                        return function(t, r) {
                            return e.tail.owner["export"](t, r)
                        }
                    }(this)
                }, t.prototype._group = function(t, e) {
                    return this._push(t, e), this._push(), this
                }, t.prototype._next = function() {
                    var t;
                    return t = this._pop(), this._state.start = this._state.start.concat(t.start), this._state.end = this._state.end.concat(t.end), this._state.nodes = this._state.nodes.concat(t.nodes), this._state.tail = this._state.tail.concat(t.tail), this._push()
                }, t.prototype._exit = function() {
                    return this._next(), this._pop(), [this._pop(), this._state]
                }, t.prototype._push = function(t, e) {
                    return this._stack.unshift(new o(t, e)), this._state = this._stack[0]
                }, t.prototype._pop = function() {
                    var t;
                    return this._state = this._stack[1], null == this._state && (this._state = new o), null != (t = this._stack.shift()) ? t : new o
                }, t.prototype._auto = function(t) {
                    return t.node.inputs.length ? this._append(t) : this._insert(t)
                }, t.prototype._append = function(t) {
                    var e, r, n, i, o;
                    for (r = t.node, this._graph.add(r), o = this._state.end, n = 0, i = o.length; i > n; n++) e = o[n], e.connect(r);
                    return this._state.start.length || (this._state.start = [r]), this._state.end = [r], this._state.nodes.push(r), r.outputs.length ? void 0 : this._state.tail.push(r)
                }, t.prototype._prepend = function(t) {
                    var e, r, n, i, o;
                    for (e = t.node, this._graph.add(e), o = this._state.start, n = 0, i = o.length; i > n; n++) r = o[n], e.connect(r);
                    return this._state.end.length || (this._state.end = [e]), this._state.start = [e], this._state.nodes.push(e), e.outputs.length ? void 0 : this._state.tail.push(e)
                }, t.prototype._insert = function(t) {
                    var e;
                    return e = t.node, this._graph.add(e), this._state.start.push(e), this._state.end.push(e), this._state.nodes.push(e), e.outputs.length ? void 0 : this._state.tail.push(e)
                }, t
            }(), o = function() {
                function t(t, e, r, n, i, o) {
                    this.op = null != t ? t : null, this.empty = null != e ? e : !1, this.start = null != r ? r : [], this.end = null != n ? n : [], this.nodes = null != i ? i : [], this.tail = null != o ? o : []
                }
                return t
            }(), e.exports = n
        }, {
            "../block": 8,
            "../graph": 25,
            "../visualize": 36
        }],
        13: [function(t, e) {
            var r, n, i, o, a, s, h, u;
            r = 3432918353, n = 461845907, i = 3864292196, o = 2246822507, a = 3266489909, h = function(t, e) {
                var r, n, i, o;
                return r = t >>> 16 & 65535, n = 65535 & t, i = e >>> 16 & 65535, o = 65535 & e, n * o + (r * o + n * i << 16 >>> 0) | 0
            }, null != Math.imul && (u = Math.imul(4294967295, 5), -5 === u && (h = Math.imul)), s = function(t) {
                var e, s, u, l, c, p;
                for (c = t.length, l = Math.floor(c / 2), u = e = 0, p = function() {
                        return t.charCodeAt(u++)
                    }, s = function(t, o) {
                        var a;
                        return a = t | o << 16, a ^= a << 9, a = h(a, r), a = a << 15 | a >>> 17, a = h(a, n), e ^= a, e = e << 13 | e >>> 19, e = h(e, 5), e = e + i | 0
                    }; l--;) s(p(), p());
                return 1 & c && s(p(), 0), e ^= c, e ^= e >>> 16, e = h(e, o), e ^= e >>> 13, e = h(e, a), e ^= e >>> 16
            }, e.exports = s
        }, {}],
        14: [function(t, e, r) {
            r.Factory = t("./factory"), r.Material = t("./material"), r.library = t("./library"), r.cache = t("./cache"), r.queue = t("./queue"), r.hash = t("./hash")
        }, {
            "./cache": 11,
            "./factory": 12,
            "./hash": 13,
            "./library": 15,
            "./material": 16,
            "./queue": 17
        }],
        15: [function(t, e) {
            var r;
            r = function(t, e, r) {
                var n, i;
                return n = null, null != e && ("function" == typeof e ? n = function(n) {
                    return r(t, n, e(n))
                } : "object" == typeof e && (n = function(n) {
                    if (null == e[n]) throw "Unknown snippet `" + n + "`";
                    return r(t, n, e[n])
                })), i = function(e) {
                    return r(t, "", e)
                }, null == n ? i : function(t) {
                    return t.match(/[{;(#]/) ? i(t) : n(t)
                }
            }, e.exports = r
        }, {}],
        16: [function(t, e) {
            var r, n, i;
            n = !1, i = function() {
                var t;
                return t = +new Date,
                    function(e) {
                        var r;
                        return r = +new Date - t, console.log(e, r + " ms"), r
                    }
            }, r = function() {
                function t(t, e) {
                    this.vertex = t, this.fragment = e, n && (this.tock = i())
                }
                return t.prototype.build = function(t) {
                    return this.link(t)
                }, t.prototype.link = function(t) {
                    var e, r, i, o, a, s, h, u, l, c, p, f, d, m;
                    for (null == t && (t = {}), a = {}, h = {}, e = {}, u = this.vertex.link("main"), r = this.fragment.link("main"), p = [u, r], l = 0, c = p.length; c > l; l++) {
                        o = p[l], f = o.uniforms;
                        for (i in f) s = f[i], a[i] = s;
                        d = o.varyings;
                        for (i in d) s = d[i], h[i] = s;
                        m = o.attributes;
                        for (i in m) s = m[i], e[i] = s
                    }
                    return t.vertexShader = u.code, t.fragmentShader = r.code, t.attributes = e, t.uniforms = a, t.varyings = h, n && this.tock("Material build"), t
                }, t
            }(), e.exports = r
        }, {}],
        17: [function(t, e) {
            var r;
            r = function(t) {
                var e, r, n, i, o, a;
                return null == t && (t = 100), i = {}, n = null, a = null, r = 0, e = function(t) {
                        return t.prev = null, t.next = n, null != n && (n.prev = t), n = t, null == a ? a = t : void 0
                    }, o = function(t) {
                        var e, r;
                        return r = t.prev, e = t.next, null != r && (r.next = e), null != e && (e.prev = r), n === t && (n = e), a === t ? a = r : void 0
                    },
                    function(s) {
                        var h, u;
                        return (u = i[s] && u !== n) ? (o(u), e(u)) : (r === t ? (h = a.key, o(a), delete i[h]) : r++, u = {
                            next: n,
                            prev: null,
                            key: s
                        }, e(u), i[s] = u), h
                    }
            }, e.exports = r
        }, {}],
        18: [function(t, e) {
            var r, n, i, o;
            r = function(t) {
                var e, r, o, a, s;
                return r = t.ast, o = t.code, s = t.signatures, a = n(s), e = i(o, a), [s, e]
            }, o = function() {
                var t;
                return t = +new Date,
                    function(e) {
                        var r;
                        return r = +new Date - t, console.log(e, r + " ms"), r
                    }
            }, n = function(t) {
                var e, r, n, i, o, a, s, h, u, l;
                for (r = {}, n = function(t) {
                        return r[t.name] = !0
                    }, n(t.main), u = ["external", "internal", "varying", "uniform", "attribute"], o = 0, s = u.length; s > o; o++)
                    for (e = u[o], l = t[e], a = 0, h = l.length; h > a; a++) i = l[a], n(i);
                return r
            }, i = function(t, e) {
                var r, n;
                return n = new RegExp("\\b(" + function() {
                        var t;
                        t = [];
                        for (r in e) t.push(r);
                        return t
                    }().join("|") + ")\\b", "g"), t = t.replace(/\/\/[^\n]*/g, ""), t = t.replace(/\/\*([^*]|\*[^\/])*\*\//g, ""),
                    function(i, o, a) {
                        var s, h, u, l;
                        null == i && (i = ""), null == o && (o = {}), null == a && (a = {}), u = {};
                        for (r in e) u[r] = null != o[r] ? r : i + r;
                        return s = t.replace(n, function(t) {
                            return u[t]
                        }), h = function() {
                            var t;
                            t = [];
                            for (r in a) l = a[r], t.push("#define " + r + " " + l);
                            return t
                        }(), h.length && h.push(""), h.join("\n") + s
                    }
            }, e.exports = r
        }, {}],
        19: [function(t, e) {
            e.exports = {
                SHADOW_ARG: "_i_n_o_u_t",
                RETURN_ARG: "return"
            }
        }, {}],
        20: [function(t, e) {
            var r, n, i, o, a, s;
            e.exports = r = {}, r["in"] = 0, r.out = 1, r.inout = 2, i = function(t) {
                return t.token.data
            }, r.node = function(t) {
                var e, n;
                return "function" === (null != (e = t.children[5]) ? e.type : void 0) ? r["function"](t) : "keyword" === (null != (n = t.token) ? n.type : void 0) ? r.external(t) : void 0
            }, r.external = function(t) {
                var e, r, n, o, a, s, h, u, l, c, p, f, d;
                for (e = t.children, u = i(e[1]), l = i(e[3]), c = i(e[4]), o = e[5], "attribute" !== u && "uniform" !== u && "varying" !== u && (u = "global"), s = [], d = o.children, r = p = 0, f = d.length; f > p; r = ++p) e = d[r], "ident" === e.type && (n = i(e), a = o.children[r + 1], h = "quantifier" === (null != a ? a.type : void 0), s.push({
                    decl: "external",
                    storage: u,
                    type: c,
                    ident: n,
                    quant: !!h,
                    count: h
                }));
                return s
            }, r["function"] = function(t) {
                var e, n, o, a, s, h, u, l, c, p;
                return o = t.children, l = i(o[1]), c = i(o[3]), p = i(o[4]), h = o[5], u = i(h.children[0]), e = h.children[1], n = h.children[2], s = function() {
                    var t, n, i, o;
                    for (i = e.children, o = [], t = 0, n = i.length; n > t; t++) a = i[t], o.push(r.argument(a));
                    return o
                }(), [{
                    decl: "function",
                    storage: l,
                    type: p,
                    ident: u,
                    body: !!n,
                    args: s
                }]
            }, r.argument = function(t) {
                var e, r, n, o, a, s, h, u;
                return e = t.children, h = i(e[1]), o = i(e[2]), u = i(e[4]), a = e[5], n = i(a.children[0]), s = a.children[1], r = s ? s.children[0].token.data : void 0, {
                    decl: "argument",
                    storage: h,
                    inout: o,
                    type: u,
                    ident: n,
                    quant: !!s,
                    count: r
                }
            }, r.param = function(t, e, r, n, i) {
                var o, a;
                return o = [], null != e && o.push(e), null != r && o.push(r), o.push(""), o = o.join(" "), a = n ? "[" + i + "]" : "", "" !== t && (t += " "),
                    function(e, r) {
                        return (r ? t : "") + ("" + o + e + a)
                    }
            }, s = "undefined" != typeof window, a = s && !!window.THREE, n = {
                "int": 0,
                "float": 0,
                vec2: a ? THREE.Vector2 : null,
                vec3: a ? THREE.Vector3 : null,
                vec4: a ? THREE.Vector4 : null,
                mat2: null,
                mat3: a ? THREE.Matrix3 : null,
                mat4: a ? THREE.Matrix4 : null,
                sampler2D: 0,
                samplerCube: 0
            }, o = {
                "int": "i",
                "float": "f",
                vec2: "v2",
                vec3: "v3",
                vec4: "v4",
                mat2: "m2",
                mat3: "m3",
                mat4: "m4",
                sampler2D: "t",
                samplerCube: "t"
            }, r.type = function(t, e, i, a, s, h) {
                var u, l, c, p, f, d, m;
                return u = {
                    "in": r["in"],
                    out: r.out,
                    inout: r.inout
                }, p = {
                    "const": "const"
                }, f = o[e], i && (f += "v"), d = n[e], (null != d ? d.call : void 0) && (d = new d), i && (d = [d]), l = null != (m = u[s]) ? m : u["in"], h = p[h], c = r.param(s, h, e, i, a), {
                    name: t,
                    type: f,
                    spec: e,
                    param: c,
                    value: d,
                    inout: l,
                    copy: function(t) {
                        return r.copy(this, t)
                    }
                }
            }, r.copy = function(t, e) {
                var r, n, i, o, a, s, h;
                return h = t, i = h.name, t = h.type, a = h.spec, o = h.param, s = h.value, n = h.inout, r = h.copy, null != e && (i = e), {
                    name: i,
                    type: t,
                    spec: a,
                    param: o,
                    value: s,
                    inout: n,
                    copy: r
                }
            }
        }, {}],
        21: [function(t, e) {
            var r, n, i;
            n = t("../graph"), r = t("./constants"), e.exports = i = {
                unshadow: function(t) {
                    var e;
                    return e = t.replace(r.SHADOW_ARG, ""), e !== t ? e : null
                },
                lines: function(t) {
                    return t.join("\n")
                },
                list: function(t) {
                    return t.join(", ")
                },
                statements: function(t) {
                    return t.join(";\n")
                },
                body: function(t) {
                    return {
                        entry: t,
                        type: "void",
                        params: [],
                        signature: [],
                        "return": "",
                        vars: {},
                        calls: []
                    }
                },
                define: function(t, e) {
                    return "#define " + t + " " + e
                },
                "function": function(t, e, r, n, i) {
                    return "" + t + " " + e + "(" + r + ") {\n" + n + i + "}"
                },
                invoke: function(t, e, r) {
                    return t = t ? "" + t + " = " : "", r = i.list(r), "  " + t + e + "(" + r + ")"
                },
                same: function(t, e) {
                    var n, i, o, a, s;
                    for (o = a = 0, s = t.length; s > a; o = ++a) {
                        if (n = t[o], i = e[o], !i) return !1;
                        if (n.type !== i.type) return !1;
                        if (n.name === r.RETURN_ARG != (i.name === r.RETURN_ARG)) return !1
                    }
                    return !0
                },
                call: function(t, e, n, o, a) {
                    var s, h, u, l, c, p, f, d, m;
                    for (h = [], p = "", f = 1, d = 0, m = o.length; m > d; d++) s = o[d], c = s.param, l = s.name, i.unshadow(l) || (u = t(l), l === r.RETURN_ARG ? p = u : h.push(u), a && (e(l) ? l === r.RETURN_ARG ? "" === a["return"] ? (a.type = s.spec, a["return"] = "  return " + u, a.vars[u] = "  " + c(u), a.signature.push(s)) : (a.vars[u] = "  " + c(u), a.params.push(c(u, !0)), a.signature.push(s.copy(u))) : (a.params.push(c(u, !0)), a.signature.push(s.copy(u))) : a.vars[u] = "  " + c(u)));
                    return a.calls.push(i.invoke(p, n, h))
                },
                build: function(t, e) {
                    var r, n, o, a, s, h, u, l, c, p;
                    return s = t.entry, o = null, e && 1 === t.calls.length && "main" !== s && (r = t, n = e[0].module, i.same(t.signature, n.main.signature) && (o = i.define(s, n.entry))), null == o && (p = function() {
                        var e, r;
                        e = t.vars, r = [];
                        for (c in e) a = e[c], r.push(a);
                        return r
                    }(), e = t.calls.slice(), h = t.params, l = t.type, u = t["return"], "" !== u && e.push(u), e.push(""), p.length ? (p.push(""), p = i.statements(p) + "\n") : p = "", e = i.statements(e), h = i.list(h), o = i["function"](l, s, h, p, e)), {
                        signature: t.signature,
                        code: o,
                        name: s
                    }
                },
                links: function(t) {
                    var e, r, n, o;
                    for (r = {
                            defs: [],
                            bodies: []
                        }, n = 0, o = t.length; o > n; n++) e = t[n], i.link(e, r);
                    return r.defs = i.lines(r.defs), r.bodies = i.statements(r.bodies), "" === r.defs && delete r.defs, "" === r.bodies && delete r.bodies, r
                },
                link: function() {
                    return function(t, e) {
                        var o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S;
                        if (f = t.module, d = t.name, s = t.external, c = f.main, a = f.entry, i.same(c.signature, s.signature)) return e.defs.push(i.define(d, a));
                        for (u = [], v = [], p = {}, E = [f.namespace, r.RETURN_ARG].join(""), M = s.signature, x = 0, b = M.length; b > x; x++) o = M[x], l = o.inout === n.IN ? u : v, l.push(o);
                        for (S = c.signature, _ = 0, R = S.length; R > _; _++) o = S[_], l = o.inout === n.IN ? u : v, m = l.shift(), H = m.name, H === r.RETURN_ARG && (H = E), p[o.name] = H;
                        return w = function(t) {
                            return p[t]
                        }, T = function() {
                            return !0
                        }, h = i.body(), i.call(w, T, a, c.signature, h), h.entry = a, p = {
                            "return": E
                        }, w = function(t) {
                            var e;
                            return null != (e = p[t]) ? e : t
                        }, g = i.body(), y = i.call(w, T, a, s.signature, g), g.calls = h.calls, g.entry = d, e.bodies.push(i.build(h).code.split(" {")[0]), e.bodies.push(i.build(g).code)
                    }
                }(this),
                defuse: function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m;
                    for (u = /([A-Za-z0-9_]+\s+)?[A-Za-z0-9_]+\s+[A-Za-z0-9_]+\s*\([^)]*\)\s*;\s*/gm, c = function(t) {
                            return t.replace(u, function() {
                                return ""
                            })
                        }, r = t.split(/(?=[{}])/g), s = 0, o = p = 0, d = r.length; d > p; o = ++p) {
                        switch (e = r[o], e[0]) {
                            case "{":
                                s++;
                                break;
                            case "}":
                                s--
                        }
                        if (0 === s) {
                            for (n = e.split(/^[ \t]*#/m), a = f = 0, m = n.length; m > f; a = ++f) h = n[a], a > 0 ? (h = h.split(/\n/), i = h.shift(), l = h.join("\n"), n[a] = [i, c(l)].join("\n")) : n[a] = c(h);
                            r[o] = n.join("#")
                        }
                    }
                    return t = r.join("")
                },
                dedupe: function(t) {
                    var e, r;
                    return e = {}, r = /((attribute|uniform|varying)\s+)[A-Za-z0-9_]+\s+([A-Za-z0-9_]+)\s*(\[[^\]]*\]\s*)?;\s*/gm, t.replace(r, function(t, r, n, i) {
                        return e[i] ? "" : (e[i] = !0, t)
                    })
                },
                hoist: function(t) {
                    var e, r, n, i, o, a, s, h;
                    for (a = /^#define ([^ ]+ _pg_[0-9]+_|_pg_[0-9]+_ [^ ]+)$/, n = t.split(/\n/g), e = [], o = [], s = 0, h = n.length; h > s; s++) r = n[s], i = r.match(a) ? e : o, i.push(r);
                    return e.concat(o).join("\n")
                }
            }
        }, {
            "../graph": 25,
            "./constants": 19
        }],
        22: [function(t, e, r) {
            var n, i, o, a, s;
            for (r.compile = t("./compile"), r.parse = t("./parse"), r.generate = t("./generate"), s = t("./constants"), i = o = 0, a = s.length; a > o; i = ++o) n = s[i], r[n] = i
        }, {
            "./compile": 18,
            "./constants": 19,
            "./generate": 21,
            "./parse": 23
        }],
        23: [function(t, e) {
            var r, n, i, o, a, s, h, u, l, c, p, f, d, m;
            d = t("../../vendor/glsl-tokenizer"), l = t("../../vendor/glsl-parser"), o = t("./decl"), r = t("./constants"), i = !1, h = function(t, e) {
                var r, n;
                return r = u(t, e), n = c(r, e)
            }, u = function(t, e) {
                var r, n, o, a, s, h, u, c;
                if (i && (a = f()), u = d().process(l(), e), c = u[0], r = c[0], o = u[1], i && a("GLSL Tokenize & Parse"), !r || o.length) {
                    for (t || (t = "(inline code)"), s = 0, h = o.length; h > s; s++) n = o[s], console.error("[ShaderGraph] " + t + " -", n.message);
                    throw "GLSL parse error"
                }
                return r
            }, c = function(t, e) {
                var r, o, h, u, l, c, d;
                return i && (c = f()), l = [], m(s, n(l), t, ""), d = p(l), h = d[0], o = d[1], r = d[2], u = a(h, o, r), i && c("GLSL AST"), {
                    ast: t,
                    code: e,
                    signatures: u
                }
            }, s = function(t, e) {
                switch (t.type) {
                    case "decl":
                        return e(o.node(t)), !1
                }
                return !0
            }, n = function(t) {
                return function(e) {
                    var r, n, i, o;
                    if (null != e) {
                        for (o = [], n = 0, i = e.length; i > n; n++) r = e[n], o.push(t.push(r));
                        return o
                    }
                }
            }, p = function(t) {
                var e, r, n, i, o, a, s, h, u;
                for (o = null, i = [], r = [], a = {}, n = !1, h = 0, u = t.length; u > h; h++) s = t[h], s.body ? (a[s.ident] && (r = function() {
                    var t, n, i;
                    for (i = [], t = 0, n = r.length; n > t; t++) e = r[t], e.ident !== s.ident && i.push(e);
                    return i
                }(), delete a[s.ident]), i.push(s), "main" === s.ident ? (o = s, n = !0) : n || (o = s)) : "global" === s.storage ? i.push(s) : (r.push(s), a[s.ident] = !0);
                return [o, i, r]
            }, a = function(t, e, n) {
                var i, a, s, h, u, l, c, p, f;
                for (h = {
                        uniform: [],
                        attribute: [],
                        varying: [],
                        external: [],
                        internal: [],
                        global: [],
                        main: null
                    }, a = function(t) {
                        return o.type(t.ident, t.type, t.quant, t.count, t.inout, t.storage)
                    }, s = function(t, e) {
                        var n, i, s, h, u, l, c, p, f, d, m;
                        for (p = function() {
                                var e, r, n, o;
                                for (n = t.args, o = [], e = 0, r = n.length; r > e; e++) i = n[e], o.push(a(i));
                                return o
                            }(), d = 0, m = p.length; m > d; d++) h = p[d], h.inout === o.inout && (n = h, s = h.copy(), n.inout = o["in"], s.inout = o.out, s.name += r.SHADOW_ARG, p.push(s));
                        return "void" !== t.type && p.push(o.type(r.RETURN_ARG, t.type, !1, "", "out")), l = function() {
                            var t, e, r;
                            for (r = [], t = 0, e = p.length; e > t; t++) h = p[t], h.inout === o["in"] && r.push(h.type);
                            return r
                        }().join(","), c = function() {
                            var t, e, r;
                            for (r = [], t = 0, e = p.length; e > t; t++) h = p[t], h.inout === o.out && r.push(h.type);
                            return r
                        }().join(","), f = "(" + l + ")(" + c + ")", u = {
                            name: t.ident,
                            type: f,
                            signature: p,
                            inout: e,
                            spec: t.type
                        }
                    }, h.main = s(t, o.out), l = 0, p = e.length; p > l; l++) u = e[l], h.internal.push({
                    name: u.ident
                });
                for (c = 0, f = n.length; f > c; c++) switch (u = n[c], u.decl) {
                    case "external":
                        i = a(u), h[u.storage].push(i);
                        break;
                    case "function":
                        i = s(u, o["in"]), h.external.push(i)
                }
                return h
            }, i = !1, m = function(t, e, r, n) {
                var o, a, s, h, u, l, c, p;
                if (i && console.log(n, r.type, null != (l = r.token) ? l.data : void 0, null != (c = r.token) ? c.type : void 0), s = t(r, e))
                    for (p = r.children, a = h = 0, u = p.length; u > h; a = ++h) o = p[a], m(t, e, o, n + "  ", i);
                return null
            }, f = function() {
                var t;
                return t = +new Date,
                    function(e) {
                        var r;
                        return r = +new Date - t, console.log(e, r + " ms"), r
                    }
            }, e.exports = m, e.exports = h
        }, {
            "../../vendor/glsl-parser": 39,
            "../../vendor/glsl-tokenizer": 43,
            "./constants": 19,
            "./decl": 20
        }],
        24: [function(t, e) {
            var r;
            r = function() {
                function t(e, r) {
                    this.parent = null != r ? r : null, this.id = t.id(), this.nodes = [], e && this.add(e)
                }
                return t.index = 0, t.id = function() {
                    return ++t.index
                }, t.IN = 0, t.OUT = 1, t.prototype.inputs = function() {
                    var t, e, r, n, i, o, a, s, h;
                    for (t = [], s = this.nodes, n = 0, o = s.length; o > n; n++)
                        for (e = s[n], h = e.inputs, i = 0, a = h.length; a > i; i++) r = h[i], null === r.input && t.push(r);
                    return t
                }, t.prototype.outputs = function() {
                    var t, e, r, n, i, o, a, s, h;
                    for (r = [], s = this.nodes, n = 0, o = s.length; o > n; n++)
                        for (t = s[n], h = t.outputs, i = 0, a = h.length; a > i; i++) e = h[i], 0 === e.output.length && r.push(e);
                    return r
                }, t.prototype.getIn = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.inputs(), o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.getOut = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.outputs(), o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.add = function(t, e) {
                    var r, n, i; {
                        if (!t.length) {
                            if (t.graph && !e) throw "Adding node to two graphs at once";
                            return t.graph = this, this.nodes.push(t)
                        }
                        for (r = 0, n = t.length; n > r; r++) i = t[r], this.add(i)
                    }
                }, t.prototype.remove = function(t, e) {
                    var r, n, i; {
                        if (!t.length) {
                            if (t.graph !== this) throw "Removing node from wrong graph.";
                            return e || t.disconnect(), this.nodes.splice(this.nodes.indexOf(t), 1), t.graph = null
                        }
                        for (r = 0, n = t.length; n > r; r++) i = t[r], this.remove(i)
                    }
                }, t.prototype.adopt = function(t) {
                    var e, r, n; {
                        if (!t.length) return t.graph.remove(t, !0), this.add(t, !0);
                        for (e = 0, r = t.length; r > e; e++) n = t[e], this.adopt(n)
                    }
                }, t
            }(), e.exports = r
        }, {}],
        25: [function(t, e, r) {
            r.Graph = t("./graph"), r.Node = t("./node"), r.Outlet = t("./outlet"), r.IN = r.Graph.IN, r.OUT = r.Graph.OUT
        }, {
            "./graph": 24,
            "./node": 26,
            "./outlet": 27
        }],
        26: [function(t, e) {
            var r, n, i;
            r = t("./graph"), i = t("./outlet"), n = function() {
                function t(e, r) {
                    this.owner = e, this.graph = null, this.inputs = [], this.outputs = [], this.outlets = null, this.id = t.id(), this.setOutlets(r)
                }
                return t.index = 0, t.id = function() {
                    return ++t.index
                }, t.prototype.getIn = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.inputs, o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.getOut = function(t) {
                    var e;
                    return function() {
                        var r, n, i, o;
                        for (i = this.outputs, o = [], r = 0, n = i.length; n > r; r++) e = i[r], e.name === t && o.push(e);
                        return o
                    }.call(this)[0]
                }, t.prototype.get = function(t) {
                    return this.getIn(t) || this.getOut(t)
                }, t.prototype.setOutlets = function(t) {
                    var e, r, n, o, a, s, h, u, l, c, p, f, d;
                    if (o = function(t) {
                            return new i(t.inout, t.name, t.hint, t.type, t.meta)
                        }, null != t) {
                        if (null == this.outlets) {
                            for (this.outlets = {}, h = 0, c = t.length; c > h; h++) s = t[h], this._add(o(s));
                            return
                        }
                        for (r = function(t) {
                                return [t.name, t.inout, t.type].join("-")
                            }, a = {}, u = 0, p = t.length; p > u; u++) s = t[u], a[r(s)] = !0;
                        d = this.outlets;
                        for (n in d) s = d[n], n = r(s), a[n] ? a[n] = s : this._remove(s);
                        for (l = 0, f = t.length; f > l; l++) s = t[l], e = a[r(s)], e instanceof i ? this._morph(e, s) : this._add(o(s))
                    }
                    return this.outlets
                }, t.prototype.connect = function(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d;
                    for (s = {}, i = {}, f = t.inputs, u = 0, c = f.length; c > u; u++) a = f[u], (r || !a.input) && (h = a.type, n = [h, a.hint].join("-"), i[n] || (i[n] = a), s[h] = s[h] || [], s[h].push(a));
                    for (d = this.outputs, l = 0, p = d.length; p > l; l++) a = d[l], e && a.output.length || (h = a.type, n = [h, a.hint].join("-"), o = s[h], i[n] ? (i[n].connect(a), delete i[n], o.splice(o.indexOf(a), 1)) : o && o.length && o.shift().connect(a));
                    return this
                }, t.prototype.disconnect = function() {
                    var t, e, r, n, i, o, a;
                    for (o = this.inputs, e = 0, n = o.length; n > e; e++) t = o[e], t.disconnect();
                    for (a = this.outputs, r = 0, i = a.length; i > r; r++) t = a[r], t.disconnect();
                    return this
                }, t.prototype._key = function(t) {
                    return [t.name, t.inout].join("-")
                }, t.prototype._add = function(t) {
                    var e;
                    if (e = this._key(t), t.node) throw "Adding outlet to two nodes at once.";
                    if (this.outlets[e]) throw "Adding two identical outlets to same node. (" + e + ")";
                    return t.node = this, t.inout === r.IN && this.inputs.push(t), t.inout === r.OUT && this.outputs.push(t), this.outlets[e] = t
                }, t.prototype._morph = function(t, e) {
                    var r;
                    return r = this._key(e), delete this.outlets[r], t.morph(e), r = this._key(e), this.outlets[r] = e
                }, t.prototype._remove = function(t) {
                    var e, n;
                    if (n = this._key(t), e = t.inout, t.node !== this) throw "Removing outlet from wrong node.";
                    return t.disconnect(), t.node = null, delete this.outlets[n], t.inout === r.IN && this.inputs.splice(this.inputs.indexOf(t), 1), t.inout === r.OUT && this.outputs.splice(this.outputs.indexOf(t), 1), this
                }, t
            }(), e.exports = n
        }, {
            "./graph": 24,
            "./outlet": 27
        }],
        27: [function(t, e) {
            var r, n;
            r = t("./graph"), n = function() {
                function t(e, r, n, i, o) {
                    this.inout = e, this.name = r, this.hint = n, this.type = i, this.meta = o, null == this.hint && (this.hint = t.hint(r)), this.node = null, this.input = null, this.output = [], this.id = t.id(this.hint)
                }
                return t.index = 0, t.id = function(e) {
                    return "_io_" + ++t.index + "_" + e
                }, t.hint = function(t) {
                    return t = t.replace(/^(_io_[0-9]+_)/, ""), t = t.replace(/(In|Out|Inout|InOut)$/, "")
                }, t.prototype.morph = function(t) {
                    return this.inout = t.inout, this.name = t.name, this.hint = t.hint, this.type = t.type, this.meta = t.meta
                }, t.prototype.dupe = function(t) {
                    var e, r, n, i;
                    return null == t && (t = this.id), r = this.inout, e = this.hint, i = this.type, n = this.meta, {
                        inout: r,
                        hint: e,
                        type: i,
                        meta: n,
                        name: t
                    }
                }, t.prototype.connect = function(t) {
                    if (this.inout === r.IN && t.inout === r.OUT) return t.connect(this);
                    if (this.inout !== r.OUT || t.inout !== r.IN) throw "Can only connect out to in.";
                    if (t.input !== this) return t.disconnect(), t.input = this, this.output.push(t)
                }, t.prototype.disconnect = function(t) {
                    var e, r, n, i;
                    if (this.input && this.input.disconnect(this), this.output.length) {
                        if (!t) {
                            for (i = this.output, r = 0, n = i.length; n > r; r++) t = i[r], t.input = null;
                            return this.output = []
                        }
                        if (e = this.output.indexOf(t), e >= 0) return this.output.splice(e, 1), t.input = null
                    }
                }, t
            }(), e.exports = n
        }, {
            "./graph": 24
        }],
        28: [function(t, e) {
            var r, n, i, o, a, s, h, u, l, c, p, f;
            r = t("./block"), n = t("./factory"), i = t("./glsl"), o = t("./graph"), a = t("./linker"), u = t("./visualize"), c = n.library, l = n.cache, f = u.visualize, h = a.Snippet, p = function(t, e) {
                var r, n, i, o;
                null == e && (e = {}), n = {};
                for (r in t) i = t[r], n[r] = null != (o = e[r]) ? o : t[r];
                return n
            }, s = function() {
                function t(e, r) {
                    var n;
                    return this instanceof t ? (n = {
                        globalUniforms: !1,
                        globalVaryings: !0,
                        globalAttributes: !0,
                        globals: []
                    }, this.config = p(n, r), void(this.fetch = l(c(i, e, h.load)))) : new t(e, r)
                }
                return t.prototype.shader = function(t) {
                    var e;
                    return null == t && (t = {}), e = p(this.config, t), new n.Factory(i, this.fetch, e)
                }, t.prototype.material = function(t) {
                    return new n.Material(this.shader(t), this.shader(t))
                }, t.prototype.visualize = function(e) {
                    return t.visualize(e)
                }, t.Block = r, t.Factory = n, t.GLSL = i, t.Graph = o, t.Linker = a, t.Visualize = u, t.visualize = function(t) {
                    return t instanceof n.Material ? f(t.vertex, t.fragment) : f(t)
                }, t
            }(), e.exports = s, "undefined" != typeof window && (window.ShaderGraph = s)
        }, {
            "./block": 8,
            "./factory": 14,
            "./glsl": 22,
            "./graph": 25,
            "./linker": 30,
            "./visualize": 36
        }],
        29: [function(t, e) {
            var r, n, i;
            r = t("../graph"), n = t("./priority"), i = function(t, e, i) {
                var o, a, s, h, u, l, c, p, f, d, m, g;
                return h = t.generate, s = {}, m = {}, g = {}, a = {}, p = {}, d = function() {
                    var t, r, o, l, c, f, d, v;
                    return v = u(i), t = v[0], i = v[1], null != e && (t.entry = e), c = h.build(t, i), d = function() {
                        var t;
                        t = [];
                        for (f in p) l = p[f], t.push(l);
                        return t
                    }().sort(function(t, e) {
                        return n.compare(t.priority, e.priority)
                    }), o = d.map(function(t) {
                        return t.code
                    }), o.push(c.code), r = h.lines(o), {
                        namespace: c.name,
                        library: p,
                        body: c.code,
                        code: r,
                        main: c,
                        entry: c.name,
                        externals: s,
                        uniforms: m,
                        varyings: g,
                        attributes: a
                    }
                }, u = function() {
                    return function(t) {
                        var e, r, n, i, o, a;
                        for (t = function() {
                                var e;
                                e = [];
                                for (i in t) r = t[i], e.push(r);
                                return e
                            }(), t.sort(function(t, e) {
                                return e.priority - t.priority
                            }), n = function(t, r, n) {
                                var i, o, a, s;
                                return l(t, r, n), o = r.main, i = r.entry, s = function(e) {
                                    return f(t, e)
                                }, a = function(e) {
                                    return c(t, e)
                                }, h.call(s, a, i, o.signature, e)
                            }, e = h.body(), o = 0, a = t.length; a > o; o++) r = t[o], n(r.node, r.module, r.priority);
                        return [e, t]
                    }
                }(this), o = function(t, e, r) {
                    var i;
                    return i = p[t], null != i ? i.priority = n.max(i.priority, r) : p[t] = {
                        code: e,
                        priority: r
                    }
                }, l = function(t, e, r) {
                    var i, h, u, l, p, f, d, v, E, y;
                    r = n.make(r), p = e.library;
                    for (l in p) u = p[l], o(l, u.code, n.nest(r, u.priority));
                    o(e.namespace, e.body, r), f = e.uniforms;
                    for (h in f) i = f[h], m[h] = i;
                    d = e.varyings;
                    for (h in d) i = d[h], g[h] = i;
                    v = e.attributes;
                    for (h in v) i = v[h], a[h] = i;
                    E = e.externals, y = [];
                    for (h in E) i = E[h], y.push(c(t, i.name) ? s[h] = i : void 0);
                    return y
                }, c = function(t, e) {
                    var n;
                    return n = t.get(e), n.inout === r.IN ? null === n.input : n.inout === r.OUT ? 0 === n.output.length : void 0
                }, f = function(t, e) {
                    var r, n;
                    return n = t.get(e), n.input && (n = n.input), e = n.name, r = h.unshadow(e), r ? f(n.node, r) : n.id
                }, d()
            }, e.exports = i
        }, {
            "../graph": 25,
            "./priority": 33
        }],
        30: [function(t, e, r) {
            r.Snippet = t("./snippet"), r.Program = t("./program"), r.Layout = t("./layout"), r.assemble = t("./assemble"), r.link = t("./link"), r.priority = t("./priority"), r.load = r.Snippet.load
        }, {
            "./assemble": 29,
            "./layout": 31,
            "./link": 32,
            "./priority": 33,
            "./program": 34,
            "./snippet": 35
        }],
        31: [function(t, e) {
            var r, n, i, o;
            n = t("./snippet"), o = t("./link"), i = !1, r = function() {
                function t(t) {
                    this.language = t, this.links = [], this.includes = [], this.modules = {}, this.visits = {}
                }
                return t.prototype.callback = function(t, e, r, n, i) {
                    return this.links.push({
                        node: t,
                        module: e,
                        priority: r,
                        name: n,
                        external: i
                    })
                }, t.prototype.include = function(t, e, r) {
                    var n;
                    return null != (n = this.modules[e.namespace]) ? n.priority = Math.max(r, n.priority) : (this.modules[e.namespace] = !0, this.includes.push({
                        node: t,
                        module: e,
                        priority: r
                    }))
                }, t.prototype.visit = function(t) {
                    return i && console.log("Visit", t, !this.visits[t]), this.visits[t] ? !1 : this.visits[t] = !0
                }, t.prototype.link = function(t) {
                    var e, r, i;
                    e = o(this.language, this.links, this.includes, t), i = new n;
                    for (r in e) i[r] = e[r];
                    return i
                }, t
            }(), e.exports = r
        }, {
            "./link": 32,
            "./snippet": 35
        }],
        32: [function(t, e) {
            var r, n, i;
            r = t("../graph"), n = t("./priority"), i = function(t, e, i, o) {
                var a, s, h, u, l, c, p, f, d, m, g;
                return u = t.generate, c = [], h = {}, m = {}, s = {}, g = {}, f = {}, d = function() {
                    var t, r, a, p, d, v, E, y, T, x;
                    for (a = u.links(e), p = [], null != a.defs && p.push(a.defs), null != a.bodies && p.push(a.bodies), T = 0, x = i.length; x > T; T++) v = i[T], l(v.node, v.module, v.priority);
                    return y = function() {
                        var t;
                        t = [];
                        for (E in f) d = f[E], t.push(d);
                        return t
                    }().sort(function(t, e) {
                        return n.compare(t.priority, e.priority)
                    }), c = y.map(function(t) {
                        return t.code
                    }), t = u.lines(c), t = u.defuse(t), p.length && (t = [u.lines(p), t].join("\n")), t = u.hoist(t), t = u.dedupe(t), r = o, {
                        namespace: r.main.name,
                        code: t,
                        main: r.main,
                        entry: r.main.name,
                        externals: h,
                        uniforms: m,
                        attributes: s,
                        varyings: g
                    }
                }, a = function(t, e, r) {
                    var i;
                    return i = f[t], null != i ? i.priority = n.max(i.priority, r) : f[t] = {
                        code: e,
                        priority: r
                    }
                }, l = function(t, e, r) {
                    var i, o, u, l, c, f, d, v, E, y;
                    r = n.make(r), c = e.library;
                    for (l in c) u = c[l], a(l, u.code, n.nest(r, u.priority));
                    a(e.namespace, e.body, r), f = e.uniforms;
                    for (o in f) i = f[o], m[o] = i;
                    d = e.varyings;
                    for (o in d) i = d[o], g[o] = i;
                    v = e.attributes;
                    for (o in v) i = v[o], s[o] = i;
                    E = e.externals, y = [];
                    for (o in E) i = E[o], y.push(p(t, i.name) ? h[o] = i : void 0);
                    return y
                }, p = function(t, e) {
                    var n, i, o, a;
                    if (i = t.get(e), !i) throw n = null != (o = null != (a = t.owner.snippet) ? a._name : void 0) ? o : t.owner.namespace, "Unable to link program. Unlinked callback `" + e + "` on `" + n + "`";
                    return i.inout === r.IN ? null === i.input : i.inout === r.OUT ? 0 === i.output.length : void 0
                }, d()
            }, e.exports = i
        }, {
            "../graph": 25,
            "./priority": 33
        }],
        33: [function(t, e, r) {
            r.make = function(t) {
                return null == t && (t = []), t instanceof Array || (t = [null != +t ? +t : 0]), t
            }, r.nest = function(t, e) {
                return t.concat(e)
            }, r.compare = function(t, e) {
                var r, n, i, o, a;
                for (n = Math.min(t.length, e.length), r = a = 0; n >= 0 ? n > a : a > n; r = n >= 0 ? ++a : --a) {
                    if (i = t[r], o = e[r], i > o) return -1;
                    if (o > i) return 1
                }
                return t = t.length, e = e.length, t > e ? -1 : e > t ? 1 : 0
            }, r.max = function(t, e) {
                return r.compare(t, e) > 0 ? e : t
            }
        }, {}],
        34: [function(t, e) {
            var r, n, i;
            n = t("./snippet"), i = t("./assemble"), r = function() {
                function t(t, e) {
                    this.language = t, this.namespace = e, this.calls = {}
                }
                return t.index = 0, t.entry = function() {
                    return "_pg_" + ++t.index + "_"
                }, t.prototype.call = function(t, e, r) {
                    var n, i;
                    return i = e.namespace, (n = this.calls[i]) ? n.priority = Math.max(n.priority, r) : this.calls[i] = {
                        node: t,
                        module: e,
                        priority: r
                    }, this
                }, t.prototype.assemble = function() {
                    var e, r, o, a;
                    e = i(this.language, null != (a = this.namespace) ? a : t.entry, this.calls), o = new n;
                    for (r in e) o[r] = e[r];
                    return o
                }, t
            }(), e.exports = r
        }, {
            "./assemble": 29,
            "./snippet": 35
        }],
        35: [function(t, e) {
            var r;
            r = function() {
                function t(t, e, r, n) {
                    var i;
                    this.language = t, this._signatures = e, this._compiler = r, this._name = n, this.namespace = null, this.code = null, this.main = null, this.entry = null, this.uniforms = null, this.externals = null, this.attributes = null, this.varyings = null, this.language || delete this.language, this._signatures || delete this._signatures, this._compiler || delete this._compiler, this._name || (this._name = null != (i = this._signatures) ? i.main.name : void 0)
                }
                return t.index = 0, t.namespace = function() {
                    return "_sn_" + ++t.index + "_"
                }, t.load = function(e, r, n) {
                    var i, o, a, s;
                    return o = e.parse(r, n), s = e.compile(o), a = s[0], i = s[1], new t(e, a, i, r)
                }, t.prototype.clone = function() {
                    return new t(this.language, this._signatures, this._compiler, this._name)
                }, t.prototype.bind = function(e, r, n, i) {
                    var o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L, z, P, D, F, U, O, B, V, N, j;
                    if (r === "" + r ? (L = [r, null != n ? n : {}, null != i ? i : {}], n = L[0], r = L[1], i = L[2]) : n !== "" + n && (z = [null != n ? n : {}, void 0], i = z[0], n = z[1]), this.main = this._signatures.main, this.namespace = null != (P = null != n ? n : this.namespace) ? P : t.namespace(), this.entry = this.namespace + this.main.name, this.uniforms = {}, this.externals = {}, this.attributes = {}, this.varyings = {}, u = {}, h = {}, l = function(t) {
                            return h[t] = !0, t
                        }, p = function(t) {
                            return function(e) {
                                return t.namespace + e
                            }
                        }(this), e.globals)
                        for (D = e.globals, T = 0, R = D.length; R > T; T++) c = D[T], l(c);
                    for (N = e.globalUniforms ? l : p, j = e.globalVaryings ? l : p, E = e.globalAttributes ? l : p, y = p, v = function() {
                            return function(t) {
                                return u[t.name] = !0
                            }
                        }(this), m = function(t) {
                            return function(e, r) {
                                return t.uniforms[N(null != r ? r : e.name)] = e
                            }
                        }(this), g = function(t) {
                            return function(e) {
                                return t.varyings[j(e.name)] = e
                            }
                        }(this), s = function(t) {
                            return function(e) {
                                return t.externals[y(e.name)] = e
                            }
                        }(this), o = function(t) {
                            return function(e) {
                                return t.attributes[E(e.name)] = e
                            }
                        }(this), d = function(t) {
                            return {
                                type: t.type,
                                name: t.name,
                                value: t.value
                            }
                        }, F = this._signatures.uniform, x = 0, w = F.length; w > x; x++) a = F[x], v(a);
                    for (U = this._signatures.uniform, _ = 0, H = U.length; H > _; _++) a = U[_], m(d(a));
                    for (O = this._signatures.varying, b = 0, M = O.length; M > b; b++) a = O[b], g(d(a));
                    for (B = this._signatures.external, C = 0, S = B.length; S > C; C++) a = B[C], s(a);
                    for (V = this._signatures.attribute, k = 0, A = V.length; A > k; k++) a = V[k], o(d(a));
                    for (f in r) a = r[f], u[f] && m(a, f);
                    return this.body = this.code = this._compiler(this.namespace, h, i), null
                }, t
            }(), e.exports = r
        }, {}],
        36: [function(t, e, r) {
            var n, i, o, a;
            n = t("../Graph").Graph, r.serialize = o = t("./serialize"), r.markup = i = t("./markup"), a = function(t) {
                var e;
                return null != t._graph && (t = t._graph), e = o(t), i.process(e)
            }, r.visualize = function() {
                var t;
                return i.merge(function() {
                    var e, r, n;
                    for (n = [], e = 0, r = arguments.length; r > e; e++) t = arguments[e], n.push(a(t));
                    return n
                }.apply(this, arguments))
            }
        }, {
            "../Graph": 2,
            "./markup": 37,
            "./serialize": 38
        }],
        37: [function(t, e, r) {
            var n, i, o, a, s, h, u, l, c, p, f, d;
            a = t("../factory/hash"), i = function(t, e, r, n) {
                return "rgba(" + [t, e, r, n].join(", ") + ")"
            }, s = function(t, e) {
                var r, n, o, s, h, u, l;
                return null == e && (e = 1), n = 1193046 ^ a(t), l = 255 & n, o = n >>> 8 & 255, r = n >>> 16 & 255, s = Math.max(l, o, r), u = 140 / s, h = Math.round(s / 3), l = Math.min(255, Math.round(u * Math.max(l, h))), o = Math.min(255, Math.round(u * Math.max(o, h))), r = Math.min(255, Math.round(u * Math.max(r, h))), i(l, o, r, e)
            }, o = function(t) {
                return t = null != t ? t : "", t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;")
            }, c = function(t) {
                var e, r;
                return r = [], e = f(t, r), e.update = function() {
                    return n(e, r)
                }, e
            }, d = function(t) {
                var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m;
                for (i = {}, r = {}, f = t.nodes, a = 0, u = f.length; u > a; a++) n = f[a], i[n.id] = n;
                for (d = t.links, s = 0, l = d.length; l > s; s++) e = d[s], null == r[p = e.from] && (r[p] = []), r[e.from].push(e);
                for (o = function(t, n) {
                        var a, s, h, u;
                        if (null == n && (n = 0), t.depth = Math.max(null != (u = t.depth) ? u : 0, n), a = r[t.id])
                            for (s = 0, h = a.length; h > s; s++) e = a[s], o(i[e.to], n + 1);
                        return null
                    }, m = t.nodes, h = 0, c = m.length; c > h; h++) n = m[h], null == n.depth && o(n);
                return null
            }, f = function(t, e) {
                var r, n, i, a, h, u, l, c, p, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C;
                for (d(t), g = document.createElement("div"), g.classList.add("shadergraph-graph"), u = [], m = {}, M = t.nodes, v = 0, x = M.length; x > v; v++) {
                    for (c = M[v], n = document.createElement("div"), n.classList.add("shadergraph-node"), n.classList.add("shadergraph-node-" + c.type), n.innerHTML = '<div class="shadergraph-header">' + o(c.name) + "</div>", r = function(t, e) {
                            var r, i;
                            return r = s(t.type), i = document.createElement("div"), i.classList.add("shadergraph-outlet"), i.classList.add("shadergraph-outlet-" + e), i.innerHTML = '<div class="shadergraph-point" style="background: ' + r + '"></div>\n<div class="shadergraph-type" style="color: ' + r + '">' + o(t.type) + '</div>\n<div class="shadergraph-name">' + o(t.name) + "</div>", n.appendChild(i), m[t.id] = i.querySelector(".shadergraph-point")
                        }, S = c.inputs, E = 0, _ = S.length; _ > E; E++) p = S[E], r(p, "in");
                    for (A = c.outputs, y = 0, b = A.length; b > y; y++) p = A[y], r(p, "out");
                    null != c.graph ? n.appendChild(f(c.graph, e)) : (i = document.createElement("div"), i.classList.add("shadergraph-clear"), n.appendChild(i)), h = u[c.depth], null == h && (h = document.createElement("div"), h.classList.add("shadergraph-column"), u[c.depth] = h), h.appendChild(n)
                }
                for (T = 0, R = u.length; R > T; T++) h = u[T], null != h && g.appendChild(h);
                for (C = t.links, H = 0, w = C.length; w > H; H++) l = C[H], a = s(l.type), e.push({
                    color: a,
                    out: m[l.out],
                    "in": m[l["in"]]
                });
                return g
            }, p = function(t) {
                return t * t
            }, l = function(t, e, r, n) {
                var i, o, a, s, h, u, l, c;
                return o = r - t, a = n - e, i = Math.sqrt(p(o) + p(a)), c = Math.abs(a) > Math.abs(o), c ? (u = (t + r) / 2, l = (e + n) / 2, s = a > 0 ? .3 : -.3, h = Math.min(Math.abs(o) / 2, 20 + i / 8), ["M", t, e, "C", t + h, e + ",", u, l - i * s, u, l, "C", u, l + i * s, r - h, n + ",", r, n].join(" ")) : (h = Math.min(Math.abs(o) / 2.5, 20 + i / 4), ["M", t, e, "C", t + h, e + ",", r - h, n + ",", r, n].join(" "))
            }, h = function(t) {
                return null == t && (t = "svg"), document.createElementNS("http://www.w3.org/2000/svg", t)
            }, n = function(t, e) {
                var r, n, i, o, a, s, u, c, p, f, d;
                if (null != t.parentNode) {
                    for (s = t.getBoundingClientRect(), c = 0, f = e.length; f > c; c++) a = e[c], r = a.out.getBoundingClientRect(), n = a["in"].getBoundingClientRect(), a.coords = {
                        x1: (r.left + r.right) / 2 - s.left,
                        y1: (r.top + r.bottom) / 2 - s.top,
                        x2: (n.left + n.right) / 2 - s.left,
                        y2: (n.top + n.bottom) / 2 - s.top
                    };
                    for (u = t.querySelector("svg"), null != u && t.removeChild(u), u = h(), u.setAttribute("width", t.offsetWidth), u.setAttribute("height", t.offsetHeight), p = 0, d = e.length; d > p; p++) a = e[p], i = a.coords, o = h("path"), o.setAttribute("d", l(i.x1, i.y1, i.x2, i.y2)), o.setAttribute("stroke", a.color), o.setAttribute("stroke-width", 3), o.setAttribute("fill", "transparent"), u.appendChild(o);
                    return t.appendChild(u)
                }
            }, u = function(t) {
                var e, r, n, i;
                if (1 !== t.length) {
                    for (e = document.createElement("div"), n = 0, i = t.length; i > n; n++) r = t[n], e.appendChild(r);
                    return e.update = function() {
                        var e, n, i;
                        for (i = [], e = 0, n = t.length; n > e; e++) r = t[e], i.push(r.update());
                        return i
                    }, e
                }
                return t[0]
            }, r.process = c, r.merge = u
        }, {
            "../factory/hash": 13
        }],
        38: [function(t, e) {
            var r, n, i;
            r = t("../block"), n = function(t) {
                return "(" === t.type[0]
            }, i = function(t) {
                var e, n, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R;
                for (h = [], a = [], x = t.nodes, f = 0, v = x.length; v > f; f++) {
                    for (s = x[f], p = {
                            id: s.id,
                            name: null,
                            type: null,
                            depth: null,
                            graph: null,
                            inputs: [],
                            outputs: []
                        }, h.push(p), o = p.inputs, c = p.outputs, e = s.owner, e instanceof r.Call ? (p.name = e.snippet._name, p.type = "call") : e instanceof r.Callback ? (p.name = "Callback", p.type = "callback", p.graph = i(e.graph)) : e instanceof r.Isolate ? (p.name = "Isolate", p.type = "isolate", p.graph = i(e.graph)) : e instanceof r.Join && (p.name = "Join", p.type = "join"), n = function(t) {
                            return t = t.replace(")(", ")→("), t = t.replace("()", "")
                        }, _ = s.inputs, d = 0, E = _.length; E > d; d++) l = _[d], o.push({
                        id: l.id,
                        name: l.name,
                        type: n(l.type),
                        open: null == l.input
                    });
                    for (b = s.outputs, m = 0, y = b.length; y > m; m++)
                        for (l = b[m], c.push({
                                id: l.id,
                                name: l.name,
                                type: n(l.type),
                                open: !l.output.length
                            }), R = l.output, g = 0, T = R.length; T > g; g++) u = R[g], a.push({
                            from: s.id,
                            out: l.id,
                            to: u.node.id,
                            "in": u.id,
                            type: n(l.type)
                        })
                }
                return {
                    nodes: h,
                    links: a
                }
            }, e.exports = i
        }, {
            "../block": 8
        }],
        39: [function(t, e) {
            e.exports = t("./lib/index")
        }, {
            "./lib/index": 41
        }],
        40: [function(t, e) {
            function r() {
                return this
            }

            function n(t, e) {
                var r = v[t];
                return e = e || 0, r ? e > r.lbp && (r.lbp = e) : (r = Object.create(g), r.id = t, r.lbp = e, v[t] = r), r
            }

            function i(t) {
                var e, r = f;
                for (l(), e = r.nud(); t < f.lbp;) r = f, l(), e = r.led(e);
                return e
            }

            function o(t, e, r) {
                var o = n(t, e);
                o.led = r || function(t) {
                    return this.children = [t, i(e)], this.type = "binary", this
                }
            }

            function a(t, e, r) {
                var o = n(t, e);
                return o.led = r || function(t) {
                    return this.children = [t, i(e - 1)], this.type = "binary", this
                }, o
            }

            function s(t, e) {
                var r = n(t);
                return r.nud = e || function() {
                    return this.children = [i(70)], this.type = "unary", this
                }, r
            }

            function h(t) {
                var e = n(t, 150);
                e.led = function(t) {
                    return this.children = [t], this.type = "suffix", this
                }
            }

            function u(t) {
                return a(t, 10, function(t) {
                    return this.children = [t, i(9)], this.assignment = !0, this.type = "assign", this
                })
            }

            function l(t) {
                var e, n, i, o;
                if (t && f.data !== t) return p.unexpected("expected `" + t + "`, got `" + f.data + "`");
                if (m >= d.length) return void(f = v["(end)"]);
                if (e = d[m++], n = e.data, i = e.type, "ident" === i) o = p.scope.find(n) || p.create_node(), i = o.type;
                else if ("builtin" === i) o = v["(builtin)"];
                else if ("keyword" === i) o = v["(keyword)"];
                else if ("operator" === i) {
                    if (o = v[n], !o) return p.unexpected("unknown operator `" + n + "`")
                } else {
                    if ("float" !== i && "integer" !== i) return p.unexpected("unexpected token.");
                    i = "literal", o = v["(literal)"]
                }
                return o && (o.nud || (o.nud = r), o.children || (o.children = [])), o = Object.create(o), o.token = e, o.type = i, o.data || (o.data = n), f = o
            }

            function c(t) {
                return function() {
                    return p.unexpected(t)
                }
            }
            var p, f, d, m, g = {
                    nud: function() {
                        return this.children && this.children.length ? this : c("unexpected")()
                    },
                    led: c("missing operator")
                },
                v = {};
            n("(ident)").nud = r, n("(keyword)").nud = r, n("(builtin)").nud = r, n("(literal)").nud = r, n("(end)"), n(":"), n(";"), n(","), n(")"), n("]"), n("}"), a("&&", 30), a("||", 30), o("|", 43), o("^", 44), o("&", 45), o("==", 46), o("!=", 46), o("<", 47), o("<=", 47), o(">", 47), o(">=", 47), o(">>", 48), o("<<", 48), o("+", 50), o("-", 50), o("*", 60), o("/", 60), o("%", 60), o("?", 20, function(t) {
                return this.children = [t, i(0), (l(":"), i(0))], this.type = "ternary", this
            }), o(".", 80, function(t) {
                return f.type = "literal", p.fake(f), this.children = [t, f], l(), this
            }), o("[", 80, function(t) {
                return this.children = [t, i(0)], this.type = "binary", l("]"), this
            }), o("(", 80, function(t) {
                if (this.children = [t], this.type = "call", ")" !== f.data)
                    for (;;) {
                        if (this.children.push(i(0)), "," !== f.data) break;
                        l(",")
                    }
                return l(")"), this
            }), s("-"), s("+"), s("!"), s("~"), s("defined"), s("(", function() {
                return this.type = "group", this.children = [i(0)], l(")"), this
            }), s("++"), s("--"), h("++"), h("--"), u("="), u("+="), u("-="), u("*="), u("/="), u("%="), u("&="), u("|="), u("^="), u(">>="), u("<<="), e.exports = function(t, e) {
                function r(t) {
                    p.unshift(t, !1);
                    for (var e = 0, n = t.children.length; n > e; ++e) r(t.children[e]);
                    p.shift()
                }
                p = t, d = e, m = 0;
                var n;
                if (d.length) {
                    if (l(), n = i(0), n.parent = p[0], r(n), m < d.length) throw new Error("did not use all tokens");
                    n.parent.children = [n]
                }
            }
        }, {}],
        41: [function(t, e) {
            function r() {
                function t(t) {
                    if ("whitespace" === t.type || "line-comment" === t.type || "block-comment" === t.type) return void Ze.push(t);
                    for (Ke.push(t), ke = ke || Ke[0], ke && Ze.length && (ke.preceding = ke.preceding || [], ke.preceding = ke.preceding.concat(Ze), Ze = []); r();) switch (Ye[0].mode) {
                        case d:
                            Z();
                            break;
                        case m:
                            B();
                            break;
                        case y:
                            Q();
                            break;
                        case T:
                            J();
                            break;
                        case R:
                            re();
                            break;
                        case g:
                            Te(!0, !0);
                            break;
                        case w:
                            xe();
                            break;
                        case f:
                            ee();
                            break;
                        case S:
                            te();
                            break;
                        case A:
                            $();
                            break;
                        case v:
                            Se();
                            break;
                        case E:
                            Ae();
                            break;
                        case x:
                            be();
                            break;
                        case _:
                            He();
                            break;
                        case P:
                            Me();
                            break;
                        case C:
                            we();
                            break;
                        case b:
                            Re();
                            break;
                        case F:
                            _e()
                    }
                }

                function e(e) {
                    return arguments.length && t(e), Ye.length > 1 ? void ue("unexpected EOF") : void Xe.emit("end")
                }

                function r() {
                    return Qe || !Ye.length ? !1 : (ke = Ke[0]) && !Xe.paused
                }

                function p(t) {
                    Ye.unshift(t), Ye.shift()
                }

                function H(t, e) {
                    t.parent = Ye[0];
                    var r = [].unshift.call(this, t);
                    if (e = void 0 === e ? !0 : e, c) {
                        for (var n = "", i = 0, o = this.length - 1; o > i; ++i) n += " |";
                        console.log(n, "\\" + t.type, t.token.data)
                    }
                    return e && Le !== t && Le.children.push(t), Le = t, r
                }

                function M() {
                    var t = [].shift.call(this),
                        e = qe[this.length],
                        r = !1;
                    if (c) {
                        for (var n = "", i = 0, o = this.length; o > i; ++i) n += " |";
                        console.log(n, "/" + t.type)
                    }
                    return qe.length ? "function" == typeof qe[0] ? r = qe[0](t) : void 0 !== e && (r = e.test ? e.test(t.type) : e === t.type) : r = !0, r && Xe.emit("data", t), Le = t.parent, t
                }

                function B() {
                    function t() {
                        if (ke.data === Ye[0].expecting) return Ye.scope.exit(), Ye.shift();
                        switch (ke.type) {
                            case "preprocessor":
                                return Ye.fake(ie()), void Ke.shift();
                            default:
                                return void Ye.unshift(Pe())
                        }
                    }
                    return pe(function() {
                        return Ye.scope.enter(), l
                    }, t)()
                }

                function Z() {
                    if (Ye[0].brace) return "}" !== ke.data ? ue("expected `}`, got " + ke.data) : (Ye[0].brace = !1, Ke.shift(), Ye.shift());
                    switch (ke.type) {
                        case "eof":
                            return Ye.shift();
                        case "keyword":
                            switch (ke.data) {
                                case "for":
                                    return Ye.unshift(Ve());
                                case "if":
                                    return Ye.unshift(Ne());
                                case "while":
                                    return Ye.unshift(je());
                                case "do":
                                    return Ye.unshift(Ge());
                                case "break":
                                    return Ye.fake(n(k, ke)), Ke.shift();
                                case "continue":
                                    return Ye.fake(n(L, ke)), Ke.shift();
                                case "discard":
                                    return Ye.fake(n(z, ke)), Ke.shift();
                                case "return":
                                    return Ye.unshift(Ie());
                                case "precision":
                                    return Ye.unshift(Fe())
                            }
                            return Ye.unshift(oe(G));
                        case "ident":
                            var t;
                            if (t = Ye.scope.find(ke.data)) return Ye.unshift("struct" === t.parent.type ? oe(G) : se(";"));
                        case "operator":
                            if ("{" === ke.data) {
                                Ye[0].brace = !0;
                                var e = ze();
                                return e.expecting = "}", Ke.shift(), Ye.unshift(e)
                            }
                            if (";" === ke.data) return Ke.shift(), Ye.shift();
                        default:
                            return Ye.unshift(se(";"))
                    }
                }

                function Q() {
                    function t() {
                        return "invariant" === ke.data ? d.flags & V ? (Ye.unshift(he()), l) : ue("`invariant` is not allowed here") : (Ye.fake(n(D, {
                            data: "",
                            position: ke.position
                        })), l)
                    }

                    function e() {
                        return i(ke) ? d.flags & N ? (Ye.unshift(he()), l) : ue("storage is not allowed here") : (Ye.fake(n(D, {
                            data: "",
                            position: ke.position
                        })), l)
                    }

                    function r() {
                        return o(ke) ? d.flags & j ? ue("parameter is not allowed here") : (Ye.unshift(he()), l) : (Ye.fake(n(D, {
                            data: "",
                            position: ke.position
                        })), l)
                    }

                    function s() {
                        return a(ke) ? (Ye.unshift(he()), l) : (Ye.fake(n(D, {
                            data: "",
                            position: ke.position
                        })), l)
                    }

                    function h() {
                        if ("struct" === ke.data) return d.flags & I ? (Ye.unshift(ae()), l) : ue("cannot nest structs");
                        if ("keyword" === ke.type) return Ye.unshift(he()), l;
                        var t = Ye.scope.find(ke.data);
                        return t ? (Ye.fake(Object.create(t)), Ke.shift(), l) : ue("expected user defined type, struct or keyword, got " + ke.data)
                    }

                    function u() {
                        return "," !== ke.data || d.flags & O ? "[" === ke.data ? void Ye.unshift(We()) : ")" === ke.data ? Ye.shift() : ";" === ke.data ? d.stage + 3 : "ident" !== ke.type ? (console.log(ke), ue("expected identifier, got " + ke.data)) : (d.collected_name = Ke.shift(), l) : Ye.shift()
                    }

                    function c() {
                        return "(" === ke.data ? (Ke.unshift(d.collected_name), delete d.collected_name, Ye.unshift(Oe()), d.stage + 2) : l
                    }

                    function p() {
                        return Ke.unshift(d.collected_name), delete d.collected_name, Ye.unshift(De()), l
                    }

                    function f() {
                        return Ye.shift()
                    }
                    var d = Ye[0];
                    return pe(t, e, r, s, h, u, c, p, f)()
                }

                function J() {
                    if ("ident" === ke.type) {
                        var t = ke.data;
                        return Ye.unshift(Ue()), void Ye.scope.define(t)
                    }
                    if ("operator" === ke.type) {
                        if ("," === ke.data) return Ye[1].flags & O ? Ke.shift() : Ye.shift();
                        if ("=" === ke.data) return Ye[1].flags & U ? (Ke.shift(), void Ye.unshift(se(",", ";"))) : ue("`=` is not allowed here.");
                        if ("[" === ke.data) return void Ye.unshift(We())
                    }
                    return Ye.shift()
                }

                function $() {
                    return "keyword" === ke.type ? (Ye[0].type = "keyword", void(Ye[0].mode = S)) : "ident" === ke.type ? (Ye[0].type = "ident", void(Ye[0].mode = f)) : ue("expected keyword or user-defined name, got " + ke.data)
                }

                function te() {
                    return "keyword" !== ke.type ? ue("expected keyword, got " + ke.data) : (Ye.shift(), Ke.shift())
                }

                function ee() {
                    return "ident" !== ke.type ? ue("expected user-defined name, got " + ke.data) : (Ye[0].data = ke.data, Ye.shift(), Ke.shift())
                }

                function re() {
                    function t(t) {
                        return h(Ye, t), Ye.shift()
                    }
                    var e = Ye[0].expecting;
                    if (Ye[0].tokens = Ye[0].tokens || [], void 0 === Ye[0].parenlevel && (Ye[0].parenlevel = 0, Ye[0].bracelevel = 0), Ye[0].parenlevel < 1 && e.indexOf(ke.data) > -1) return t(Ye[0].tokens);
                    switch ("(" === ke.data ? ++Ye[0].parenlevel : ")" === ke.data && --Ye[0].parenlevel, ke.data) {
                        case "{":
                            ++Ye[0].bracelevel;
                            break;
                        case "}":
                            --Ye[0].bracelevel;
                            break;
                        case "(":
                            ++Ye[0].parenlevel;
                            break;
                        case ")":
                            --Ye[0].parenlevel
                    }
                    return Ye[0].parenlevel < 0 ? ue("unexpected `)`") : Ye[0].bracelevel < 0 ? ue("unexpected `}`") : void Ye[0].tokens.push(Ke.shift())
                }

                function ne(t) {
                    return function() {
                        return n(t, ke)
                    }
                }

                function ie() {
                    return n(K[ke.type], ke, Le)
                }

                function oe(t) {
                    var e = n(y, ke, Le);
                    return e.flags = t, e
                }

                function ae(t, e) {
                    var r = n(g, ke, Le);
                    return r.allow_assign = void 0 === t ? !0 : t, r.allow_comma = void 0 === e ? !0 : e, r
                }

                function se() {
                    var t = n(R, ke, Le);
                    return t.expecting = [].slice.call(arguments), t
                }

                function he(t) {
                    var e = ke;
                    return t && (e = {
                        type: "(implied)",
                        data: "(default)",
                        position: e.position
                    }), n(S, e, Le)
                }

                function ue(t) {
                    Qe = !0, Xe.emit("error", new Error((t || "unexpected " + Ye) + " at line " + Ye[0].token.line))
                }

                function le(t, e) {
                    return ce(t, ke.type) && ce(e, ke.data)
                }

                function ce(t, e) {
                    switch (typeof t) {
                        case "string":
                            return e !== t && ue("expected `" + t + "`, got " + e + "\n" + ke.data), !Qe;
                        case "object":
                            return t && -1 === t.indexOf(e) && ue("expected one of `" + t.join("`, `") + "`, got " + e), !Qe
                    }
                    return !0
                }

                function pe() {
                    var t, e, r = [].slice.call(arguments);
                    return function() {
                        var n = Ye[0];
                        return n.stage || (n.stage = 0), (t = r[n.stage]) ? (e = t(), e === l ? ++n.stage : void(void 0 !== e && (n.stage = e))) : ue("parser in undefined state!")
                    }
                }

                function fe(t, e) {
                    return e = e || "operator",
                        function() {
                            if (le(e, t)) {
                                var r = Ke.shift(),
                                    n = Ye[0].children,
                                    i = n[n.length - 1];
                                return i && i.token && r.preceding && (i.token.succeeding = i.token.succeeding || [], i.token.succeeding = i.token.succeeding.concat(r.preceding)), l
                            }
                        }
                }

                function de(t) {
                    return function() {
                        return Ye.unshift(se(t)), l
                    }
                }

                function me(t) {
                    return t ? function() {
                        var t = ke.data;
                        return le("ident") && (Ye.unshift(Ue()), Ye.scope.define(t), l)
                    } : function() {
                        if (le("ident")) {
                            var t = Object.create(Ye.scope.find(ke.data));
                            return t.token = ke, Ke.shift(), l
                        }
                    }
                }

                function ge() {
                    return function() {
                        var t = ze();
                        return t.expecting = "}", Ye.unshift(t), l
                    }
                }

                function ve(t) {
                    return function() {
                        var e = Ye[0].stage;
                        return "{" !== ke.data ? (Ye.unshift(Pe()), e + t) : (Ke.shift(), l)
                    }
                }

                function Ee() {
                    return function() {
                        return Ye.shift(), Ye.shift()
                    }
                }

                function ye() {
                    Te = pe(fe("struct", "keyword"), function() {
                        return "{" === ke.data ? (Ye.fake(n(f, {
                            data: "",
                            position: ke.position,
                            type: "ident"
                        })), l) : me(!0)()
                    }, function() {
                        return Ye.scope.enter(), l
                    }, fe("{"), function() {
                        return "}" === ke.data ? (Ye.scope.exit(), Ke.shift(), Ye.shift()) : ";" === ke.data ? void Ke.shift() : void Ye.unshift(oe(X))
                    }), xe = pe(function() {
                        return Ke.shift(), l
                    }, function() {
                        return le("keyword", ["lowp", "mediump", "highp"]) && (Ye.unshift(he()), l)
                    }, function() {
                        return Ye.unshift(he()), l
                    }, function() {
                        return Ye.shift()
                    }), _e = pe(fe("["), de("]"), fe("]"), function() {
                        return Ye.shift()
                    }), be = pe(fe("for", "keyword"), fe("("), function() {
                        var t;
                        if ("ident" === ke.type) {
                            if ((t = Ye.scope.find(ke.data)) || (t = Ye.create_node()), "struct" === t.parent.type) return Ye.unshift(oe(G)), l
                        } else if ("builtin" === ke.type || "keyword" === ke.type) return Ye.unshift(oe(G)), l;
                        return de(";")()
                    }, fe(";"), de(";"), fe(";"), de(")"), fe(")"), ve(3), ge(), fe("}"), Ee()), Re = pe(fe("if", "keyword"), fe("("), de(")"), fe(")"), ve(3), ge(), fe("}"), function() {
                        return "else" === ke.data ? (Ke.shift(), Ye.unshift(Pe()), l) : Ee()()
                    }, Ee()), we = pe(fe("return", "keyword"), function() {
                        return ";" === ke.data ? l : (Ye.unshift(se(";")), l)
                    }, function() {
                        Ke.shift(), Ee()()
                    }), He = pe(fe("while", "keyword"), fe("("), de(")"), fe(")"), ve(3), ge(), fe("}"), Ee()), Me = pe(fe("do", "keyword"), ve(3), ge(), fe("}"), fe("while", "keyword"), fe("("), de(")"), fe(")"), Ee()), Se = pe(function() {
                        for (var t = 1, e = Ye.length; e > t; ++t)
                            if (Ye[t].mode === v) return ue("function definition is not allowed within another function");
                        return l
                    }, function() {
                        if (le("ident")) {
                            var t = ke.data,
                                e = Ye.scope.find(t);
                            return Ye.unshift(Ue()), Ye.scope.define(t), Ye.scope.enter(e ? e.scope : null), l
                        }
                    }, fe("("), function() {
                        return Ye.unshift(Be()), l
                    }, fe(")"), function() {
                        return ";" === ke.data ? (Ye.scope.exit(), Ye.shift(), Ye.shift()) : l
                    }, fe("{"), ge(), fe("}"), function() {
                        return Ye.scope.exit(), l
                    }, function() {
                        return Ye.shift(), Ye.shift(), Ye.shift()
                    }), Ae = pe(function() {
                        return "void" === ke.data ? (Ye.fake(he()), Ke.shift(), l) : ")" === ke.data ? void Ye.shift() : "struct" === ke.data ? (Ye.unshift(ae(q, Y)), l) : (Ye.unshift(oe(W)), l)
                    }, function() {
                        return "," === ke.data ? (Ke.shift(), 0) : ")" === ke.data ? void Ye.shift() : void ue("expected one of `,` or `)`, got " + ke.data)
                    })
                }
                var Te, xe, _e, be, Re, we, He, Me, Se, Ae, Ce, ke, Le, ze = ne(m),
                    Pe = ne(d),
                    De = ne(T),
                    Fe = ne(w),
                    Ue = ne(f),
                    Oe = (ne(A), ne(v)),
                    Be = ne(E),
                    Ve = ne(x),
                    Ne = ne(b),
                    je = ne(_),
                    Ie = ne(C),
                    Ge = ne(P),
                    We = ne(F),
                    Xe = s(t, e),
                    qe = arguments.length ? [].slice.call(arguments) : [],
                    Ye = [],
                    Ke = [],
                    Ze = [],
                    Qe = !1;
                return Ye.shift = M, Ye.unshift = H, Ye.fake = p, Ye.unexpected = ue, Ye.scope = new u(Ye), Ye.create_node = function() {
                    var t = n(f, ke);
                    return t.parent = Xe.program, t
                }, ye(), Le = ze(), Le.expecting = "(eof)", Le.mode = m, Le.token = {
                    type: "(program)",
                    data: "(program)"
                }, Ce = Le, Xe.program = Ce, Xe.scope = function(t) {
                    return 1 === arguments.length && (Ye.scope = t), Ye.scope
                }, Ye.unshift(Le), Xe
            }

            function n(t, e) {
                return {
                    mode: t,
                    token: e,
                    children: [],
                    type: Z[t]
                }
            }

            function i(t) {
                return "const" === t.data || "attribute" === t.data || "uniform" === t.data || "varying" === t.data
            }

            function o(t) {
                return "in" === t.data || "inout" === t.data || "out" === t.data
            }

            function a(t) {
                return "highp" === t.data || "mediump" === t.data || "lowp" === t.data
            }
            e.exports = r;
            var s = t("../../through"),
                h = t("./expr"),
                u = t("./scope"),
                l = new Object,
                c = !1,
                p = 0,
                f = p++,
                d = p++,
                m = p++,
                g = p++,
                v = p++,
                E = p++,
                y = p++,
                T = p++,
                x = p++,
                _ = p++,
                b = p++,
                R = p++,
                w = p++,
                H = p++,
                M = p++,
                S = p++,
                A = p++,
                C = p++,
                k = p++,
                L = p++,
                z = p++,
                P = p++,
                D = p++,
                F = p++,
                U = 1,
                O = 2,
                B = 4,
                V = 8,
                N = 16,
                j = 32,
                I = 64,
                G = 255,
                W = G & ~(U | O | j | V | B),
                X = G & ~(U | V | N | I),
                q = !1,
                Y = !1,
                K = {
                    "block-comment": H,
                    "line-comment": H,
                    preprocessor: M
                },
                Z = p = ["ident", "stmt", "stmtlist", "struct", "function", "functionargs", "decl", "decllist", "forloop", "whileloop", "if", "expr", "precision", "comment", "preprocessor", "keyword", "keyword_or_ident", "return", "break", "continue", "discard", "do-while", "placeholder", "quantifier"]
        }, {
            "../../through": 47,
            "./expr": 40,
            "./scope": 42
        }],
        42: [function(t, e) {
            function r(t) {
                return this.constructor !== r ? new r(t) : (this.state = t, this.scopes = [], void(this.current = null))
            }
            e.exports = r;
            var n = r,
                i = n.prototype;
            i.enter = function(t) {
                this.scopes.push(this.current = this.state[0].scope = t || {})
            }, i.exit = function() {
                this.scopes.pop(), this.current = this.scopes[this.scopes.length - 1]
            }, i.define = function(t) {
                this.current[t] = this.state[0]
            }, i.find = function(t) {
                for (var e = this.scopes.length - 1; e > -1; --e)
                    if (this.scopes[e].hasOwnProperty(t)) return this.scopes[e][t];
                return null
            }
        }, {}],
        43: [function(t, e) {
            function r() {
                function t(t) {
                    t.length && F.queue({
                        type: x[B],
                        data: t,
                        position: j,
                        line: N
                    })
                }

                function e(t) {
                    for (U = 0, W += t.toString(), D = W.length; z = W[U], D > U;) switch (B) {
                        case u:
                            U = H();
                            break;
                        case l:
                            U = w();
                            break;
                        case c:
                            U = R();
                            break;
                        case p:
                            U = M();
                            break;
                        case f:
                            U = C();
                            break;
                        case T:
                            U = A();
                            break;
                        case d:
                            U = k();
                            break;
                        case h:
                            U = L();
                            break;
                        case E:
                            U = b();
                            break;
                        case s:
                            U = _()
                    }
                    O += U, W = W.slice(U)
                }

                function r() {
                    V.length && t(V.join("")), B = y, t("(eof)"), F.queue(null)
                }

                function _() {
                    return V = V.length ? [] : V, "/" === P && "*" === z ? (j = O + U - 1, B = u, P = z, U + 1) : "/" === P && "/" === z ? (j = O + U - 1, B = l, P = z, U + 1) : "#" === z ? (B = c, j = O + U, U) : /\s/.test(z) ? (B = E, j = O + U, U) : (I = /\d/.test(z), G = /[^\w_]/.test(z), j = O + U, B = I ? f : G ? p : h, U)
                }

                function b() {
                    return "\n" === z && ++N, /[^\s]/g.test(z) ? (t(V.join("")), B = s, U) : (V.push(z), P = z, U + 1)
                }

                function R() {
                    return "\n" === z && ++N, "\n" === z && "\\" !== P ? (t(V.join("")), B = s, U) : (V.push(z), P = z, U + 1)
                }

                function w() {
                    return R()
                }

                function H() {
                    return "/" === z && "*" === P ? (V.push(z), t(V.join("")), B = s, U + 1) : ("\n" === z && ++N, V.push(z), P = z, U + 1)
                }

                function M() {
                    if ("." === P && /\d/.test(z)) return B = d, U;
                    if ("/" === P && "*" === z) return B = u, U;
                    if ("/" === P && "/" === z) return B = l, U;
                    if ("." === z && V.length) {
                        for (; S(V););
                        return B = d, U
                    }
                    if (";" === z) {
                        if (V.length)
                            for (; S(V););
                        return t(z), B = s, U + 1
                    }
                    var e = 2 === V.length && "=" !== z;
                    if (/[\w_\d\s]/.test(z) || e) {
                        for (; S(V););
                        return B = s, U
                    }
                    return V.push(z), P = z, U + 1
                }

                function S(e) {
                    for (var r, n = 0, i = e.length;;) {
                        r = o.indexOf(e.slice(0, e.length + n).join("")); {
                            if (-1 !== r) return t(o[r]), j += o[r].length, V = V.slice(o[r].length), V.length;
                            if (n -= 1, i -= 1, 0 > i) return 0
                        }
                    }
                }

                function A() {
                    return /[^a-fA-F0-9]/.test(z) ? (t(V.join("")), B = s, U) : (V.push(z), P = z, U + 1)
                }

                function C() {
                    return "." === z ? (V.push(z), B = d, P = z, U + 1) : /[eE]/.test(z) ? (V.push(z), B = d, P = z, U + 1) : "x" === z && 1 === V.length && "0" === V[0] ? (B = T, V.push(z), P = z, U + 1) : /[^\d]/.test(z) ? (t(V.join("")), B = s, U) : (V.push(z), P = z, U + 1)
                }

                function k() {
                    return "f" === z && (V.push(z), P = z, U += 1), /[eE]/.test(z) ? (V.push(z), P = z, U + 1) : /[^\d]/.test(z) ? (t(V.join("")), B = s, U) : (V.push(z), P = z, U + 1)
                }

                function L() {
                    if (/[^\d\w_]/.test(z)) {
                        var e = V.join("");
                        return B = i.indexOf(e) > -1 ? v : a.indexOf(e) > -1 ? g : m, t(V.join("")), B = s, U
                    }
                    return V.push(z), P = z, U + 1
                }
                var z, P, D, F = n(e, r),
                    U = 0,
                    O = 0,
                    B = s,
                    V = [],
                    N = 1,
                    j = 0,
                    I = !1,
                    G = !1,
                    W = "";
                return F
            }
            e.exports = r;
            var n = t("../through"),
                i = t("./lib/literals"),
                o = t("./lib/operators"),
                a = t("./lib/builtins"),
                s = 999,
                h = 9999,
                u = 0,
                l = 1,
                c = 2,
                p = 3,
                f = 4,
                d = 5,
                m = 6,
                g = 7,
                v = 8,
                E = 9,
                y = 10,
                T = 11,
                x = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"]
        }, {
            "../through": 47,
            "./lib/builtins": 44,
            "./lib/literals": 45,
            "./lib/operators": 46
        }],
        44: [function(t, e) {
            e.exports = ["gl_Position", "gl_PointSize", "gl_ClipVertex", "gl_FragCoord", "gl_FrontFacing", "gl_FragColor", "gl_FragData", "gl_FragDepth", "gl_Color", "gl_SecondaryColor", "gl_Normal", "gl_Vertex", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_FogCoord", "gl_MaxLights", "gl_MaxClipPlanes", "gl_MaxTextureUnits", "gl_MaxTextureCoords", "gl_MaxVertexAttribs", "gl_MaxVertexUniformComponents", "gl_MaxVaryingFloats", "gl_MaxVertexTextureImageUnits", "gl_MaxCombinedTextureImageUnits", "gl_MaxTextureImageUnits", "gl_MaxFragmentUniformComponents", "gl_MaxDrawBuffers", "gl_ModelViewMatrix", "gl_ProjectionMatrix", "gl_ModelViewProjectionMatrix", "gl_TextureMatrix", "gl_NormalMatrix", "gl_ModelViewMatrixInverse", "gl_ProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverse", "gl_TextureMatrixInverse", "gl_ModelViewMatrixTranspose", "gl_ProjectionMatrixTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_TextureMatrixTranspose", "gl_ModelViewMatrixInverseTranspose", "gl_ProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_TextureMatrixInverseTranspose", "gl_NormalScale", "gl_DepthRangeParameters", "gl_DepthRange", "gl_ClipPlane", "gl_PointParameters", "gl_Point", "gl_MaterialParameters", "gl_FrontMaterial", "gl_BackMaterial", "gl_LightSourceParameters", "gl_LightSource", "gl_LightModelParameters", "gl_LightModel", "gl_LightModelProducts", "gl_FrontLightModelProduct", "gl_BackLightModelProduct", "gl_LightProducts", "gl_FrontLightProduct", "gl_BackLightProduct", "gl_FogParameters", "gl_Fog", "gl_TextureEnvColor", "gl_EyePlaneS", "gl_EyePlaneT", "gl_EyePlaneR", "gl_EyePlaneQ", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_ObjectPlaneR", "gl_ObjectPlaneQ", "gl_FrontColor", "gl_BackColor", "gl_FrontSecondaryColor", "gl_BackSecondaryColor", "gl_TexCoord", "gl_FogFragCoord", "gl_Color", "gl_SecondaryColor", "gl_TexCoord", "gl_FogFragCoord", "gl_PointCoord", "radians", "degrees", "sin", "cos", "tan", "asin", "acos", "atan", "pow", "exp", "log", "exp2", "log2", "sqrt", "inversesqrt", "abs", "sign", "floor", "ceil", "fract", "mod", "min", "max", "clamp", "mix", "step", "smoothstep", "length", "distance", "dot", "cross", "normalize", "faceforward", "reflect", "refract", "matrixCompMult", "lessThan", "lessThanEqual", "greaterThan", "greaterThanEqual", "equal", "notEqual", "any", "all", "not", "texture2D", "texture2DProj", "texture2DLod", "texture2DProjLod", "textureCube", "textureCubeLod"]
        }, {}],
        45: [function(t, e) {
            e.exports = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"]
        }, {}],
        46: [function(t, e) {
            e.exports = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"]
        }, {}],
        47: [function(t, e) {
            var r;
            r = function(t, e) {
                var r, n;
                return n = [], r = [], {
                    output: n,
                    parser: null,
                    write: t,
                    end: e,
                    process: function(e, r) {
                        return this.parser = e, t(r), this.flush(), this.parser.flush()
                    },
                    flush: function() {
                        return e(), [n, r]
                    },
                    queue: function(t) {
                        var e;
                        return null != t && null != (e = this.parser) ? e.write(t) : void 0
                    },
                    emit: function(t, e) {
                        return "data" === t && null == e.parent && n.push(e), "error" === t ? r.push(e) : void 0
                    }
                }
            }, e.exports = r
        }, {}]
    }, {}, [28]), require = function e(t, r, n) {
        function i(a, s) {
            if (!r[a]) {
                if (!t[a]) {
                    var h = "function" == typeof require && require;
                    if (!s && h) return h(a, !0);
                    if (o) return o(a, !0);
                    throw new Error("Cannot find module '" + a + "'")
                }
                var u = r[a] = {
                    exports: {}
                };
                t[a][0].call(u.exports, function(e) {
                    var r = t[a][1][e];
                    return i(r ? r : e)
                }, u, u.exports, e, t, r, n)
            }
            return r[a].exports
        }
        for (var o = "function" == typeof require && require, a = 0; a < n.length; a++) i(n[a]);
        return i
    }({
        1: [function() {
            window.MathBox.Shaders = {
                "arrow.position": "uniform float arrowSize;\nuniform float arrowSpace;\n\nattribute vec4 position4;\nattribute vec3 arrow;\nattribute vec2 attach;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvoid getArrowGeometry(vec4 xyzw, float near, float far, out vec3 left, out vec3 right, out vec3 start) {\n  right = getPosition(xyzw);\n  left  = getPosition(vec4(near, xyzw.yzw));\n  start = getPosition(vec4(far, xyzw.yzw));\n}\n\nmat4 getArrowMatrix(float size, vec3 left, vec3 right, vec3 start) {\n  \n  vec3 diff = left - right;\n  float l = length(diff);\n  if (l == 0.0) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n  }\n\n  // Construct TBN matrix around shaft\n  vec3 t = normalize(diff);\n  vec3 n = normalize(cross(t, t.yzx + vec3(.1, .2, .3)));\n  vec3 b = cross(n, t);\n  \n  // Shrink arrows when vector gets too small\n  // Approach linear scaling with cubic ease the smaller we get\n  diff = right - start;\n  l = length(diff) * arrowSpace;\n  float mini = clamp((3.0 - l / size) * .333, 0.0, 1.0);\n  float scale = 1.0 - mini * mini * mini;\n  \n  // Size to 2.5:1 ratio\n  size *= scale;\n  float sizeNB = size / 2.5;\n\n  // Anchor at end position\n  return mat4(vec4(n * sizeNB,  0),\n              vec4(b * sizeNB,  0),\n              vec4(t * size, 0),\n              vec4(right,  1.0));\n}\n\nvec3 getArrowPosition() {\n  vec3 left, right, start;\n  \n  getArrowGeometry(position4, attach.x, attach.y, left, right, start);\n  mat4 matrix = getArrowMatrix(arrowSize, left, right, start);\n  return (matrix * vec4(arrow.xyz, 1.0)).xyz;\n\n}\n",
                "axis.position": "uniform vec4 axisStep;\nuniform vec4 axisPosition;\n\nvec4 getAxisPosition(vec4 xyzw) {\n  return axisStep * xyzw.x + axisPosition;\n}\n",
                "cartesian.position": "uniform mat4 viewMatrix;\n\nvec4 getCartesianPosition(vec4 position) {\n  return viewMatrix * vec4(position.xyz, 1.0);\n}\n",
                "cartesian4.position": "uniform vec4 basisScale;\nuniform vec4 basisOffset;\nuniform mat4 viewMatrix;\nuniform vec2 view4D;\n\nvec4 getCartesian4Position(vec4 position) {\n  vec4 pos4 = position * basisScale - basisOffset;\n  vec3 xyz = (viewMatrix * vec4(pos4.xyz, 1.0)).xyz;\n  return vec4(xyz, pos4.w * view4D.y + view4D.x);\n}\n",
                "color.opaque": "vec4 opaqueColor(vec4 color) {\n  return vec4(color.rgb, 1.0);\n}\n",
                "face.position": "attribute vec4 position4;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvec3 getFacePosition() {\n  return getPosition(position4);\n}\n",
                "face.position.normal": "attribute vec4 position4;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvarying vec3 vNormal;\nvarying vec3 vLight;\nvarying vec3 vPosition;\n\nvoid getFaceGeometry(vec4 xyzw, out vec3 pos, out vec3 normal) {\n  vec3 a, b, c;\n\n  a   = getPosition(vec4(xyzw.xyz, 0.0));\n  b   = getPosition(vec4(xyzw.xyz, 1.0));\n  c   = getPosition(vec4(xyzw.xyz, 2.0));\n\n  pos = getPosition(xyzw);\n  normal = normalize(cross(c - a, b - a));\n}\n\nvec3 getFacePositionNormal() {\n  vec3 center, normal;\n\n  getFaceGeometry(position4, center, normal);\n  vNormal   = normal;\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\n  vPosition = -center;\n\n  return center;\n}\n",
                "fragment.clip.dashed": "varying float vClipStrokeWidth;\nvarying float vClipStrokeIndex;\nvarying vec3  vClipStrokeEven;\nvarying vec3  vClipStrokeOdd;\nvarying vec3  vClipStrokePosition;\n\nvoid clipStrokeFragment() {\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\n\n  vec3 tangent;\n  if (odd) {\n    tangent = vClipStrokeOdd;\n  }\n  else {\n    tangent = vClipStrokeEven;\n  }\n\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\n  if (mod(travel, 16.0) > 8.0) {\n    discard;\n  }\n}\n",
                "fragment.clip.dotted": "varying float vClipStrokeWidth;\nvarying float vClipStrokeIndex;\nvarying vec3  vClipStrokeEven;\nvarying vec3  vClipStrokeOdd;\nvarying vec3  vClipStrokePosition;\n\nvoid clipStrokeFragment() {\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\n\n  vec3 tangent;\n  if (odd) {\n    tangent = vClipStrokeOdd;\n  }\n  else {\n    tangent = vClipStrokeEven;\n  }\n\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\n  if (mod(travel, 4.0) > 2.0) {\n    discard;\n  }\n}\n",
                "fragment.clip.ends": "varying vec2 vClipEnds;\n\nvoid clipEndsFragment() {\n  if (vClipEnds.x < 0.0 || vClipEnds.y < 0.0) discard;\n}\n",
                "fragment.color": "void setFragmentColor(vec4 color) {\n  gl_FragColor = color;\n}",
                "grid.position": "uniform vec4 gridPosition;\nuniform vec4 gridStep;\nuniform vec4 gridAxis;\n\nvec4 sampleData(vec2 xy);\n\nvec4 getGridPosition(vec4 xyzw) {\n  vec4 onAxis  = gridAxis * sampleData(vec2(xyzw.y, 0.0)).x;\n  vec4 offAxis = gridStep * xyzw.x + gridPosition;\n  return onAxis + offAxis;\n}\n",
                "join.position": "uniform float joinStride;\nuniform float joinStrideInv;\n\nfloat getIndex(vec4 xyzw);\nvec4 getRest(vec4 xyzw);\nvec4 injectIndices(float a, float b);\n\nvec4 getJoinXYZW(vec4 xyzw) {\n\n  float a = getIndex(xyzw);\n  float b = a * joinStrideInv;\n\n  float integer  = floor(b);\n  float fraction = b - integer;\n  \n  return injectIndices(fraction * joinStride, integer) + getRest(xyzw);\n}\n",
                "lerp.depth": "uniform float sampleRatio;\n\n// External\nvec4 sampleData(vec4 xyzw);\n\nvec4 lerpDepth(vec4 xyzw) {\n  float x = xyzw.z * sampleRatio;\n  float i = floor(x);\n  float f = x - i;\n    \n  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);\n  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);\n  \n  vec4 a = sampleData(xyzw1);\n  vec4 b = sampleData(xyzw2);\n\n  return mix(a, b, f);\n}\n",
                "lerp.height": "uniform float sampleRatio;\n\n// External\nvec4 sampleData(vec4 xyzw);\n\nvec4 lerpHeight(vec4 xyzw) {\n  float x = xyzw.y * sampleRatio;\n  float i = floor(x);\n  float f = x - i;\n    \n  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);\n  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);\n  \n  vec4 a = sampleData(xyzw1);\n  vec4 b = sampleData(xyzw2);\n\n  return mix(a, b, f);\n}\n",
                "lerp.items": "uniform float sampleRatio;\n\n// External\nvec4 sampleData(vec4 xyzw);\n\nvec4 lerpItems(vec4 xyzw) {\n  float x = xyzw.w * sampleRatio;\n  float i = floor(x);\n  float f = x - i;\n    \n  vec4 xyzw1 = vec4(xyzw.xyz, i);\n  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);\n  \n  vec4 a = sampleData(xyzw1);\n  vec4 b = sampleData(xyzw2);\n\n  return mix(a, b, f);\n}\n",
                "lerp.width": "uniform float sampleRatio;\n\n// External\nvec4 sampleData(vec4 xyzw);\n\nvec4 lerpWidth(vec4 xyzw) {\n  float x = xyzw.x * sampleRatio;\n  float i = floor(x);\n  float f = x - i;\n    \n  vec4 xyzw1 = vec4(i, xyzw.yzw);\n  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);\n  \n  vec4 a = sampleData(xyzw1);\n  vec4 b = sampleData(xyzw2);\n\n  return mix(a, b, f);\n}\n",
                "line.clip.ends": "uniform float clipRange;\nuniform vec2  clipStyle;\nuniform float clipSpace;\nuniform float lineWidth;\n\nattribute vec2 strip;\n//attribute vec2 position4;\n\nvarying vec2 vClipEnds;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvoid clipEndsPosition(vec3 pos) {\n\n  // Sample end of line strip\n  vec4 xyzwE = vec4(strip.y, position4.yzw);\n  vec3 end   = getPosition(xyzwE);\n\n  // Sample start of line strip\n  vec4 xyzwS = vec4(strip.x, position4.yzw);\n  vec3 start = getPosition(xyzwS);\n\n  // Measure length and adjust clip range\n  // Approach linear scaling with cubic ease the smaller we get\n  vec3 diff = end - start;\n  float l = length(vec2(length(diff), lineWidth)) * clipSpace;\n  float mini = clamp((3.0 - l / clipRange) * .333, 0.0, 1.0);\n  float scale = 1.0 - mini * mini * mini; \n  float range = clipRange * scale;\n  \n  vClipEnds = vec2(1.0);\n  \n  if (clipStyle.y > 0.0) {\n    // Clip end\n    float d = length(pos - end);\n    vClipEnds.x = d / range - 1.0;\n  }\n\n  if (clipStyle.x > 0.0) {\n    // Clip start \n    float d = length(pos - start);\n    vClipEnds.y = d / range - 1.0;\n  }\n}",
                "line.position": "uniform float lineWidth;\nuniform float lineDepth;\nuniform vec4 geometryClip;\n\nattribute vec2 line;\nattribute vec4 position4;\n\n#ifdef LINE_STROKE\nvarying float vClipStrokeWidth;\nvarying float vClipStrokeIndex;\nvarying vec3  vClipStrokeEven;\nvarying vec3  vClipStrokeOdd;\nvarying vec3  vClipStrokePosition;\n#endif\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvoid getLineGeometry(vec4 xyzw, float edge, out vec3 left, out vec3 center, out vec3 right) {\n  vec4 delta = vec4(1.0, 0.0, 0.0, 0.0);\n\n  center =                 getPosition(xyzw);\n  left   = (edge > -0.5) ? getPosition(xyzw - delta) : center;\n  right  = (edge < 0.5)  ? getPosition(xyzw + delta) : center;\n}\n\nvec3 getLineJoin(float edge, bool odd, vec3 left, vec3 center, vec3 right) {\n  vec2 join = vec2(1.0, 0.0);\n\n  if (center.z < 0.0) {\n    vec4 a = vec4(left.xy, right.xy);\n    vec4 b = a / vec4(left.zz, right.zz);\n\n    vec2 l = b.xy;\n    vec2 r = b.zw;\n    vec2 c = center.xy / center.z;\n\n    vec4 d = vec4(l, c) - vec4(c, r);\n    float l1 = dot(d.xy, d.xy);\n    float l2 = dot(d.zw, d.zw);\n\n    if (l1 + l2 > 0.0) {\n      \n      if (edge > 0.5 || l2 == 0.0) {\n        vec2 nl = normalize(l - c);\n        vec2 tl = vec2(nl.y, -nl.x);\n\n#ifdef LINE_STROKE\n        vClipStrokeEven = vClipStrokeOdd = normalize(left - center);\n#endif\n        join = tl;\n      }\n      else if (edge < -0.5 || l1 == 0.0) {\n        vec2 nr = normalize(c - r);\n        vec2 tr = vec2(nr.y, -nr.x);\n\n#ifdef LINE_STROKE\n        vClipStrokeEven = vClipStrokeOdd = normalize(center - right);\n#endif\n        join = tr;\n      }\n      else {\n        vec2 nl = normalize(d.xy);\n        vec2 nr = normalize(d.zw);\n\n        vec2 tl = vec2(nl.y, -nl.x);\n        vec2 tr = vec2(nr.y, -nr.x);\n\n        vec2 tc = normalize(tl + tr);\n      \n        float cosA = dot(nl, tc);\n        float sinA = max(0.1, abs(dot(tl, tc)));\n        float factor = cosA / sinA;\n        float scale = sqrt(1.0 + factor * factor);\n\n#ifdef LINE_STROKE\n        vec3 stroke1 = normalize(left - center);\n        vec3 stroke2 = normalize(center - right);\n\n        if (odd) {\n          vClipStrokeEven = stroke1;\n          vClipStrokeOdd  = stroke2;\n        }\n        else {\n          vClipStrokeEven = stroke2;\n          vClipStrokeOdd  = stroke1;\n        }\n#endif\n        join = tc * scale;\n      }\n    }\n    else {\n      return vec3(0.0);\n    }\n  }\n    \n  return vec3(join, 0.0);\n}\n\nvec3 getLinePosition() {\n  vec3 left, center, right, join;\n\n  float edge = line.x;\n  float offset = line.y;\n\n  vec4 p = min(geometryClip, position4);\n\n  getLineGeometry(p, edge, left, center, right);\n\n#ifdef LINE_STROKE\n  vClipStrokePosition = center;\n  vClipStrokeIndex = p.x;\n  bool odd = mod(p.x, 2.0) >= 1.0;\n#else\n  bool odd = true;\n#endif\n\n  join = getLineJoin(edge, odd, left, center, right);\n  \n  float width = lineWidth * 0.5;\n  if (lineDepth < 1.0) {\n    width /= mix(1.0/max(0.001, -center.z), 1.0, lineDepth);\n  }\n\n#ifdef LINE_STROKE\n  vClipStrokeWidth = width;\n#endif\n  \n  return center + join * offset * width;\n}\n",
                "map.2d.data": "uniform vec2 dataResolution;\nuniform vec2 dataPointer;\n\nvec2 map2DData(vec2 xy) {\n  return fract((xy + dataPointer) * dataResolution);\n}\n",
                "map.xyzw.2dv": "void mapXyzw2DV(vec4 xyzw, out vec2 xy, out float z) {\n  xy = xyzw.xy;\n  z  = xyzw.z;\n}\n\n",
                "map.xyzw.texture": "uniform float textureItems;\nuniform float textureHeight;\n\nvec2 mapXyzwTexture(vec4 xyzw) {\n  \n  float x = xyzw.x;\n  float y = xyzw.y;\n  float z = xyzw.z;\n  float i = xyzw.w;\n  \n  return vec2(i + x * textureItems, y + z * textureHeight);\n}\n\n",
                "mesh.fragment.color": "varying vec4 vColor;\n\nvec4 getColor(vec4 rgba) {\n  return rgba * vColor;\n}\n",
                "mesh.position": "attribute vec4 position4;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvec3 getMeshPosition() {\n  return getPosition(position4);\n}\n",
                "mesh.vertex.color": "attribute vec4 position4;\nvarying vec4 vColor;\n\n// External\nvec4 getSample(vec4 xyzw);\n\nvoid vertexColor() {\n  vColor = getSample(position4);\n}\n",
                "object.position": "uniform mat4 objectMatrix;\n\nvec4 getObjectPosition(vec4 position) {\n  return objectMatrix * vec4(position.xyz, 1.0);\n}\n",
                "object4.position": "uniform mat4 objectMatrix;\nuniform vec2 object4D;\n\nvec4 getObject4Position(vec4 position) {\n  vec3 xyz = (objectMatrix * vec4(position.xyz, 1.0)).xyz;\n  return vec4(xyz, position.w * object4D.y + object4D.x);\n}\n",
                "polar.position": "uniform float polarBend;\nuniform float polarFocus;\nuniform float polarAspect;\nuniform float polarHelix;\n\nuniform mat4 viewMatrix;\n\nvec4 getPolarPosition(vec4 position) {\n  if (polarBend > 0.0001) {\n\n    vec2 xy = position.xy * vec2(polarBend, polarAspect);\n    float radius = polarFocus + xy.y;\n\n    return viewMatrix * vec4(\n      sin(xy.x) * radius,\n      (cos(xy.x) * radius - polarFocus) / polarAspect,\n      position.z + position.x * polarHelix * polarBend,\n      1.0\n    );\n  }\n  else {\n    return viewMatrix * vec4(position.xyz, 1.0);\n  }\n}",
                "project.position": "uniform float styleZIndex;\n\nvoid setPosition(vec3 position) {\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\n  pos.z *= (1.0 - styleZIndex / 32768.0);\n  gl_Position = pos;\n}\n",
                "project4.position": "uniform mat4 projectionMatrix;\n\nvec4 getProject4Position(vec4 position) {\n  vec3 pos3 = (projectionMatrix * position).xyz;\n  return vec4(pos3, 1.0);\n}\n",
                "raw.position.scale": "uniform vec4 geometryScale;\nattribute vec4 position4;\n\nvec4 getRawPositionScale() {\n  return geometryScale * position4;\n}\n",
                "remap.relative": "uniform vec4 remapFactor;\n\nvec4 remapRelative(vec4 xyzw) {\n  return xyzw * remapFactor;\n}",
                "repeat.position": "uniform vec4 repeatModulus;\n\nvec4 getRepeatXYZW(vec4 xyzw) {\n  return mod(xyzw, repeatModulus);\n}\n",
                "sample.2d": "uniform sampler2D dataTexture;\n\nvec4 sample2D(vec2 uv) {\n  return texture2D(dataTexture, uv);\n}\n",
                "screen.position": "void setScreenPosition(vec4 position) {\n  gl_Position = vec4(position.xy * 2.0 - 1.0, 0.5, 1.0);\n}\n",
                "screen.remap.2d.xyzw": "uniform vec2 remap2DScale;\n\nvec4 screenRemap2Dxyzw(vec2 uv) {\n  return vec4(remap2DScale * uv - vec2(.5), 0.0, 0.0);\n}\n",
                "screen.remap.4d.xyzw": "uniform vec2 remap2DScale;\nuniform vec2 remapModulus;\nuniform vec2 remapModulusInv;\n\nvec4 screenRemap4Dxyzw(vec2 uv) {\n  vec2 st = remap2DScale * uv - .5;\n  vec2 xy = st * remapModulusInv;\n  vec2 ixy = floor(xy);\n  vec2 fxy = xy - ixy;\n  vec2 zw = fxy * remapModulus;\n  return vec4(ixy.x, zw.y, ixy.y, zw.x);\n}\n",
                "spherical.position": "uniform float sphericalBend;\nuniform float sphericalFocus;\nuniform float sphericalAspectX;\nuniform float sphericalAspectY;\nuniform float sphericalScaleY;\n\nuniform mat4 viewMatrix;\n\nvec4 getSphericalPosition(vec4 position) {\n  if (sphericalBend > 0.0001) {\n\n    vec3 xyz = position.xyz * vec3(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);\n    float radius = sphericalFocus + xyz.z;\n    float cosine = cos(xyz.y) * radius;\n\n    return viewMatrix * vec4(\n      sin(xyz.x) * cosine,\n      sin(xyz.y) * radius * sphericalAspectY,\n      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,\n      1.0\n    );\n  }\n  else {\n    return viewMatrix * vec4(position.xyz, 1.0);\n  }\n}",
                "split.position": "uniform float splitStride;\n\nvec2 getIndices(vec4 xyzw);\nvec4 getRest(vec4 xyzw);\nvec4 injectIndex(float v);\n\nvec4 getSplitXYZW(vec4 xyzw) {\n  vec2 uv = getIndices(xyzw);\n  float offset = uv.x + uv.y * splitStride;\n  return injectIndex(offset) + getRest(xyzw);\n}\n",
                "spread.position": "uniform vec4 spreadOffset;\nuniform mat4 spreadMatrix;\n\n// External\nvec4 getValue(vec4 xyzw);\n\nvec4 getSpreadValue(vec4 xyzw) {\n  vec4 sample = getValue(xyzw);\n  return sample + spreadMatrix * (spreadOffset + xyzw);\n}\n",
                "sprite.alpha.circle": "varying float vPixelSize;\n\nfloat getDiscAlpha(float mask) {\n  // Approximation: 1 - x*x is approximately linear around x = 1 with slope 2\n  return vPixelSize * (1.0 - mask);\n  //  return vPixelSize * 2.0 * (1.0 - sqrt(mask));\n}\n",
                "sprite.alpha.circle.hollow": "varying float vPixelSize;\n\nfloat getDiscHollowAlpha(float mask) {\n  return vPixelSize * (0.5 - 2.0 * abs(sqrt(mask) - .75));\n}\n",
                "sprite.alpha.generic": "varying float vPixelSize;\n\nfloat getGenericAlpha(float mask) {\n  return vPixelSize * 2.0 * (1.0 - mask);\n}\n",
                "sprite.alpha.generic.hollow": "varying float vPixelSize;\n\nfloat getGenericHollowAlpha(float mask) {\n  return vPixelSize * (0.5 - 2.0 * abs(mask - .75));\n}\n",
                "sprite.edge": "varying vec2 vSprite;\n\nfloat getSpriteMask(vec2 xy);\nfloat getSpriteAlpha(float mask);\n\nvoid setFragmentColorFill(vec4 color) {\n  float mask = getSpriteMask(vSprite);\n  if (mask > 1.0) {\n    discard;\n  }\n  float alpha = getSpriteAlpha(mask);\n  if (alpha >= 1.0) {\n    discard;\n  }\n  gl_FragColor = vec4(color.rgb, alpha * color.a);\n}\n",
                "sprite.fill": "varying vec2 vSprite;\n\nfloat getSpriteMask(vec2 xy);\nfloat getSpriteAlpha(float mask);\n\nvoid setFragmentColorFill(vec4 color) {\n  float mask = getSpriteMask(vSprite);\n  if (mask > 1.0) {\n    discard;\n  }\n  float alpha = getSpriteAlpha(mask);\n  if (alpha < 1.0) {\n    discard;\n  }\n  gl_FragColor = color;\n}\n\n",
                "sprite.mask.circle": "varying float vPixelSize;\n\nfloat getCircleMask(vec2 uv) {\n  return dot(uv, uv);\n}\n",
                "sprite.mask.diamond": "varying float vPixelSize;\n\nfloat getDiamondMask(vec2 uv) {\n  vec2 a = abs(uv);\n  return a.x + a.y;\n}\n",
                "sprite.mask.square": "varying float vPixelSize;\n\nfloat getSquareMask(vec2 uv) {\n  vec2 a = abs(uv);\n  return max(a.x, a.y);\n}\n",
                "sprite.mask.triangle": "varying float vPixelSize;\n\nfloat getTriangleMask(vec2 uv) {\n  uv.y -= .25;\n  return max(-uv.y, abs(uv.x) * .866 + uv.y * .5 + .6);\n}\n",
                "sprite.position": "uniform float pointSize;\nuniform float renderScale;\n\nattribute vec4 position4;\nattribute vec2 sprite;\n\nvarying vec2 vSprite;\nvarying float vPixelSize;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvec3 getPointPosition() {\n  vec3 center = getPosition(position4);\n\n  float pixelSize = renderScale * pointSize / -center.z;\n  float paddedSize = pixelSize + 0.5;\n  float padFactor = paddedSize / pixelSize;\n\n  vPixelSize = paddedSize;\n  vSprite    = sprite;\n\n  return center + vec3(sprite * pointSize * padFactor, 0.0);\n}\n",
                "stereographic.position": "uniform float stereoBend;\n\nuniform mat4 viewMatrix;\n\nvec4 getStereoPosition(vec4 position) {\n  if (stereoBend > 0.0001) {\n\n    vec3 pos = position.xyz;\n    float r = length(pos);\n    float z = r + pos.z;\n    vec3 project = vec3(pos.xy / z, r);\n    \n    vec3 lerped = mix(pos, project, stereoBend);\n\n    return viewMatrix * vec4(lerped, 1.0);\n  }\n  else {\n    return viewMatrix * vec4(position.xyz, 1.0);\n  }\n}",
                "stereographic4.position": "uniform float stereoBend;\nuniform vec4 basisScale;\nuniform vec4 basisOffset;\nuniform mat4 viewMatrix;\nuniform vec2 view4D;\n\nvec4 getStereographic4Position(vec4 position) {\n  \n  vec4 transformed;\n  if (stereoBend > 0.0001) {\n\n    float r = length(position);\n    float w = r + position.w;\n    vec4 project = vec4(position.xyz / w, r);\n    \n    transformed = mix(position, project, stereoBend);\n  }\n  else {\n    transformed = position;\n  }\n\n  vec4 pos4 = transformed * basisScale - basisOffset;\n  vec3 xyz = (viewMatrix * vec4(pos4.xyz, 1.0)).xyz;\n  return vec4(xyz, pos4.w * view4D.y + view4D.x);\n}\n",
                "stpq.sample.2d": "varying vec2 vST;\n\nvec4 getSample(vec2 st);\n\nvec4 getSTSample() {\n  return getSample(vST);\n}\n",
                "stpq.xyzw.2d": "varying vec2 vST;\n\nvoid setRawST(vec4 xyzw) {\n  vST = xyzw.xy;\n}\n",
                "strip.position.normal": "attribute vec4 position4;\nattribute vec3 strip;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvarying vec3 vNormal;\nvarying vec3 vLight;\nvarying vec3 vPosition;\n\nvoid getStripGeometry(vec4 xyzw, vec3 strip, out vec3 pos, out vec3 normal) {\n  vec3 a, b, c;\n\n  a   = getPosition(xyzw);\n  b   = getPosition(vec4(xyzw.xyz, strip.x));\n  c   = getPosition(vec4(xyzw.xyz, strip.y));\n\n  pos = getPosition(xyzw);\n  normal = normalize(cross(c - a, b - a)) * strip.z;\n}\n\nvec3 getStripPositionNormal() {\n  vec3 center, normal;\n\n  getStripGeometry(position4, strip, center, normal);\n  vNormal   = normal;\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\n  vPosition = -center;\n\n  return center;\n}\n",
                "style.color": "uniform vec3 styleColor;\nuniform float styleOpacity;\n\nvec4 getStyleColor() {\n  return vec4(styleColor, styleOpacity);\n}\n",
                "style.color.shaded": "uniform vec3 styleColor;\nuniform float styleOpacity;\n\nvarying vec3 vNormal;\nvarying vec3 vLight;\nvarying vec3 vPosition;\n\nvec4 getStyleColor() {\n  \n  vec3 color = styleColor * styleColor;\n  vec3 color2 = styleColor;\n\n  vec3 normal = normalize(vNormal);\n  vec3 light = normalize(vLight);\n  vec3 position = normalize(vPosition);\n  \n  float side    = gl_FrontFacing ? -1.0 : 1.0;\n  float cosine  = side * dot(normal, light);\n  float diffuse = mix(max(0.0, cosine), .5 + .5 * cosine, .1);\n  \n  vec3  halfLight = normalize(light + position);\n	float cosineHalf = max(0.0, side * dot(normal, halfLight));\n	float specular = pow(cosineHalf, 16.0);\n	\n	return vec4(sqrt(color * (diffuse * .9 + .05) + .25 * color2 * specular), styleOpacity);\n}\n",
                "surface.position": "attribute vec4 position4;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvec3 getSurfacePosition() {\n  return getPosition(position4);\n}\n",
                "surface.position.normal": "attribute vec4 position4;\nattribute vec2 surface;\n\n// External\nvec3 getPosition(vec4 xyzw);\n\nvoid getSurfaceGeometry(vec4 xyzw, float edgeX, float edgeY, out vec3 left, out vec3 center, out vec3 right, out vec3 up, out vec3 down) {\n  vec4 deltaX = vec4(1.0, 0.0, 0.0, 0.0);\n  vec4 deltaY = vec4(0.0, 1.0, 0.0, 0.0);\n\n  /*\n  // high quality, 5 tap\n  center =                  getPosition(xyzw);\n  left   = (edgeX > -0.5) ? getPosition(xyzw - deltaX) : center;\n  right  = (edgeX < 0.5)  ? getPosition(xyzw + deltaX) : center;\n  down   = (edgeY > -0.5) ? getPosition(xyzw - deltaY) : center;\n  up     = (edgeY < 0.5)  ? getPosition(xyzw + deltaY) : center;\n  */\n  \n  // low quality, 3 tap\n  center =                  getPosition(xyzw);\n  left   =                  center;\n  down   =                  center;\n  right  = (edgeX < 0.5)  ? getPosition(xyzw + deltaX) : (2.0 * center - getPosition(xyzw - deltaX));\n  up     = (edgeY < 0.5)  ? getPosition(xyzw + deltaY) : (2.0 * center - getPosition(xyzw - deltaY));\n}\n\nvec3 getSurfaceNormal(vec3 left, vec3 center, vec3 right, vec3 up, vec3 down) {\n  vec3 dx = right - left;\n  vec3 dy = up    - down;\n  vec3 n = cross(dy, dx);\n  if (length(n) > 0.0) {\n    return normalize(n);\n  }\n  return vec3(0.0, 1.0, 0.0);\n}\n\nvarying vec3 vNormal;\nvarying vec3 vLight;\nvarying vec3 vPosition;\n\nvec3 getSurfacePositionNormal() {\n  vec3 left, center, right, up, down;\n\n  getSurfaceGeometry(position4, surface.x, surface.y, left, center, right, up, down);\n  vNormal   = getSurfaceNormal(left, center, right, up, down);\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);// - center);\n  vPosition = -center;\n  \n  return center;\n}\n",
                "ticks.position": "uniform float tickSize;\nuniform vec4  tickAxis;\nuniform vec4  tickNormal;\n\nvec4 sampleData(vec2 xy);\n\nvec3 transformPosition(vec4 value);\n\nvec3 getTickPosition(vec4 xyzw) {\n\n  const float epsilon = 0.0001;\n  float line = xyzw.x - .5;\n\n  vec4 center = tickAxis * sampleData(vec2(xyzw.y, 0.0));\n  vec4 edge   = tickNormal * epsilon;\n\n  vec4 a = center;\n  vec4 b = center + edge;\n\n  vec3 c = transformPosition(a);\n  vec3 d = transformPosition(b);\n  \n  vec3 mid  = c;\n  vec3 side = normalize(d - c);\n\n  return mid + side * line * tickSize;\n}\n",
                "view.position": "vec3 getViewPosition(vec4 position) {\n  return (viewMatrix * vec4(position.xyz, 1.0)).xyz;\n}"
            }
        }, {}],
        2: [function(t, e, r) {
            function n(t, e, r) {
                if (!(this instanceof n)) return new n(t, e, r);
                var i = typeof t;
                if ("base64" === e && "string" === i)
                    for (t = S(t); t.length % 4 !== 0;) t += "=";
                var o;
                if ("number" === i) o = C(t);
                else if ("string" === i) o = n.byteLength(t, e);
                else {
                    if ("object" !== i) throw new Error("First argument needs to be a number, array or string.");
                    o = C(t.length)
                }
                var a;
                n._useTypedArrays ? a = n._augment(new Uint8Array(o)) : (a = this, a.length = o, a._isBuffer = !0);
                var s;
                if (n._useTypedArrays && "number" == typeof t.byteLength) a._set(t);
                else if (L(t))
                    for (s = 0; o > s; s++) a[s] = n.isBuffer(t) ? t.readUInt8(s) : t[s];
                else if ("string" === i) a.write(t, 0, e);
                else if ("number" === i && !n._useTypedArrays && !r)
                    for (s = 0; o > s; s++) a[s] = 0;
                return a
            }

            function i(t, e, r, i) {
                r = Number(r) || 0;
                var o = t.length - r;
                i ? (i = Number(i), i > o && (i = o)) : i = o;
                var a = e.length;
                I(a % 2 === 0, "Invalid hex string"), i > a / 2 && (i = a / 2);
                for (var s = 0; i > s; s++) {
                    var h = parseInt(e.substr(2 * s, 2), 16);
                    I(!isNaN(h), "Invalid hex string"), t[r + s] = h
                }
                return n._charsWritten = 2 * s, s
            }

            function o(t, e, r, i) {
                var o = n._charsWritten = O(P(e), t, r, i);
                return o
            }

            function a(t, e, r, i) {
                var o = n._charsWritten = O(D(e), t, r, i);
                return o
            }

            function s(t, e, r, n) {
                return a(t, e, r, n)
            }

            function h(t, e, r, i) {
                var o = n._charsWritten = O(U(e), t, r, i);
                return o
            }

            function u(t, e, r, i) {
                var o = n._charsWritten = O(F(e), t, r, i);
                return o
            }

            function l(t, e, r) {
                return G.fromByteArray(0 === e && r === t.length ? t : t.slice(e, r))
            }

            function c(t, e, r) {
                var n = "",
                    i = "";
                r = Math.min(t.length, r);
                for (var o = e; r > o; o++) t[o] <= 127 ? (n += B(i) + String.fromCharCode(t[o]), i = "") : i += "%" + t[o].toString(16);
                return n + B(i)
            }

            function p(t, e, r) {
                var n = "";
                r = Math.min(t.length, r);
                for (var i = e; r > i; i++) n += String.fromCharCode(t[i]);
                return n
            }

            function f(t, e, r) {
                return p(t, e, r)
            }

            function d(t, e, r) {
                var n = t.length;
                (!e || 0 > e) && (e = 0), (!r || 0 > r || r > n) && (r = n);
                for (var i = "", o = e; r > o; o++) i += z(t[o]);
                return i
            }

            function m(t, e, r) {
                for (var n = t.slice(e, r), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                return i
            }

            function g(t, e, r, n) {
                n || (I("boolean" == typeof r, "missing or invalid endian"), I(void 0 !== e && null !== e, "missing offset"), I(e + 1 < t.length, "Trying to read beyond buffer length"));
                var i = t.length;
                if (!(e >= i)) {
                    var o;
                    return r ? (o = t[e], i > e + 1 && (o |= t[e + 1] << 8)) : (o = t[e] << 8, i > e + 1 && (o |= t[e + 1])), o
                }
            }

            function v(t, e, r, n) {
                n || (I("boolean" == typeof r, "missing or invalid endian"), I(void 0 !== e && null !== e, "missing offset"), I(e + 3 < t.length, "Trying to read beyond buffer length"));
                var i = t.length;
                if (!(e >= i)) {
                    var o;
                    return r ? (i > e + 2 && (o = t[e + 2] << 16), i > e + 1 && (o |= t[e + 1] << 8), o |= t[e], i > e + 3 && (o += t[e + 3] << 24 >>> 0)) : (i > e + 1 && (o = t[e + 1] << 16), i > e + 2 && (o |= t[e + 2] << 8), i > e + 3 && (o |= t[e + 3]), o += t[e] << 24 >>> 0), o
                }
            }

            function E(t, e, r, n) {
                n || (I("boolean" == typeof r, "missing or invalid endian"), I(void 0 !== e && null !== e, "missing offset"), I(e + 1 < t.length, "Trying to read beyond buffer length"));
                var i = t.length;
                if (!(e >= i)) {
                    var o = g(t, e, r, !0),
                        a = 32768 & o;
                    return a ? -1 * (65535 - o + 1) : o
                }
            }

            function y(t, e, r, n) {
                n || (I("boolean" == typeof r, "missing or invalid endian"), I(void 0 !== e && null !== e, "missing offset"), I(e + 3 < t.length, "Trying to read beyond buffer length"));
                var i = t.length;
                if (!(e >= i)) {
                    var o = v(t, e, r, !0),
                        a = 2147483648 & o;
                    return a ? -1 * (4294967295 - o + 1) : o
                }
            }

            function T(t, e, r, n) {
                return n || (I("boolean" == typeof r, "missing or invalid endian"), I(e + 3 < t.length, "Trying to read beyond buffer length")), W.read(t, e, r, 23, 4)
            }

            function x(t, e, r, n) {
                return n || (I("boolean" == typeof r, "missing or invalid endian"), I(e + 7 < t.length, "Trying to read beyond buffer length")), W.read(t, e, r, 52, 8)
            }

            function _(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 1 < t.length, "trying to write beyond buffer length"), V(e, 65535));
                var o = t.length;
                if (!(r >= o))
                    for (var a = 0, s = Math.min(o - r, 2); s > a; a++) t[r + a] = (e & 255 << 8 * (n ? a : 1 - a)) >>> 8 * (n ? a : 1 - a)
            }

            function b(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 3 < t.length, "trying to write beyond buffer length"), V(e, 4294967295));
                var o = t.length;
                if (!(r >= o))
                    for (var a = 0, s = Math.min(o - r, 4); s > a; a++) t[r + a] = e >>> 8 * (n ? a : 3 - a) & 255
            }

            function R(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 1 < t.length, "Trying to write beyond buffer length"), N(e, 32767, -32768));
                var o = t.length;
                r >= o || (e >= 0 ? _(t, e, r, n, i) : _(t, 65535 + e + 1, r, n, i))
            }

            function w(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 3 < t.length, "Trying to write beyond buffer length"), N(e, 2147483647, -2147483648));
                var o = t.length;
                r >= o || (e >= 0 ? b(t, e, r, n, i) : b(t, 4294967295 + e + 1, r, n, i))
            }

            function H(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 3 < t.length, "Trying to write beyond buffer length"), j(e, 3.4028234663852886e38, -3.4028234663852886e38));
                var o = t.length;
                r >= o || W.write(t, e, r, n, 23, 4)
            }

            function M(t, e, r, n, i) {
                i || (I(void 0 !== e && null !== e, "missing value"), I("boolean" == typeof n, "missing or invalid endian"), I(void 0 !== r && null !== r, "missing offset"), I(r + 7 < t.length, "Trying to write beyond buffer length"), j(e, 1.7976931348623157e308, -1.7976931348623157e308));
                var o = t.length;
                r >= o || W.write(t, e, r, n, 52, 8)
            }

            function S(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
            }

            function A(t, e, r) {
                return "number" != typeof t ? r : (t = ~~t, t >= e ? e : t >= 0 ? t : (t += e, t >= 0 ? t : 0))
            }

            function C(t) {
                return t = ~~Math.ceil(+t), 0 > t ? 0 : t
            }

            function k(t) {
                return (Array.isArray || function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                })(t)
            }

            function L(t) {
                return k(t) || n.isBuffer(t) || t && "object" == typeof t && "number" == typeof t.length
            }

            function z(t) {
                return 16 > t ? "0" + t.toString(16) : t.toString(16)
            }

            function P(t) {
                for (var e = [], r = 0; r < t.length; r++) {
                    var n = t.charCodeAt(r);
                    if (127 >= n) e.push(t.charCodeAt(r));
                    else {
                        var i = r;
                        n >= 55296 && 57343 >= n && r++;
                        for (var o = encodeURIComponent(t.slice(i, r + 1)).substr(1).split("%"), a = 0; a < o.length; a++) e.push(parseInt(o[a], 16))
                    }
                }
                return e
            }

            function D(t) {
                for (var e = [], r = 0; r < t.length; r++) e.push(255 & t.charCodeAt(r));
                return e
            }

            function F(t) {
                for (var e, r, n, i = [], o = 0; o < t.length; o++) e = t.charCodeAt(o), r = e >> 8, n = e % 256, i.push(n), i.push(r);
                return i
            }

            function U(t) {
                return G.toByteArray(t)
            }

            function O(t, e, r, n) {
                for (var i = 0; n > i && !(i + r >= e.length || i >= t.length); i++) e[i + r] = t[i];
                return i
            }

            function B(t) {
                try {
                    return decodeURIComponent(t)
                } catch (e) {
                    return String.fromCharCode(65533)
                }
            }

            function V(t, e) {
                I("number" == typeof t, "cannot write a non-number as a number"), I(t >= 0, "specified a negative value for writing an unsigned value"), I(e >= t, "value is larger than maximum value for type"), I(Math.floor(t) === t, "value has a fractional component")
            }

            function N(t, e, r) {
                I("number" == typeof t, "cannot write a non-number as a number"), I(e >= t, "value larger than maximum allowed value"), I(t >= r, "value smaller than minimum allowed value"), I(Math.floor(t) === t, "value has a fractional component")
            }

            function j(t, e, r) {
                I("number" == typeof t, "cannot write a non-number as a number"), I(e >= t, "value larger than maximum allowed value"), I(t >= r, "value smaller than minimum allowed value")
            }

            function I(t, e) {
                if (!t) throw new Error(e || "Failed assertion")
            }
            var G = t("base64-js"),
                W = t("ieee754");
            r.Buffer = n, r.SlowBuffer = n, r.INSPECT_MAX_BYTES = 50, n.poolSize = 8192, n._useTypedArrays = function() {
                try {
                    var t = new ArrayBuffer(0),
                        e = new Uint8Array(t);
                    return e.foo = function() {
                        return 42
                    }, 42 === e.foo() && "function" == typeof e.subarray
                } catch (r) {
                    return !1
                }
            }(), n.isEncoding = function(t) {
                switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "raw":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, n.isBuffer = function(t) {
                return !(null === t || void 0 === t || !t._isBuffer)
            }, n.byteLength = function(t, e) {
                var r;
                switch (t += "", e || "utf8") {
                    case "hex":
                        r = t.length / 2;
                        break;
                    case "utf8":
                    case "utf-8":
                        r = P(t).length;
                        break;
                    case "ascii":
                    case "binary":
                    case "raw":
                        r = t.length;
                        break;
                    case "base64":
                        r = U(t).length;
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        r = 2 * t.length;
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return r
            }, n.concat = function(t, e) {
                if (I(k(t), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === t.length) return new n(0);
                if (1 === t.length) return t[0];
                var r;
                if ("number" != typeof e)
                    for (e = 0, r = 0; r < t.length; r++) e += t[r].length;
                var i = new n(e),
                    o = 0;
                for (r = 0; r < t.length; r++) {
                    var a = t[r];
                    a.copy(i, o), o += a.length
                }
                return i
            }, n.prototype.write = function(t, e, r, n) {
                if (isFinite(e)) isFinite(r) || (n = r, r = void 0);
                else {
                    var l = n;
                    n = e, e = r, r = l
                }
                e = Number(e) || 0;
                var c = this.length - e;
                r ? (r = Number(r), r > c && (r = c)) : r = c, n = String(n || "utf8").toLowerCase();
                var p;
                switch (n) {
                    case "hex":
                        p = i(this, t, e, r);
                        break;
                    case "utf8":
                    case "utf-8":
                        p = o(this, t, e, r);
                        break;
                    case "ascii":
                        p = a(this, t, e, r);
                        break;
                    case "binary":
                        p = s(this, t, e, r);
                        break;
                    case "base64":
                        p = h(this, t, e, r);
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        p = u(this, t, e, r);
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return p
            }, n.prototype.toString = function(t, e, r) {
                var n = this;
                if (t = String(t || "utf8").toLowerCase(), e = Number(e) || 0, r = void 0 !== r ? Number(r) : r = n.length, r === e) return "";
                var i;
                switch (t) {
                    case "hex":
                        i = d(n, e, r);
                        break;
                    case "utf8":
                    case "utf-8":
                        i = c(n, e, r);
                        break;
                    case "ascii":
                        i = p(n, e, r);
                        break;
                    case "binary":
                        i = f(n, e, r);
                        break;
                    case "base64":
                        i = l(n, e, r);
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        i = m(n, e, r);
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return i
            }, n.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, n.prototype.copy = function(t, e, r, i) {
                var o = this;
                if (r || (r = 0), i || 0 === i || (i = this.length), e || (e = 0), i !== r && 0 !== t.length && 0 !== o.length) {
                    I(i >= r, "sourceEnd < sourceStart"), I(e >= 0 && e < t.length, "targetStart out of bounds"), I(r >= 0 && r < o.length, "sourceStart out of bounds"), I(i >= 0 && i <= o.length, "sourceEnd out of bounds"), i > this.length && (i = this.length), t.length - e < i - r && (i = t.length - e + r);
                    var a = i - r;
                    if (100 > a || !n._useTypedArrays)
                        for (var s = 0; a > s; s++) t[s + e] = this[s + r];
                    else t._set(this.subarray(r, r + a), e)
                }
            }, n.prototype.slice = function(t, e) {
                var r = this.length;
                if (t = A(t, r, 0), e = A(e, r, r), n._useTypedArrays) return n._augment(this.subarray(t, e));
                for (var i = e - t, o = new n(i, void 0, !0), a = 0; i > a; a++) o[a] = this[a + t];
                return o
            }, n.prototype.get = function(t) {
                return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(t)
            }, n.prototype.set = function(t, e) {
                return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(t, e)
            }, n.prototype.readUInt8 = function(t, e) {
                return e || (I(void 0 !== t && null !== t, "missing offset"), I(t < this.length, "Trying to read beyond buffer length")), t >= this.length ? void 0 : this[t]
            }, n.prototype.readUInt16LE = function(t, e) {
                return g(this, t, !0, e)
            }, n.prototype.readUInt16BE = function(t, e) {
                return g(this, t, !1, e)
            }, n.prototype.readUInt32LE = function(t, e) {
                return v(this, t, !0, e)
            }, n.prototype.readUInt32BE = function(t, e) {
                return v(this, t, !1, e)
            }, n.prototype.readInt8 = function(t, e) {
                if (e || (I(void 0 !== t && null !== t, "missing offset"), I(t < this.length, "Trying to read beyond buffer length")), !(t >= this.length)) {
                    var r = 128 & this[t];
                    return r ? -1 * (255 - this[t] + 1) : this[t]
                }
            }, n.prototype.readInt16LE = function(t, e) {
                return E(this, t, !0, e)
            }, n.prototype.readInt16BE = function(t, e) {
                return E(this, t, !1, e)
            }, n.prototype.readInt32LE = function(t, e) {
                return y(this, t, !0, e)
            }, n.prototype.readInt32BE = function(t, e) {
                return y(this, t, !1, e)
            }, n.prototype.readFloatLE = function(t, e) {
                return T(this, t, !0, e)
            }, n.prototype.readFloatBE = function(t, e) {
                return T(this, t, !1, e)
            }, n.prototype.readDoubleLE = function(t, e) {
                return x(this, t, !0, e)
            }, n.prototype.readDoubleBE = function(t, e) {
                return x(this, t, !1, e)
            }, n.prototype.writeUInt8 = function(t, e, r) {
                r || (I(void 0 !== t && null !== t, "missing value"), I(void 0 !== e && null !== e, "missing offset"), I(e < this.length, "trying to write beyond buffer length"), V(t, 255)), e >= this.length || (this[e] = t)
            }, n.prototype.writeUInt16LE = function(t, e, r) {
                _(this, t, e, !0, r)
            }, n.prototype.writeUInt16BE = function(t, e, r) {
                _(this, t, e, !1, r)
            }, n.prototype.writeUInt32LE = function(t, e, r) {
                b(this, t, e, !0, r)
            }, n.prototype.writeUInt32BE = function(t, e, r) {
                b(this, t, e, !1, r)
            }, n.prototype.writeInt8 = function(t, e, r) {
                r || (I(void 0 !== t && null !== t, "missing value"), I(void 0 !== e && null !== e, "missing offset"), I(e < this.length, "Trying to write beyond buffer length"), N(t, 127, -128)), e >= this.length || (t >= 0 ? this.writeUInt8(t, e, r) : this.writeUInt8(255 + t + 1, e, r))
            }, n.prototype.writeInt16LE = function(t, e, r) {
                R(this, t, e, !0, r)
            }, n.prototype.writeInt16BE = function(t, e, r) {
                R(this, t, e, !1, r)
            }, n.prototype.writeInt32LE = function(t, e, r) {
                w(this, t, e, !0, r)
            }, n.prototype.writeInt32BE = function(t, e, r) {
                w(this, t, e, !1, r)
            }, n.prototype.writeFloatLE = function(t, e, r) {
                H(this, t, e, !0, r)
            }, n.prototype.writeFloatBE = function(t, e, r) {
                H(this, t, e, !1, r)
            }, n.prototype.writeDoubleLE = function(t, e, r) {
                M(this, t, e, !0, r)
            }, n.prototype.writeDoubleBE = function(t, e, r) {
                M(this, t, e, !1, r)
            }, n.prototype.fill = function(t, e, r) {
                if (t || (t = 0), e || (e = 0), r || (r = this.length), "string" == typeof t && (t = t.charCodeAt(0)), I("number" == typeof t && !isNaN(t), "value is not a number"), I(r >= e, "end < start"), r !== e && 0 !== this.length) {
                    I(e >= 0 && e < this.length, "start out of bounds"), I(r >= 0 && r <= this.length, "end out of bounds");
                    for (var n = e; r > n; n++) this[n] = t
                }
            }, n.prototype.inspect = function() {
                for (var t = [], e = this.length, n = 0; e > n; n++)
                    if (t[n] = z(this[n]), n === r.INSPECT_MAX_BYTES) {
                        t[n + 1] = "...";
                        break
                    }
                return "<Buffer " + t.join(" ") + ">"
            }, n.prototype.toArrayBuffer = function() {
                if ("undefined" != typeof Uint8Array) {
                    if (n._useTypedArrays) return new n(this).buffer;
                    for (var t = new Uint8Array(this.length), e = 0, r = t.length; r > e; e += 1) t[e] = this[e];
                    return t.buffer
                }
                throw new Error("Buffer.toArrayBuffer not supported in this browser")
            };
            var X = n.prototype;
            n._augment = function(t) {
                return t._isBuffer = !0, t._get = t.get, t._set = t.set, t.get = X.get, t.set = X.set, t.write = X.write, t.toString = X.toString, t.toLocaleString = X.toString, t.toJSON = X.toJSON, t.copy = X.copy, t.slice = X.slice, t.readUInt8 = X.readUInt8, t.readUInt16LE = X.readUInt16LE, t.readUInt16BE = X.readUInt16BE, t.readUInt32LE = X.readUInt32LE, t.readUInt32BE = X.readUInt32BE, t.readInt8 = X.readInt8, t.readInt16LE = X.readInt16LE, t.readInt16BE = X.readInt16BE, t.readInt32LE = X.readInt32LE, t.readInt32BE = X.readInt32BE, t.readFloatLE = X.readFloatLE, t.readFloatBE = X.readFloatBE, t.readDoubleLE = X.readDoubleLE, t.readDoubleBE = X.readDoubleBE, t.writeUInt8 = X.writeUInt8, t.writeUInt16LE = X.writeUInt16LE, t.writeUInt16BE = X.writeUInt16BE, t.writeUInt32LE = X.writeUInt32LE, t.writeUInt32BE = X.writeUInt32BE, t.writeInt8 = X.writeInt8, t.writeInt16LE = X.writeInt16LE, t.writeInt16BE = X.writeInt16BE, t.writeInt32LE = X.writeInt32LE, t.writeInt32BE = X.writeInt32BE, t.writeFloatLE = X.writeFloatLE, t.writeFloatBE = X.writeFloatBE, t.writeDoubleLE = X.writeDoubleLE, t.writeDoubleBE = X.writeDoubleBE, t.fill = X.fill, t.inspect = X.inspect, t.toArrayBuffer = X.toArrayBuffer, t
            }
        }, {
            "base64-js": 3,
            ieee754: 4
        }],
        3: [function(t, e) {
            var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            ! function() {
                "use strict";

                function t(t) {
                    var e = t.charCodeAt(0);
                    return e === a ? 62 : e === s ? 63 : h > e ? -1 : h + 10 > e ? e - h + 26 + 26 : l + 26 > e ? e - l : u + 26 > e ? e - u + 26 : void 0
                }

                function n(e) {
                    function r(t) {
                        u[c++] = t
                    }
                    var n, i, a, s, h, u;
                    if (e.length % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                    var l = e.length;
                    h = "=" === e.charAt(l - 2) ? 2 : "=" === e.charAt(l - 1) ? 1 : 0, u = new o(3 * e.length / 4 - h), a = h > 0 ? e.length - 4 : e.length;
                    var c = 0;
                    for (n = 0, i = 0; a > n; n += 4, i += 3) s = t(e.charAt(n)) << 18 | t(e.charAt(n + 1)) << 12 | t(e.charAt(n + 2)) << 6 | t(e.charAt(n + 3)), r((16711680 & s) >> 16), r((65280 & s) >> 8), r(255 & s);
                    return 2 === h ? (s = t(e.charAt(n)) << 2 | t(e.charAt(n + 1)) >> 4, r(255 & s)) : 1 === h && (s = t(e.charAt(n)) << 10 | t(e.charAt(n + 1)) << 4 | t(e.charAt(n + 2)) >> 2, r(s >> 8 & 255), r(255 & s)), u
                }

                function i(t) {
                    function e(t) {
                        return r.charAt(t)
                    }

                    function n(t) {
                        return e(t >> 18 & 63) + e(t >> 12 & 63) + e(t >> 6 & 63) + e(63 & t)
                    }
                    var i, o, a, s = t.length % 3,
                        h = "";
                    for (i = 0, a = t.length - s; a > i; i += 3) o = (t[i] << 16) + (t[i + 1] << 8) + t[i + 2], h += n(o);
                    switch (s) {
                        case 1:
                            o = t[t.length - 1], h += e(o >> 2), h += e(o << 4 & 63), h += "==";
                            break;
                        case 2:
                            o = (t[t.length - 2] << 8) + t[t.length - 1], h += e(o >> 10), h += e(o >> 4 & 63), h += e(o << 2 & 63), h += "="
                    }
                    return h
                }
                var o = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                    a = ("0".charCodeAt(0), "+".charCodeAt(0)),
                    s = "/".charCodeAt(0),
                    h = "0".charCodeAt(0),
                    u = "a".charCodeAt(0),
                    l = "A".charCodeAt(0);
                e.exports.toByteArray = n, e.exports.fromByteArray = i
            }()
        }, {}],
        4: [function(t, e, r) {
            r.read = function(t, e, r, n, i) {
                var o, a, s = 8 * i - n - 1,
                    h = (1 << s) - 1,
                    u = h >> 1,
                    l = -7,
                    c = r ? i - 1 : 0,
                    p = r ? -1 : 1,
                    f = t[e + c];
                for (c += p, o = f & (1 << -l) - 1, f >>= -l, l += s; l > 0; o = 256 * o + t[e + c], c += p, l -= 8);
                for (a = o & (1 << -l) - 1, o >>= -l, l += n; l > 0; a = 256 * a + t[e + c], c += p, l -= 8);
                if (0 === o) o = 1 - u;
                else {
                    if (o === h) return a ? 0 / 0 : 1 / 0 * (f ? -1 : 1);
                    a += Math.pow(2, n), o -= u
                }
                return (f ? -1 : 1) * a * Math.pow(2, o - n)
            }, r.write = function(t, e, r, n, i, o) {
                var a, s, h, u = 8 * o - i - 1,
                    l = (1 << u) - 1,
                    c = l >> 1,
                    p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    f = n ? 0 : o - 1,
                    d = n ? 1 : -1,
                    m = 0 > e || 0 === e && 0 > 1 / e ? 1 : 0;
                for (e = Math.abs(e), isNaN(e) || 1 / 0 === e ? (s = isNaN(e) ? 1 : 0, a = l) : (a = Math.floor(Math.log(e) / Math.LN2), e * (h = Math.pow(2, -a)) < 1 && (a--, h *= 2), e += a + c >= 1 ? p / h : p * Math.pow(2, 1 - c), e * h >= 2 && (a++, h /= 2), a + c >= l ? (s = 0, a = l) : a + c >= 1 ? (s = (e * h - 1) * Math.pow(2, i), a += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & s, f += d, s /= 256, i -= 8);
                for (a = a << i | s, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);
                t[r + f - d] |= 128 * m
            }
        }, {}],
        5: [function(t, e) {
            function r() {
                this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
            }

            function n(t) {
                return "function" == typeof t
            }

            function i(t) {
                return "number" == typeof t
            }

            function o(t) {
                return "object" == typeof t && null !== t
            }

            function a(t) {
                return void 0 === t
            }
            e.exports = r, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._maxListeners = void 0, r.defaultMaxListeners = 10, r.prototype.setMaxListeners = function(t) {
                if (!i(t) || 0 > t || isNaN(t)) throw TypeError("n must be a positive number");
                return this._maxListeners = t, this
            }, r.prototype.emit = function(t) {
                var e, r, i, s, h, u;
                if (this._events || (this._events = {}), "error" === t && (!this._events.error || o(this._events.error) && !this._events.error.length)) throw e = arguments[1], e instanceof Error ? e : TypeError('Uncaught, unspecified "error" event.');
                if (r = this._events[t], a(r)) return !1;
                if (n(r)) switch (arguments.length) {
                    case 1:
                        r.call(this);
                        break;
                    case 2:
                        r.call(this, arguments[1]);
                        break;
                    case 3:
                        r.call(this, arguments[1], arguments[2]);
                        break;
                    default:
                        for (i = arguments.length, s = new Array(i - 1), h = 1; i > h; h++) s[h - 1] = arguments[h];
                        r.apply(this, s)
                } else if (o(r)) {
                    for (i = arguments.length, s = new Array(i - 1), h = 1; i > h; h++) s[h - 1] = arguments[h];
                    for (u = r.slice(), i = u.length, h = 0; i > h; h++) u[h].apply(this, s)
                }
                return !0
            }, r.prototype.addListener = function(t, e) {
                var i;
                if (!n(e)) throw TypeError("listener must be a function");
                if (this._events || (this._events = {}), this._events.newListener && this.emit("newListener", t, n(e.listener) ? e.listener : e), this._events[t] ? o(this._events[t]) ? this._events[t].push(e) : this._events[t] = [this._events[t], e] : this._events[t] = e, o(this._events[t]) && !this._events[t].warned) {
                    var i;
                    i = a(this._maxListeners) ? r.defaultMaxListeners : this._maxListeners, i && i > 0 && this._events[t].length > i && (this._events[t].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[t].length), "function" == typeof console.trace && console.trace())
                }
                return this
            }, r.prototype.on = r.prototype.addListener, r.prototype.once = function(t, e) {
                function r() {
                    this.removeListener(t, r), i || (i = !0, e.apply(this, arguments))
                }
                if (!n(e)) throw TypeError("listener must be a function");
                var i = !1;
                return r.listener = e, this.on(t, r), this
            }, r.prototype.removeListener = function(t, e) {
                var r, i, a, s;
                if (!n(e)) throw TypeError("listener must be a function");
                if (!this._events || !this._events[t]) return this;
                if (r = this._events[t], a = r.length, i = -1, r === e || n(r.listener) && r.listener === e) delete this._events[t], this._events.removeListener && this.emit("removeListener", t, e);
                else if (o(r)) {
                    for (s = a; s-- > 0;)
                        if (r[s] === e || r[s].listener && r[s].listener === e) {
                            i = s;
                            break
                        }
                    if (0 > i) return this;
                    1 === r.length ? (r.length = 0, delete this._events[t]) : r.splice(i, 1), this._events.removeListener && this.emit("removeListener", t, e)
                }
                return this
            }, r.prototype.removeAllListeners = function(t) {
                var e, r;
                if (!this._events) return this;
                if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[t] && delete this._events[t], this;
                if (0 === arguments.length) {
                    for (e in this._events) "removeListener" !== e && this.removeAllListeners(e);
                    return this.removeAllListeners("removeListener"), this._events = {}, this
                }
                if (r = this._events[t], n(r)) this.removeListener(t, r);
                else
                    for (; r.length;) this.removeListener(t, r[r.length - 1]);
                return delete this._events[t], this
            }, r.prototype.listeners = function(t) {
                var e;
                return e = this._events && this._events[t] ? n(this._events[t]) ? [this._events[t]] : this._events[t].slice() : []
            }, r.listenerCount = function(t, e) {
                var r;
                return r = t._events && t._events[e] ? n(t._events[e]) ? 1 : t._events[e].length : 0
            }
        }, {}],
        6: [function(t, e) {
            e.exports = "function" == typeof Object.create ? function(t, e) {
                t.super_ = e, t.prototype = Object.create(e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                })
            } : function(t, e) {
                t.super_ = e;
                var r = function() {};
                r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
            }
        }, {}],
        7: [function(t, e) {
            function r() {}
            var n = e.exports = {};
            n.nextTick = function() {
                var t = "undefined" != typeof window && window.setImmediate,
                    e = "undefined" != typeof window && window.postMessage && window.addEventListener;
                if (t) return function(t) {
                    return window.setImmediate(t)
                };
                if (e) {
                    var r = [];
                    return window.addEventListener("message", function(t) {
                            var e = t.source;
                            if ((e === window || null === e) && "process-tick" === t.data && (t.stopPropagation(), r.length > 0)) {
                                var n = r.shift();
                                n()
                            }
                        }, !0),
                        function(t) {
                            r.push(t), window.postMessage("process-tick", "*")
                        }
                }
                return function(t) {
                    setTimeout(t, 0)
                }
            }(), n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.on = r, n.addListener = r, n.once = r, n.off = r, n.removeListener = r, n.removeAllListeners = r, n.emit = r, n.binding = function() {
                throw new Error("process.binding is not supported")
            }, n.cwd = function() {
                return "/"
            }, n.chdir = function() {
                throw new Error("process.chdir is not supported")
            }
        }, {}],
        8: [function(t, e) {
            function r(t) {
                return this instanceof r ? (a.call(this, t), s.call(this, t), t && t.readable === !1 && (this.readable = !1), t && t.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, t && t.allowHalfOpen === !1 && (this.allowHalfOpen = !1), void this.once("end", n)) : new r(t)
            }

            function n() {
                if (!this.allowHalfOpen && !this._writableState.ended) {
                    var t = this;
                    o(function() {
                        t.end()
                    })
                }
            }
            e.exports = r;
            var i = t("inherits"),
                o = t("process/browser.js").nextTick,
                a = t("./readable.js"),
                s = t("./writable.js");
            i(r, a), r.prototype.write = s.prototype.write, r.prototype.end = s.prototype.end, r.prototype._write = s.prototype._write
        }, {
            "./readable.js": 12,
            "./writable.js": 14,
            inherits: 6,
            "process/browser.js": 10
        }],
        9: [function(t, e) {
            function r() {
                n.call(this)
            }
            e.exports = r;
            var n = t("events").EventEmitter,
                i = t("inherits");
            i(r, n), r.Readable = t("./readable.js"), r.Writable = t("./writable.js"), r.Duplex = t("./duplex.js"), r.Transform = t("./transform.js"), r.PassThrough = t("./passthrough.js"), r.Stream = r, r.prototype.pipe = function(t, e) {
                function r(e) {
                    t.writable && !1 === t.write(e) && u.pause && u.pause()
                }

                function i() {
                    u.readable && u.resume && u.resume()
                }

                function o() {
                    l || (l = !0, t.end())
                }

                function a() {
                    l || (l = !0, "function" == typeof t.destroy && t.destroy())
                }

                function s(t) {
                    if (h(), 0 === n.listenerCount(this, "error")) throw t
                }

                function h() {
                    u.removeListener("data", r), t.removeListener("drain", i), u.removeListener("end", o), u.removeListener("close", a), u.removeListener("error", s), t.removeListener("error", s), u.removeListener("end", h), u.removeListener("close", h), t.removeListener("close", h)
                }
                var u = this;
                u.on("data", r), t.on("drain", i), t._isStdio || e && e.end === !1 || (u.on("end", o), u.on("close", a));
                var l = !1;
                return u.on("error", s), t.on("error", s), u.on("end", h), u.on("close", h), t.on("close", h), t.emit("pipe", u), t
            }
        }, {
            "./duplex.js": 8,
            "./passthrough.js": 11,
            "./readable.js": 12,
            "./transform.js": 13,
            "./writable.js": 14,
            events: 5,
            inherits: 6
        }],
        10: [function(t, e) {
            var r = e.exports = {};
            r.nextTick = function() {
                var t = "undefined" != typeof window && window.setImmediate,
                    e = "undefined" != typeof window && window.postMessage && window.addEventListener;
                if (t) return function(t) {
                    return window.setImmediate(t)
                };
                if (e) {
                    var r = [];
                    return window.addEventListener("message", function(t) {
                            var e = t.source;
                            if ((e === window || null === e) && "process-tick" === t.data && (t.stopPropagation(), r.length > 0)) {
                                var n = r.shift();
                                n()
                            }
                        }, !0),
                        function(t) {
                            r.push(t), window.postMessage("process-tick", "*")
                        }
                }
                return function(t) {
                    setTimeout(t, 0)
                }
            }(), r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.binding = function() {
                throw new Error("process.binding is not supported")
            }, r.cwd = function() {
                return "/"
            }, r.chdir = function() {
                throw new Error("process.chdir is not supported")
            }
        }, {}],
        11: [function(t, e) {
            function r(t) {
                return this instanceof r ? void n.call(this, t) : new r(t)
            }
            e.exports = r;
            var n = t("./transform.js"),
                i = t("inherits");
            i(r, n), r.prototype._transform = function(t, e, r) {
                r(null, t)
            }
        }, {
            "./transform.js": 13,
            inherits: 6
        }],
        12: [function(t, e) {
            (function(r) {
                function n(e) {
                    e = e || {};
                    var r = e.highWaterMark;
                    this.highWaterMark = r || 0 === r ? r : 16384, this.highWaterMark = ~~this.highWaterMark, this.buffer = [], this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = !1, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.calledRead = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.objectMode = !!e.objectMode, this.defaultEncoding = e.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (b || (b = t("string_decoder").StringDecoder), this.decoder = new b(e.encoding), this.encoding = e.encoding)
                }

                function i(t) {
                    return this instanceof i ? (this._readableState = new n(t, this), this.readable = !0, void w.call(this)) : new i(t)
                }

                function o(t, e, r, n, i) {
                    var o = u(e, r);
                    if (o) t.emit("error", o);
                    else if (null === r || void 0 === r) e.reading = !1, e.ended || l(t, e);
                    else if (e.objectMode || r && r.length > 0)
                        if (e.ended && !i) {
                            var s = new Error("stream.push() after EOF");
                            t.emit("error", s)
                        } else if (e.endEmitted && i) {
                        var s = new Error("stream.unshift() after end event");
                        t.emit("error", s)
                    } else !e.decoder || i || n || (r = e.decoder.write(r)), e.length += e.objectMode ? 1 : r.length, i ? e.buffer.unshift(r) : (e.reading = !1, e.buffer.push(r)), e.needReadable && c(t), f(t, e);
                    else i || (e.reading = !1);
                    return a(e)
                }

                function a(t) {
                    return !t.ended && (t.needReadable || t.length < t.highWaterMark || 0 === t.length)
                }

                function s(t) {
                    if (t >= A) t = A;
                    else {
                        t--;
                        for (var e = 1; 32 > e; e <<= 1) t |= t >> e;
                        t++
                    }
                    return t
                }

                function h(t, e) {
                    return 0 === e.length && e.ended ? 0 : e.objectMode ? 0 === t ? 0 : 1 : isNaN(t) || null === t ? e.flowing && e.buffer.length ? e.buffer[0].length : e.length : 0 >= t ? 0 : (t > e.highWaterMark && (e.highWaterMark = s(t)), t > e.length ? e.ended ? e.length : (e.needReadable = !0, 0) : t)
                }

                function u(t, e) {
                    var r = null;
                    return H.isBuffer(e) || "string" == typeof e || null === e || void 0 === e || t.objectMode || r || (r = new TypeError("Invalid non-string/buffer chunk")), r
                }

                function l(t, e) {
                    if (e.decoder && !e.ended) {
                        var r = e.decoder.end();
                        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length)
                    }
                    e.ended = !0, e.length > 0 ? c(t) : T(t)
                }

                function c(t) {
                    var e = t._readableState;
                    e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, e.sync ? M(function() {
                        p(t)
                    }) : p(t))
                }

                function p(t) {
                    t.emit("readable")
                }

                function f(t, e) {
                    e.readingMore || (e.readingMore = !0, M(function() {
                        d(t, e)
                    }))
                }

                function d(t, e) {
                    for (var r = e.length; !e.reading && !e.flowing && !e.ended && e.length < e.highWaterMark && (t.read(0), r !== e.length);) r = e.length;
                    e.readingMore = !1
                }

                function m(t) {
                    return function() {
                        var e = t._readableState;
                        e.awaitDrain--, 0 === e.awaitDrain && g(t)
                    }
                }

                function g(t) {
                    function e(t) {
                        var e = t.write(r);
                        !1 === e && n.awaitDrain++
                    }
                    var r, n = t._readableState;
                    for (n.awaitDrain = 0; n.pipesCount && null !== (r = t.read());)
                        if (1 === n.pipesCount ? e(n.pipes, 0, null) : x(n.pipes, e), t.emit("data", r), n.awaitDrain > 0) return;
                    return 0 === n.pipesCount ? (n.flowing = !1, void(R.listenerCount(t, "data") > 0 && E(t))) : void(n.ranOut = !0)
                }

                function v() {
                    this._readableState.ranOut && (this._readableState.ranOut = !1, g(this))
                }

                function E(t, e) {
                    var r = t._readableState;
                    if (r.flowing) throw new Error("Cannot switch to old mode now.");
                    var n = e || !1,
                        i = !1;
                    t.readable = !0, t.pipe = w.prototype.pipe, t.on = t.addListener = w.prototype.on, t.on("readable", function() {
                        i = !0;
                        for (var e; !n && null !== (e = t.read());) t.emit("data", e);
                        null === e && (i = !1, t._readableState.needReadable = !0)
                    }), t.pause = function() {
                        n = !0, this.emit("pause")
                    }, t.resume = function() {
                        n = !1, i ? M(function() {
                            t.emit("readable")
                        }) : this.read(0), this.emit("resume")
                    }, t.emit("readable")
                }

                function y(t, e) {
                    var r, n = e.buffer,
                        i = e.length,
                        o = !!e.decoder,
                        a = !!e.objectMode;
                    if (0 === n.length) return null;
                    if (0 === i) r = null;
                    else if (a) r = n.shift();
                    else if (!t || t >= i) r = o ? n.join("") : H.concat(n, i), n.length = 0;
                    else if (t < n[0].length) {
                        var s = n[0];
                        r = s.slice(0, t), n[0] = s.slice(t)
                    } else if (t === n[0].length) r = n.shift();
                    else {
                        r = o ? "" : new H(t);
                        for (var h = 0, u = 0, l = n.length; l > u && t > h; u++) {
                            var s = n[0],
                                c = Math.min(t - h, s.length);
                            o ? r += s.slice(0, c) : s.copy(r, h, 0, c), c < s.length ? n[0] = s.slice(c) : n.shift(), h += c
                        }
                    }
                    return r
                }

                function T(t) {
                    var e = t._readableState;
                    if (e.length > 0) throw new Error("endReadable called on non-empty stream");
                    !e.endEmitted && e.calledRead && (e.ended = !0, M(function() {
                        e.endEmitted || 0 !== e.length || (e.endEmitted = !0, t.readable = !1, t.emit("end"))
                    }))
                }

                function x(t, e) {
                    for (var r = 0, n = t.length; n > r; r++) e(t[r], r)
                }

                function _(t, e) {
                    for (var r = 0, n = t.length; n > r; r++)
                        if (t[r] === e) return r;
                    return -1
                }
                e.exports = i, i.ReadableState = n;
                var b, R = t("events").EventEmitter,
                    w = t("./index.js"),
                    H = t("buffer").Buffer,
                    M = t("process/browser.js").nextTick,
                    S = t("inherits");
                S(i, w), i.prototype.push = function(t, e) {
                    var r = this._readableState;
                    return "string" != typeof t || r.objectMode || (e = e || r.defaultEncoding, e !== r.encoding && (t = new H(t, e), e = "")), o(this, r, t, e, !1)
                }, i.prototype.unshift = function(t) {
                    var e = this._readableState;
                    return o(this, e, t, "", !0)
                }, i.prototype.setEncoding = function(e) {
                    b || (b = t("string_decoder").StringDecoder), this._readableState.decoder = new b(e), this._readableState.encoding = e
                };
                var A = 8388608;
                i.prototype.read = function(t) {
                    var e = this._readableState;
                    e.calledRead = !0;
                    var r = t;
                    if (("number" != typeof t || t > 0) && (e.emittedReadable = !1), 0 === t && e.needReadable && (e.length >= e.highWaterMark || e.ended)) return c(this), null;
                    if (t = h(t, e), 0 === t && e.ended) return 0 === e.length && T(this), null;
                    var n = e.needReadable;
                    e.length - t <= e.highWaterMark && (n = !0), (e.ended || e.reading) && (n = !1), n && (e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1), n && !e.reading && (t = h(r, e));
                    var i;
                    return i = t > 0 ? y(t, e) : null, null === i && (e.needReadable = !0, t = 0), e.length -= t, 0 !== e.length || e.ended || (e.needReadable = !0), e.ended && !e.endEmitted && 0 === e.length && T(this), i
                }, i.prototype._read = function() {
                    this.emit("error", new Error("not implemented"))
                }, i.prototype.pipe = function(t, e) {
                    function n(t) {
                        t === l && o()
                    }

                    function i() {
                        t.end()
                    }

                    function o() {
                        t.removeListener("close", s), t.removeListener("finish", h), t.removeListener("drain", d), t.removeListener("error", a), t.removeListener("unpipe", n), l.removeListener("end", i), l.removeListener("end", o), (!t._writableState || t._writableState.needDrain) && d()
                    }

                    function a(e) {
                        u(), 0 === E && 0 === R.listenerCount(t, "error") && t.emit("error", e)
                    }

                    function s() {
                        t.removeListener("finish", h), u()
                    }

                    function h() {
                        t.removeListener("close", s), u()
                    }

                    function u() {
                        l.unpipe(t)
                    }
                    var l = this,
                        c = this._readableState;
                    switch (c.pipesCount) {
                        case 0:
                            c.pipes = t;
                            break;
                        case 1:
                            c.pipes = [c.pipes, t];
                            break;
                        default:
                            c.pipes.push(t)
                    }
                    c.pipesCount += 1;
                    var p = (!e || e.end !== !1) && t !== r.stdout && t !== r.stderr,
                        f = p ? i : o;
                    c.endEmitted ? M(f) : l.once("end", f), t.on("unpipe", n);
                    var d = m(l);
                    t.on("drain", d);
                    var E = R.listenerCount(t, "error");
                    return t.once("error", a), t.once("close", s), t.once("finish", h), t.emit("pipe", l), c.flowing || (this.on("readable", v), c.flowing = !0, M(function() {
                        g(l)
                    })), t
                }, i.prototype.unpipe = function(t) {
                    var e = this._readableState;
                    if (0 === e.pipesCount) return this;
                    if (1 === e.pipesCount) return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, this.removeListener("readable", v), e.flowing = !1, t && t.emit("unpipe", this), this);
                    if (!t) {
                        var r = e.pipes,
                            n = e.pipesCount;
                        e.pipes = null, e.pipesCount = 0, this.removeListener("readable", v), e.flowing = !1;
                        for (var i = 0; n > i; i++) r[i].emit("unpipe", this);
                        return this
                    }
                    var i = _(e.pipes, t);
                    return -1 === i ? this : (e.pipes.splice(i, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this), this)
                }, i.prototype.on = function(t, e) {
                    var r = w.prototype.on.call(this, t, e);
                    if ("data" !== t || this._readableState.flowing || E(this), "readable" === t && this.readable) {
                        var n = this._readableState;
                        n.readableListening || (n.readableListening = !0, n.emittedReadable = !1, n.needReadable = !0, n.reading ? n.length && c(this, n) : this.read(0))
                    }
                    return r
                }, i.prototype.addListener = i.prototype.on, i.prototype.resume = function() {
                    E(this), this.read(0), this.emit("resume")
                }, i.prototype.pause = function() {
                    E(this, !0), this.emit("pause")
                }, i.prototype.wrap = function(t) {
                    var e = this._readableState,
                        r = !1,
                        n = this;
                    t.on("end", function() {
                        if (e.decoder && !e.ended) {
                            var t = e.decoder.end();
                            t && t.length && n.push(t)
                        }
                        n.push(null)
                    }), t.on("data", function(i) {
                        if (e.decoder && (i = e.decoder.write(i)), i && (e.objectMode || i.length)) {
                            var o = n.push(i);
                            o || (r = !0, t.pause())
                        }
                    });
                    for (var i in t) "function" == typeof t[i] && "undefined" == typeof this[i] && (this[i] = function(e) {
                        return function() {
                            return t[e].apply(t, arguments)
                        }
                    }(i));
                    var o = ["error", "close", "destroy", "pause", "resume"];
                    return x(o, function(e) {
                        t.on(e, function(t) {
                            return n.emit.apply(n, e, t)
                        })
                    }), n._read = function() {
                        r && (r = !1, t.resume())
                    }, n
                }, i._fromList = y
            }).call(this, t("+xKvab"))
        }, {
            "+xKvab": 7,
            "./index.js": 9,
            buffer: 2,
            events: 5,
            inherits: 6,
            "process/browser.js": 10,
            string_decoder: 15
        }],
        13: [function(t, e) {
            function r(t, e) {
                this.afterTransform = function(t, r) {
                    return n(e, t, r)
                }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null
            }

            function n(t, e, r) {
                var n = t._transformState;
                n.transforming = !1;
                var i = n.writecb;
                if (!i) return t.emit("error", new Error("no writecb in Transform class"));
                n.writechunk = null, n.writecb = null, null !== r && void 0 !== r && t.push(r), i && i(e);
                var o = t._readableState;
                o.reading = !1, (o.needReadable || o.length < o.highWaterMark) && t._read(o.highWaterMark)
            }

            function i(t) {
                if (!(this instanceof i)) return new i(t);
                a.call(this, t);
                var e = (this._transformState = new r(t, this), this);
                this._readableState.needReadable = !0, this._readableState.sync = !1, this.once("finish", function() {
                    "function" == typeof this._flush ? this._flush(function(t) {
                        o(e, t)
                    }) : o(e)
                })
            }

            function o(t, e) {
                if (e) return t.emit("error", e);
                var r = t._writableState,
                    n = (t._readableState, t._transformState);
                if (r.length) throw new Error("calling transform done when ws.length != 0");
                if (n.transforming) throw new Error("calling transform done when still transforming");
                return t.push(null)
            }
            e.exports = i;
            var a = t("./duplex.js"),
                s = t("inherits");
            s(i, a), i.prototype.push = function(t, e) {
                return this._transformState.needTransform = !1, a.prototype.push.call(this, t, e)
            }, i.prototype._transform = function() {
                throw new Error("not implemented")
            }, i.prototype._write = function(t, e, r) {
                var n = this._transformState;
                if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
                    var i = this._readableState;
                    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
                }
            }, i.prototype._read = function() {
                var t = this._transformState;
                t.writechunk && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0
            }
        }, {
            "./duplex.js": 8,
            inherits: 6
        }],
        14: [function(t, e) {
            function r(t, e, r) {
                this.chunk = t, this.encoding = e, this.callback = r
            }

            function n(t, e) {
                t = t || {};
                var r = t.highWaterMark;
                this.highWaterMark = r || 0 === r ? r : 16384, this.objectMode = !!t.objectMode, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
                var n = t.decodeStrings === !1;
                this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
                    p(e, t)
                }, this.writecb = null, this.writelen = 0, this.buffer = []
            }

            function i(t) {
                return this instanceof i || this instanceof _.Duplex ? (this._writableState = new n(t, this), this.writable = !0, void _.call(this)) : new i(t)
            }

            function o(t, e, r) {
                var n = new Error("write after end");
                t.emit("error", n), b(function() {
                    r(n)
                })
            }

            function a(t, e, r, n) {
                var i = !0;
                if (!R.isBuffer(r) && "string" != typeof r && null !== r && void 0 !== r && !e.objectMode) {
                    var o = new TypeError("Invalid non-string/buffer chunk");
                    t.emit("error", o), b(function() {
                        n(o)
                    }), i = !1
                }
                return i
            }

            function s(t, e, r) {
                return t.objectMode || t.decodeStrings === !1 || "string" != typeof e || (e = new R(e, r)), e
            }

            function h(t, e, n, i, o) {
                n = s(e, n, i);
                var a = e.objectMode ? 1 : n.length;
                e.length += a;
                var h = e.length < e.highWaterMark;
                return e.needDrain = !h, e.writing ? e.buffer.push(new r(n, i, o)) : u(t, e, a, n, i, o), h
            }

            function u(t, e, r, n, i, o) {
                e.writelen = r, e.writecb = o, e.writing = !0, e.sync = !0, t._write(n, i, e.onwrite), e.sync = !1
            }

            function l(t, e, r, n, i) {
                r ? b(function() {
                    i(n)
                }) : i(n), t.emit("error", n)
            }

            function c(t) {
                t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0
            }

            function p(t, e) {
                var r = t._writableState,
                    n = r.sync,
                    i = r.writecb;
                if (c(r), e) l(t, r, n, e, i);
                else {
                    var o = g(t, r);
                    o || r.bufferProcessing || !r.buffer.length || m(t, r), n ? b(function() {
                        f(t, r, o, i)
                    }) : f(t, r, o, i)
                }
            }

            function f(t, e, r, n) {
                r || d(t, e), n(), r && v(t, e)
            }

            function d(t, e) {
                0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain"))
            }

            function m(t, e) {
                e.bufferProcessing = !0;
                for (var r = 0; r < e.buffer.length; r++) {
                    var n = e.buffer[r],
                        i = n.chunk,
                        o = n.encoding,
                        a = n.callback,
                        s = e.objectMode ? 1 : i.length;
                    if (u(t, e, s, i, o, a), e.writing) {
                        r++;
                        break
                    }
                }
                e.bufferProcessing = !1, r < e.buffer.length ? e.buffer = e.buffer.slice(r) : e.buffer.length = 0
            }

            function g(t, e) {
                return e.ending && 0 === e.length && !e.finished && !e.writing
            }

            function v(t, e) {
                var r = g(t, e);
                return r && (e.finished = !0, t.emit("finish")), r
            }

            function E(t, e, r) {
                e.ending = !0, v(t, e), r && (e.finished ? b(r) : t.once("finish", r)), e.ended = !0
            }
            e.exports = i, i.WritableState = n;
            var y = "undefined" != typeof Uint8Array ? function(t) {
                    return t instanceof Uint8Array
                } : function(t) {
                    return t && t.constructor && "Uint8Array" === t.constructor.name
                },
                T = "undefined" != typeof ArrayBuffer ? function(t) {
                    return t instanceof ArrayBuffer
                } : function(t) {
                    return t && t.constructor && "ArrayBuffer" === t.constructor.name
                },
                x = t("inherits"),
                _ = t("./index.js"),
                b = t("process/browser.js").nextTick,
                R = t("buffer").Buffer;
            x(i, _), i.prototype.pipe = function() {
                this.emit("error", new Error("Cannot pipe. Not readable."))
            }, i.prototype.write = function(t, e, r) {
                var n = this._writableState,
                    i = !1;
                return "function" == typeof e && (r = e, e = null), !R.isBuffer(t) && y(t) && (t = new R(t)), T(t) && "undefined" != typeof Uint8Array && (t = new R(new Uint8Array(t))), R.isBuffer(t) ? e = "buffer" : e || (e = n.defaultEncoding), "function" != typeof r && (r = function() {}), n.ended ? o(this, n, r) : a(this, n, t, r) && (i = h(this, n, t, e, r)), i
            }, i.prototype._write = function(t, e, r) {
                r(new Error("not implemented"))
            }, i.prototype.end = function(t, e, r) {
                var n = this._writableState;
                "function" == typeof t ? (r = t, t = null, e = null) : "function" == typeof e && (r = e, e = null), "undefined" != typeof t && null !== t && this.write(t, e), n.ending || n.finished || E(this, n, r)
            }
        }, {
            "./index.js": 9,
            buffer: 2,
            inherits: 6,
            "process/browser.js": 10
        }],
        15: [function(t, e, r) {
            function n(t) {
                if (t && !s.isEncoding(t)) throw new Error("Unknown encoding: " + t)
            }

            function i(t) {
                return t.toString(this.encoding)
            }

            function o(t) {
                var e = this.charReceived = t.length % 2;
                return this.charLength = e ? 2 : 0, e
            }

            function a(t) {
                var e = this.charReceived = t.length % 3;
                return this.charLength = e ? 3 : 0, e
            }
            var s = t("buffer").Buffer,
                h = r.StringDecoder = function(t) {
                    switch (this.encoding = (t || "utf8").toLowerCase().replace(/[-_]/, ""), n(t), this.encoding) {
                        case "utf8":
                            this.surrogateSize = 3;
                            break;
                        case "ucs2":
                        case "utf16le":
                            this.surrogateSize = 2, this.detectIncompleteChar = o;
                            break;
                        case "base64":
                            this.surrogateSize = 3, this.detectIncompleteChar = a;
                            break;
                        default:
                            return void(this.write = i)
                    }
                    this.charBuffer = new s(6), this.charReceived = 0, this.charLength = 0
                };
            h.prototype.write = function(t) {
                for (var e = "", r = 0; this.charLength;) {
                    var n = t.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : t.length;
                    if (t.copy(this.charBuffer, this.charReceived, r, n), this.charReceived += n - r, r = n, this.charReceived < this.charLength) return "";
                    e = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                    var i = e.charCodeAt(e.length - 1);
                    if (!(i >= 55296 && 56319 >= i)) {
                        if (this.charReceived = this.charLength = 0, n == t.length) return e;
                        t = t.slice(n, t.length);
                        break
                    }
                    this.charLength += this.surrogateSize, e = ""
                }
                var o = this.detectIncompleteChar(t),
                    a = t.length;
                this.charLength && (t.copy(this.charBuffer, 0, t.length - o, a), this.charReceived = o, a -= o), e += t.toString(this.encoding, 0, a);
                var a = e.length - 1,
                    i = e.charCodeAt(a);
                if (i >= 55296 && 56319 >= i) {
                    var s = this.surrogateSize;
                    return this.charLength += s, this.charReceived += s, this.charBuffer.copy(this.charBuffer, s, 0, s), this.charBuffer.write(e.charAt(e.length - 1), this.encoding), e.substring(0, a)
                }
                return e
            }, h.prototype.detectIncompleteChar = function(t) {
                for (var e = t.length >= 3 ? 3 : t.length; e > 0; e--) {
                    var r = t[t.length - e];
                    if (1 == e && r >> 5 == 6) {
                        this.charLength = 2;
                        break
                    }
                    if (2 >= e && r >> 4 == 14) {
                        this.charLength = 3;
                        break
                    }
                    if (3 >= e && r >> 3 == 30) {
                        this.charLength = 4;
                        break
                    }
                }
                return e
            }, h.prototype.end = function(t) {
                var e = "";
                if (t && t.length && (e = this.write(t)), this.charReceived) {
                    var r = this.charReceived,
                        n = this.charBuffer,
                        i = this.encoding;
                    e += n.slice(0, r).toString(i)
                }
                return e
            }
        }, {
            buffer: 2
        }],
        16: [function(t, e) {
            function r(t) {
                return function(e) {
                    return o(e, n(t))
                }
            }

            function n(t) {
                for (var e in t) i(t, e) && (t[e] = Function("return function(node, attr) { return node." + t[e] + " }"), t[e] = t[e]());
                return t
            }

            function i(t, e) {
                return t.hasOwnProperty(e) && "string" == typeof t[e]
            }

            function o(t, e) {
                function r(t) {
                    var e;
                    return "comma" === t.type ? void E.unshift(g = []) : "op" === t.type || "any-child" === t.type ? (g.unshift(m[t.data]), void g.unshift(i())) : (g[0] = g[0] || i(), e = g[0], "!" === t.type ? void(e.subject = E[0].subject = !0) : void e.push("attr" === t.type ? o(t) : ":" === t.type || "::" === t.type ? d(t) : "*" === t.type ? Boolean : h(t.type, t.data)))
                }

                function n(t, e) {
                    function r(t) {
                        for (var e; t.length;) e = t.shift(), -1 === h.indexOf(e) && h.push(e)
                    }
                    var n, i, o, s, h;
                    o = t, h = [];
                    for (var u = 0, l = E.length; l > u; ++u) {
                        g = E[u], n = a, i = g.length, t = o, s = [];
                        for (var c = 0; i > c && (t = n(t, g[c], s), t); c += 2) n = g[c + 1];
                        if (c >= i) {
                            if (e) return !0;
                            r(g.subject ? s : [o])
                        }
                    }
                    return e ? !1 : h.length ? 1 === h.length ? h[0] : h : !1
                }

                function i() {
                    function t(e, r) {
                        for (var n = 0, i = t.bits.length; i > n; ++n)
                            if (!t.bits[n](e)) return !1;
                        return t.subject && r.push(e), !0
                    }
                    return t.bits = [], t.subject = !1, t.push = function(e) {
                        t.bits.push(e)
                    }, t
                }

                function o(t) {
                    return t.data.lhs ? l(e.attr, t.data.lhs, t.data.cmp, t.data.rhs) : l(e.attr, t.data)
                }

                function h(t, r) {
                    return function(n) {
                        return e[t](n) == r
                    }
                }

                function u(t, r, n) {
                    do t = e.parent(t); while (t && !r(t, n));
                    return t
                }

                function c(t, r, n) {
                    return t = e.parent(t), t && r(t, n) ? t : null
                }

                function p(t, r, n) {
                    var i, o = e.parent(t),
                        a = 0;
                    i = e.children(o);
                    for (var s = 0, h = i.length; h > s; ++s)
                        if (i[s] === t) {
                            a = s;
                            break
                        }
                    return i[a - 1] && r(i[a - 1], n) ? i[a - 1] : null
                }

                function f(t, r, n) {
                    var i, o = e.parent(t);
                    i = e.children(o);
                    for (var a = 0, s = i.length; s > a; ++a) {
                        if (i[a] === t) return null;
                        if (r(i[a], n)) return i[a]
                    }
                    return null
                }

                function d(t) {
                    return s(e, t.data)
                }
                var m, g, v = x(),
                    E = [
                        []
                    ];
                return g = E[0], m = {
                    "": u,
                    ">": c,
                    "+": p,
                    "~": f
                }, v.on("data", r).end(t), n
            }

            function a(t, e, r) {
                return e(t, r) ? t : null
            }

            function s(t, e) {
                switch (e) {
                    case "empty":
                        return f(t);
                    case "first-child":
                        return c(t);
                    case "last-child":
                        return p(t);
                    case "root":
                        return d(t)
                }
                return 0 === e.indexOf("contains") ? m(t, e.slice(9, -1)) : 0 === e.indexOf("any") ? u(t, e.slice(4, -1)) : 0 === e.indexOf("not") ? h(t, e.slice(4, -1)) : function() {
                    return !1
                }
            }

            function h(t, e) {
                function r(t) {
                    return !n(t, !0)
                }
                var n = o(e, t);
                return r
            }

            function u(t, e) {
                var r = o(e, t);
                return r
            }

            function l(t, e, r, n) {
                return function(i) {
                    var o = t(i, e);
                    return r ? 1 === r.length ? o == n : void 0 === o || null === o ? !1 : _[r.charAt(0)](o, n) : !!o
                }
            }

            function c(t) {
                return function(e) {
                    return t.children(t.parent(e))[0] === e
                }
            }

            function p(t) {
                return function(e) {
                    var r = t.children(t.parent(e));
                    return r[r.length - 1] === e
                }
            }

            function f(t) {
                return function(e) {
                    return 0 === t.children(e).length
                }
            }

            function d(t) {
                return function(e) {
                    return !t.parent(e)
                }
            }

            function m(t, e) {
                return function(r) {
                    return -1 !== t.contents(r).indexOf(e)
                }
            }

            function g(t, e) {
                return t.slice(t.length - e.length) === e
            }

            function v(t, e) {
                return t.slice(0, e.length) === e
            }

            function E(t, e) {
                return t.indexOf(e) > -1
            }

            function y(t, e) {
                return t.split(/\s+/).indexOf(e) > -1
            }

            function T(t, e) {
                return t.split("-").indexOf(e) > -1
            }
            e.exports = r;
            var x = t("./tokenizer"),
                _ = {
                    $: g,
                    "^": v,
                    "*": E,
                    "~": y,
                    "|": T
                }
        }, {
            "./tokenizer": 18
        }],
        17: [function(t, e, r) {
            (function(n) {
                function i(t, e, r) {
                    function i() {
                        for (; u.length && !c.paused;) {
                            var t = u.shift();
                            if (null === t) return c.emit("end");
                            c.emit("data", t)
                        }
                    }

                    function a() {
                        c.writable = !1, e.call(c), !c.readable && c.autoDestroy && c.destroy()
                    }
                    t = t || function(t) {
                        this.queue(t)
                    }, e = e || function() {
                        this.queue(null)
                    };
                    var s = !1,
                        h = !1,
                        u = [],
                        l = !1,
                        c = new o;
                    return c.readable = c.writable = !0, c.paused = !1, c.autoDestroy = !(r && r.autoDestroy === !1), c.write = function(e) {
                        return t.call(this, e), !c.paused
                    }, c.queue = c.push = function(t) {
                        return l ? c : (null == t && (l = !0), u.push(t), i(), c)
                    }, c.on("end", function() {
                        c.readable = !1, !c.writable && c.autoDestroy && n.nextTick(function() {
                            c.destroy()
                        })
                    }), c.end = function(t) {
                        return s ? void 0 : (s = !0, arguments.length && c.write(t), a(), c)
                    }, c.destroy = function() {
                        return h ? void 0 : (h = !0, s = !0, u.length = 0, c.writable = c.readable = !1, c.emit("close"), c)
                    }, c.pause = function() {
                        return c.paused ? void 0 : (c.paused = !0, c)
                    }, c.resume = function() {
                        return c.paused && (c.paused = !1, c.emit("resume")), i(), c.paused || c.emit("drain"), c
                    }, c
                }
                var o = t("stream");
                r = e.exports = i, i.through = i
            }).call(this, t("+xKvab"))
        }, {
            "+xKvab": 7,
            stream: 9
        }],
        18: [function(t, e) {
            function r() {
                function t(t) {
                    for (I = I.concat(t.split("")), z = I.length; z > G && (B = I[G++]);) switch (j) {
                        case c:
                            r();
                            break;
                        case a:
                            R();
                            break;
                        case p:
                            b();
                            break;
                        case o:
                            M();
                            break;
                        case s:
                            S();
                            break;
                        case h:
                            A();
                            break;
                        case l:
                        case u:
                            w();
                            break;
                        case i:
                            H();
                            break;
                        case y:
                        case v:
                        case f:
                            C()
                    }
                    I = I.slice(G)
                }

                function e(e) {
                    arguments.length && t(e), N.length && L.queue(k())
                }

                function r() {
                    switch (!0) {
                        case "#" === B:
                            j = y;
                            break;
                        case "." === B:
                            j = f;
                            break;
                        case ":" === B:
                            j = l;
                            break;
                        case "[" === B:
                            j = o;
                            break;
                        case "!" === B:
                            T();
                            break;
                        case "*" === B:
                            x();
                            break;
                        case "," === B:
                            _();
                            break;
                        case /[>\+~]/.test(B):
                            j = p;
                            break;
                        case /\s/.test(B):
                            j = a;
                            break;
                        case /[\w\d\-_]/.test(B):
                            j = v, --G
                    }
                }

                function T() {
                    j = g, N = ["!"], L.queue(k()), j = c
                }

                function x() {
                    j = E, N = ["*"], L.queue(k()), j = c
                }

                function _() {
                    j = d, N = [","], L.queue(k()), j = c
                }

                function b() {
                    return /[>\+~]/.test(B) ? N.push(B) : void(/\s/.test(B) || (L.queue(k()), j = c, --G))
                }

                function R() {
                    if (!/\s/.test(B)) {
                        if (/[>\+~]/.test(B)) return --G, j = p;
                        L.queue(k()), j = c, --G
                    }
                }

                function w() {
                    if (U = j, C(!0), j === c) {
                        if ("(" === B) return F = N.join(""), j = i, N.length = 0, D = 1, void++G;
                        j = l, L.queue(k()), j = c
                    }
                }

                function H() {
                    if (0 !== N.length || !(P = /['"]/.test(B) ? B : null)) {
                        if (P) return V || B !== P ? "\\" === B ? void(V ? N.push(B) : V = !0) : (V = !1, void N.push(B)) : void(P = null);
                        N.push(B), "(" === B ? ++D : ")" === B && --D, D || (N.pop(), L.queue({
                            type: U,
                            data: F + "(" + N.join("") + ")"
                        }), j = c, F = U = O = null, N.length = 0)
                    }
                }

                function M() {
                    if (C(!0), j === c) {
                        if ("]" === B) return j = m, L.queue(k()), void(j = c);
                        F = N.join(""), N.length = 0, j = s
                    }
                }

                function S() {
                    return /[=~|$^*]/.test(B) && N.push(B), 2 === N.length || "=" === B ? (O = N.join(""), N.length = 0, j = h, void(P = null)) : void 0
                }

                function A() {
                    if (N.length || !(P = /['"]/.test(B) ? B : null)) {
                        if (P) return V || B !== P ? "\\" === B ? void(V ? N.push(B) : V = !0) : (V = !1, void N.push(B)) : void(P = null);
                        C(!0), j === c && (L.queue({
                            type: m,
                            data: {
                                lhs: F,
                                rhs: N.join(""),
                                cmp: O
                            }
                        }), j = c, F = U = O = null, N.length = 0)
                    }
                }

                function C(t) {
                    return /[^\d\w\-_]/.test(B) && !V ? void("\\" === B ? V = !0 : (!t && L.queue(k()), j = c, --G)) : (V = !1, void N.push(B))
                }

                function k() {
                    var t = N.join("");
                    return N.length = 0, {
                        type: j,
                        data: t
                    }
                }
                var L, z, P, D, F, U, O, B, V = !1,
                    N = [],
                    j = c,
                    I = [],
                    G = 0;
                return L = n(t, e)
            }
            e.exports = r;
            var n = t("through"),
                i = "pseudo-start",
                o = "attr-start",
                a = "any-child",
                s = "attr-comp",
                h = "attr-end",
                u = "::",
                l = ":",
                c = "(ready)",
                p = "op",
                f = "class",
                d = "comma",
                m = "attr",
                g = "!",
                v = "tag",
                E = "*",
                y = "id"
        }, {
            through: 17
        }],
        19: [function(t, e, r) {
            r.setDimension = function(t, e) {
                var r, n, i, o;
                return n = 1 === e ? 1 : 0, i = 2 === e ? 1 : 0, o = 3 === e ? 1 : 0, r = 4 === e ? 1 : 0, t.set(n, i, o, r)
            }, r.setDimensionNormal = function(t, e) {
                var r, n, i, o;
                return n = 1 === e ? 1 : 0, i = 2 === e ? 1 : 0, o = 3 === e ? 1 : 0, r = 4 === e ? 1 : 0, t.set(i, o + n, r, 0)
            }, r.recenterAxis = function() {
                var t;
                return t = [0, 0],
                    function(e, r, n, i) {
                        var o, a, s, h, u, l;
                        return null == i && (i = 0), n > 0 && (u = e, l = e + r, o = Math.max(Math.abs(u), Math.abs(l)), a = o * i, h = Math.min(u, l), s = Math.max(u, l), e = h + (-o + a - h) * n, r = s + (o + a - s) * n - e), t[0] = e, t[1] = r, t
                    }
            }()
        }, {}],
        20: [function(t, e, r) {
            var n;
            r.getSizes = n = function(t) {
                var e, r;
                for (r = [], e = t; null != (null != e ? e.length : void 0);) r.push(e.length), e = e[0];
                return r
            }, r.getDimensions = function(t, e) {
                var r, i, o, a, s, h, u, l, c, p, f, d, m, g, v;
                return null == e && (e = {}), s = e.items, r = e.channels, p = e.width, a = e.height, i = e.depth, o = {}, t && t.length ? (c = n(t), l = c.length, o.channels = 1 !== r && c.length > 1 ? c.pop() : r, o.items = 1 !== s && c.length > 1 ? c.pop() : s, o.width = 1 !== p && c.length > 1 ? c.pop() : p, o.height = 1 !== a && c.length > 1 ? c.pop() : a, o.depth = 1 !== i && c.length > 1 ? c.pop() : i, h = l, 1 === r && h++, 1 === s && h > 1 && h++, 1 === p && h > 2 && h++, 1 === a && h > 3 && h++, u = null != (f = c.pop()) ? f : 1, 1 >= h && (u /= null != (d = o.channels) ? d : 1), 2 >= h && (u /= null != (m = o.items) ? m : 1), 3 >= h && (u /= null != (g = o.width) ? g : 1), 4 >= h && (u /= null != (v = o.height) ? v : 1), u = Math.floor(u), null == o.width && (o.width = u, u = 1), null == o.height && (o.height = u, u = 1), null == o.depth && (o.depth = u, u = 1), o) : {
                    items: s,
                    channels: r,
                    width: null != p ? p : 0,
                    height: null != a ? a : 0,
                    depth: null != i ? i : 0
                }
            }, r.makeEmitter = function(t, e, r, n) {
                var i, o, a;
                return i = function() {
                    switch (r) {
                        case 0:
                            return function() {
                                return !0
                            };
                        case 1:
                            return function(e) {
                                return e(t())
                            };
                        case 2:
                            return function(e) {
                                return e(t(), t())
                            };
                        case 3:
                            return function(e) {
                                return e(t(), t(), t())
                            };
                        case 4:
                            return function(e) {
                                return e(t(), t(), t(), t())
                            }
                    }
                }(), o = function() {
                    switch (e) {
                        case 0:
                            return function() {
                                return !0
                            };
                        case 1:
                            return function(t) {
                                return i(t)
                            };
                        case 2:
                            return function(t) {
                                return i(t), i(t)
                            };
                        case 3:
                            return function(t) {
                                return i(t), i(t), i(t)
                            };
                        case 4:
                            return function(t) {
                                return i(t), i(t), i(t), i(t)
                            }
                    }
                }(), a = function() {
                    switch (n) {
                        case 1:
                            return function(t, e) {
                                return o(e)
                            };
                        case 2:
                            return function(t, e, r) {
                                return o(r)
                            };
                        case 3:
                            return function(t, e, r, n) {
                                return o(n)
                            };
                        case 4:
                            return function(t, e, r, n, i) {
                                return o(i)
                            }
                    }
                }(), a.reset = t.reset, a.rebind = t.rebind, a
            }, r.getThunk = function(t) {
                var e, r, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S;
                switch (g = n(t), d = g.length, e = g.pop(), r = g.pop(), i = g.pop(), o = g.pop(), a = !1, d) {
                    case 0:
                        E = function() {}, E.reset = function() {};
                        break;
                    case 1:
                        u = 0, E = function() {
                            return t[u++]
                        }, E.reset = function() {
                            return u = 0
                        };
                        break;
                    case 2:
                        u = l = 0, s = null != (y = t[l]) ? y : [], E = function() {
                            var r, n, i;
                            return r = s[u++], u === e && (n = [0, l + 1], u = n[0], l = n[1], s = null != (i = t[l]) ? i : []), r
                        }, E.reset = function() {
                            return u = l = 0
                        };
                        break;
                    case 3:
                        u = l = c = 0, m = null != (T = t[c]) ? T : [], s = null != (x = m[l]) ? x : [], E = function() {
                            var n, i, o, a, h;
                            return n = s[u++], u === e && (i = [0, l + 1], u = i[0], l = i[1], l === r && (o = [0, c + 1], l = o[0], c = o[1], m = null != (a = t[c]) ? a : []), s = null != (h = m[l]) ? h : []), n
                        }, E.reset = function() {
                            return u = l = c = 0
                        };
                        break;
                    case 4:
                        u = l = c = p = 0, v = null != (_ = t[p]) ? _ : [], m = null != (b = v[c]) ? b : [], s = null != (R = m[l]) ? R : [], E = function() {
                            var n, o, a, h, f, d, g;
                            return n = s[u++], u === e && (h = [0, l + 1], u = h[0], l = h[1], l === r && (f = [0, c + 1], l = f[0], c = f[1], c === i && (d = [0, p + 1], c = d[0], p = d[1], v = null != (g = t[p]) ? g : []), m = null != (o = v[c]) ? o : []), s = null != (a = m[l]) ? a : []), n
                        }, E.reset = function() {
                            return u = l = c = p = 0
                        };
                        break;
                    case 5:
                        u = l = c = p = f = 0, h = null != (w = t[f]) ? w : [], v = null != (H = h[p]) ? H : [], m = null != (M = v[c]) ? M : [], s = null != (S = m[l]) ? S : [], E = function() {
                            var n, a, d, g, E, y, T, x, _;
                            return n = s[u++], u === e && (a = [0, l + 1], u = a[0], l = a[1], l === r && (d = [0, c + 1], l = d[0], c = d[1], c === i && (g = [0, p + 1], c = g[0], p = g[1], p === o && (E = [0, f + 1], p = E[0], f = E[1], h = null != (y = t[f]) ? y : []), v = null != (T = h[p]) ? T : []), m = null != (x = v[c]) ? x : []), s = null != (_ = m[l]) ? _ : []), n
                        }, E.reset = function() {
                            return u = l = c = p = f = 0
                        }
                }
                return E.rebind = function(o) {
                    return t = o, g = n(t), g.length && (e = g.pop()), g.length && (r = g.pop()), g.length && (i = g.pop()), g.length ? o = g.pop() : void 0
                }, E
            }
        }, {}],
        21: [function(t, e) {
            var r;
            r = {
                cosine: function(t) {
                    return .5 - .5 * Math.cos(t * π)
                }
            }, e.exports = r
        }, {}],
        22: [function(t, e, r) {
            var n, i, o, a = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            i = "xyzw".split(""), n = {
                0: -1,
                x: 0,
                y: 1,
                z: 2,
                w: 3
            }, o = function(t) {
                return t === "" + t && (t = t.split("")), t === +t && (t = [t]), t
            }, r.sample2DArray = function(t) {
                var e, r;
                return r = function(t, e) {
                    var n, i;
                    return t === e ? i = "return texture2D(dataTextures[" + t + "], uv);" : (n = Math.ceil(t + (e - t) / 2), i = "if (z < " + (n - .5) + ") {\n  " + r(t, n - 1) + "\n}\nelse {\n  " + r(n, e) + "\n}"), i = i.replace(/\n/g, "\n  ")
                }, e = r(0, t - 1), "uniform sampler2D dataTextures[" + t + "];\n\nvec4 sample2DArray(vec2 uv, float z) {\n  " + e + "\n}"
            }, r.binaryOperator = function(t, e) {
                return "" + t + " binaryOperator(" + t + " a, " + t + " b) {\n  return a " + e + " b;\n}"
            }, r.extendVec = function(t, e) {
                var r, n, i, o;
                return n = e - t, t = "vec" + t, e = "vec" + e, "vec1" === t && (t = "float"), "vec1" === e && (e = "float"), i = function() {
                    o = [];
                    for (var t = 0; n >= 0 ? n >= t : t >= n; n >= 0 ? t++ : t--) o.push(t);
                    return o
                }.apply(this).map(function(t) {
                    return t ? "0.0" : "v"
                }), r = i.join(","), "" + e + " extendVec(" + t + " v) { return " + e + "(" + r + "); }"
            }, r.truncateVec = function(t, e) {
                var r;
                return r = "." + "xyzw".substr(0, e), t = "vec" + t, e = "vec" + e, "vec1" === e && (e = "float"), "" + e + " truncateVec(" + t + " v) { return v" + r + "; }"
            }, r.injectVec4 = function(t) {
                var e, r, i, a, s, h, u;
                for (s = ["0.0", "0.0", "0.0", "0.0"], t = o(t), t = t.map(function(t) {
                        return t === "" + t ? n[t] : t
                    }), i = h = 0, u = t.length; u > h; i = ++h) r = t[i], s[r] = ["a", "b", "c", "d"][i];
                return a = s.slice(0, 4).join(", "), e = ["float a", "float b", "float c", "float d"].slice(0, t.length), "vec4 inject(" + e + ") {\n  return vec4(" + a + ");\n}"
            }, r.swizzleVec4 = function(t, e) {
                var r, i;
                for (null == e && (e = null), r = ["0.0", "xyzw.x", "xyzw.y", "xyzw.z", "xyzw.w"], null == e && (e = t.length), t = o(t), t = t.map(function(t) {
                        return a.call([0, 1, 2, 3, 4], +t) >= 0 && (t = +t), t === "" + t && (t = n[t] + 1), r[t]
                    }); t.length < e;) t.push("0.0");
                return i = t.join(", "), ("vec" + e + " swizzle(vec4 xyzw) {\n  return vec" + e + "(" + i + ");\n}").replace(/vec1/g, "float")
            }, r.invertSwizzleVec4 = function(t) {
                var e, r, a, s, h, u, l, c;
                for (u = ["0.0", "0.0", "0.0", "0.0"], t = o(t), t = t.map(function(t) {
                        return t === +t ? i[t - 1] : t
                    }), e = l = 0, c = t.length; c > l; e = ++l) a = t[e], h = i[e], r = n[a], u[r] = "xyzw." + h;
                return s = u.join(", "), "vec4 invertSwizzle(vec4 xyzw) {\n  return vec4(" + s + ");\n}"
            }
        }, {}],
        23: [function(t, e, r) {
            r.Data = t("./data"), r.Ticks = t("./ticks"), r.Ease = t("./ease"), r.GLSL = t("./glsl"), r.Axis = t("./axis"), r.JS = t("./js"), r.Three = t("./three")
        }, {
            "./axis": 19,
            "./data": 20,
            "./ease": 21,
            "./glsl": 22,
            "./js": 24,
            "./three": 25,
            "./ticks": 26
        }],
        24: [function(t, e, r) {
            r.merge = function() {
                var t, e, r, n, i, o;
                for (n = {}, i = 0, o = arguments.length; o > i; i++) {
                    e = arguments[i];
                    for (t in e) r = e[t], n[t] = r
                }
                return n
            }, r.clone = function(t) {
                return JSON.parse(JSON.serialize(t))
            }
        }, {}],
        25: [function(t, e, r) {
            r.paramToGL = function(t, e) {
                return e === THREE.RepeatWrapping ? t.REPEAT : e === THREE.ClampToEdgeWrapping ? t.CLAMP_TO_EDGE : e === THREE.MirroredRepeatWrapping ? t.MIRRORED_REPEAT : e === THREE.NearestFilter ? t.NEAREST : e === THREE.NearestMipMapNearestFilter ? t.NEAREST_MIPMAP_NEAREST : e === THREE.NearestMipMapLinearFilter ? t.NEAREST_MIPMAP_LINEAR : e === THREE.LinearFilter ? t.LINEAR : e === THREE.LinearMipMapNearestFilter ? t.LINEAR_MIPMAP_NEAREST : e === THREE.LinearMipMapLinearFilter ? t.LINEAR_MIPMAP_LINEAR : e === THREE.UnsignedByteType ? t.UNSIGNED_BYTE : e === THREE.UnsignedShort4444Type ? t.UNSIGNED_SHORT_4_4_4_4 : e === THREE.UnsignedShort5551Type ? t.UNSIGNED_SHORT_5_5_5_1 : e === THREE.UnsignedShort565Type ? t.UNSIGNED_SHORT_5_6_5 : e === THREE.ByteType ? t.BYTE : e === THREE.ShortType ? t.SHORT : e === THREE.UnsignedShortType ? t.UNSIGNED_SHORT : e === THREE.IntType ? t.INT : e === THREE.UnsignedIntType ? t.UNSIGNED_INT : e === THREE.FloatType ? t.FLOAT : e === THREE.AlphaFormat ? t.ALPHA : e === THREE.RGBFormat ? t.RGB : e === THREE.RGBAFormat ? t.RGBA : e === THREE.LuminanceFormat ? t.LUMINANCE : e === THREE.LuminanceAlphaFormat ? t.LUMINANCE_ALPHA : e === THREE.AddEquation ? t.FUNC_ADD : e === THREE.SubtractEquation ? t.FUNC_SUBTRACT : e === THREE.ReverseSubtractEquation ? t.FUNC_REVERSE_SUBTRACT : e === THREE.ZeroFactor ? t.ZERO : e === THREE.OneFactor ? t.ONE : e === THREE.SrcColorFactor ? t.SRC_COLOR : e === THREE.OneMinusSrcColorFactor ? t.ONE_MINUS_SRC_COLOR : e === THREE.SrcAlphaFactor ? t.SRC_ALPHA : e === THREE.OneMinusSrcAlphaFactor ? t.ONE_MINUS_SRC_ALPHA : e === THREE.DstAlphaFactor ? t.DST_ALPHA : e === THREE.OneMinusDstAlphaFactor ? t.ONE_MINUS_DST_ALPHA : e === THREE.DstColorFactor ? t.DST_COLOR : e === THREE.OneMinusDstColorFactor ? t.ONE_MINUS_DST_COLOR : e === THREE.SrcAlphaSaturateFactor ? t.SRC_ALPHA_SATURATE : 0
            }, r.paramToArrayStorage = function(t) {
                switch (t) {
                    case THREE.UnsignedByteType:
                        return Uint8Array;
                    case THREE.ByteType:
                        return Int8Array;
                    case THREE.ShortType:
                        return Int16Array;
                    case THREE.UnsignedShortType:
                        return Uint16Array;
                    case THREE.IntType:
                        return Int32Array;
                    case THREE.UnsignedIntType:
                        return Uint32Array;
                    case THREE.FloatType:
                        return Float32Array
                }
            }
        }, {}],
        26: [function(t, e, r) {
            var n, i, o, a, s;
            o = function(t, e, r, n, i, o, a) {
                var s, h, u, l, c, p, f, d, m, g, v, E;
                for (r || (r = 10), a || (a = 0), d = e - t, p = d / r, n || (n = 1), i || (i = 10), f = n * (a + Math.pow(i, Math.floor(Math.log(p / n) / Math.log(i)))), l = i % 2 === 0 ? [i / 2, 1, .5] : i % 3 === 0 ? [i / 3, 1, 1 / 3] : [1], g = function() {
                        var t, e, r;
                        for (r = [], t = 0, e = l.length; e > t; t++) u = l[t], r.push(f * u);
                        return r
                    }(), s = 1 / 0, m = g.reduce(function(t, e) {
                        var r, n;
                        return n = e / p, r = Math.max(n, 1 / n), s > r ? (s = r, e) : t
                    }, f), h = +!o, t = (Math.ceil(t / m) + h) * m, e = (Math.floor(e / m) - h) * m, r = Math.ceil((e - t) / m), E = [], c = v = 0; r >= 0 ? r >= v : v >= r; c = r >= 0 ? ++v : --v) E.push(t + c * m);
                return E
            }, a = function() {
                throw "Log ticks not yet implemented."
            }, n = 0, i = 1, s = function(t, e, r, s, h, u, l, c) {
                switch (t) {
                    case n:
                        return o(e, r, s, h, u, l, c);
                    case i:
                        return a(e, r, s, h, u, l, c)
                }
            }, r.make = s, r.linear = o, r.log = a
        }, {}],
        27: [function(t, e) {
            var r, n, i, o, a, s, h;
            n = t("./model"), s = t("./stage"), o = t("./render"), a = t("./shaders"), i = t("./primitives"), h = t("./util"), r = function() {
                function t(t, e, r, h) {
                    null == h && (h = []), this.shaders = new a.Factory(a.Snippets), this.renderables = new o.Factory(t, o.Classes, this.shaders), this.scene = this.renderables.make("scene", {
                        scene: e,
                        camera: r
                    }), this.attributes = new n.Attributes(i.Types), this.primitives = new i.Factory(i.Types, this), this.root = this.primitives.make("root"), this.model = new n.Model(this.root), this.guard = new n.Guard, this.controller = new s.Controller(this.model, this.primitives), this.animator = new s.Animator(this.model), this.director = new s.Director(this.controller, this.animator, h), this.api = new s.API(this), window.model = this.model, window.root = this.model.root
                }
                return t.Namespace = {
                    Model: n,
                    Stage: s,
                    Render: o,
                    Shaders: a,
                    Primitives: i,
                    Util: h
                }, t.prototype.init = function() {
                    return this.scene.inject()
                }, t.prototype.destroy = function() {
                    return this.scene.unject()
                }, t.prototype.resize = function(t) {
                    return this.root.primitive.resize(t)
                }, t.prototype.update = function() {
                    return this.animator.update(), this.guard.iterate(function(t) {
                        return function() {
                            var e;
                            return e = t.attributes.digest(), e || (e = t.model.digest())
                        }
                    }(this)), this.root.primitive.update()
                }, t
            }(), e.exports = r
        }, {
            "./model": 32,
            "./primitives": 36,
            "./render": 104,
            "./shaders": 117,
            "./stage": 122,
            "./util": 127
        }],
        28: [function(t, e, r) {
            var n, i, o, a, s;
            o = function(t) {
                var e, r;
                return null == t && (t = {}), e = THREE.Bootstrap(t), null == e.MathBox && e.install("mathbox"), null != (r = e.mathbox) ? r : e
            }, window.π = Math.PI, window.τ = 2 * π, window.MathBox = r, window.mathBox = r.mathBox = o, r.version = "2", t("../build/shaders"), n = t("./context"), s = n.Namespace;
            for (i in s) a = s[i], r[i] = a;
            THREE.Bootstrap.registerPlugin("mathbox", {
                defaults: {
                    init: !0
                },
                listen: ["ready", "update", "post", "resize"],
                install: function(t) {
                    var e;
                    return e = !1, this.first = !0, t.MathBox = {
                        init: function(r) {
                            return function(i) {
                                var o, a, s;
                                if (!e) return e = !0, a = (null != i ? i.scene : void 0) || r.options.scene || t.scene, o = (null != i ? i.camera : void 0) || r.options.camera || t.camera, s = (null != i ? i.script : void 0) || r.options.script, r.context = new n(t.renderer, a, o, s), r.context.api.three = t, t.mathbox = r.context.api, r.context.init(), r.context.resize(t.Size)
                            }
                        }(this),
                        destroy: function(r) {
                            return function() {
                                return e ? (e = !1, r.context.destroy(), delete t.mathbox, delete r.context.api.three, delete r.context) : void 0
                            }
                        }(this),
                        object: function(t) {
                            return function() {
                                var e;
                                return null != (e = t.context) ? e.scene.root : void 0
                            }
                        }(this)
                    }
                },
                uninstall: function(t) {
                    return t.MathBox.destroy(), delete t.MathBox
                },
                ready: function(t, e) {
                    return this.options.init ? e.MathBox.init() : void 0
                },
                resize: function(t, e) {
                    var r;
                    return null != (r = this.context) ? r.resize(e.Size) : void 0
                },
                update: function() {
                    var t;
                    return null != (t = this.context) ? t.update() : void 0
                },
                render: function() {
                    var t;
                    return null != (t = this.context) ? t.update() : void 0
                },
                post: function(t, e) {
                    var r, n;
                    return this.first ? (r = function(t) {
                        var e;
                        for (e = []; t >= 1e3;) e.unshift(("000" + t % 1e3).slice(-3)), t = Math.floor(t / 1e3);
                        return e.unshift(t), e.join(",")
                    }, this.first = !1, n = e.renderer.info.render, console.log(r(n.faces) + " faces  ", r(n.vertices) + " vertices  ", r(n.calls) + " calls")) : void 0
                }
            })
        }, {
            "../build/shaders": 1,
            "./context": 27
        }],
        29: [function(t, e) {
            var r, n;
            r = function() {
                function t(t) {
                    this.traits = t.Traits, this.types = t.Types, this.pending = []
                }
                return t.prototype.make = function(t) {
                    return {
                        T: t,
                        type: "function" == typeof t.uniform ? t.uniform() : void 0,
                        value: t.make()
                    }
                }, t.prototype.apply = function(t, e) {
                    return null == e && (e = []), new n(t, e, this)
                }, t.prototype.queue = function(t) {
                    return this.pending.push(t)
                }, t.prototype.digest = function() {
                    var t, e, r, n, i;
                    if (!this.pending.length) return !1;
                    for (i = [this.pending, []], e = i[0], this.pending = i[1], r = 0, n = e.length; n > r; r++)(t = e[r])();
                    return !0
                }, t.prototype.getTrait = function(t) {
                    return this.traits[t]
                }, t
            }(), n = function() {
                function t(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L, z, P, D, F;
                    for (null == e && (e = []), E = {}, v = {}, w = function(t) {
                            var e;
                            return null != (e = E[t]) ? e : t
                        }, c = function(t) {
                            var e;
                            return null != (e = v[t]) ? e : t
                        }, o = function(t, e) {
                            if (E[e]) throw "Duplicate property `" + e + "`";
                            return v[t] = e, E[e] = t
                        }, p = function(t) {
                            return function(e) {
                                var r, n, i;
                                return null != (r = null != (n = t[e]) ? n.value : void 0) ? r : null != (i = t[w(e)]) ? i.value : void 0
                            }
                        }(this), _ = function(t) {
                            return function(e, r, i) {
                                var o, a, s;
                                if (e = w(e), null == C[e]) throw "Setting unknown property '" + e + "'";
                                return o = t[e], a = A(e, r, o.last), void 0 === a && (a = o.last), s = [a, o.value], o.value = s[0], o.last = s[1], i || u(e, o.value, o.last) ? void 0 : n(e, r)
                            }
                        }(this), t.get = function(t) {
                            return function(e) {
                                var r, n;
                                if (null != e) return p(e);
                                r = {};
                                for (e in t) n = t[e], r[c(e)] = n.value;
                                return r
                            }
                        }(this), t.set = function(t, e, r) {
                            var n;
                            if (null != t && null != e) _(t, e, r);
                            else {
                                n = t;
                                for (t in n) e = n[t], _(t, e, r)
                            }
                        }, g = {}, C = {}, h = {}, u = function(t, e, r) {
                            return h[t](e, r)
                        }, A = function(t, e, r) {
                            return C[t](e, r)
                        }, t.validate = function(t, e) {
                            var r, n, i;
                            return r = g[t], null != r && (i = r()), n = A(t, e, i), void 0 !== n ? n : i
                        }, s = !1, i = {}, H = {}, f = function(t) {
                            return t.split(".")[0]
                        }, n = function() {
                            return function(t) {
                                var e;
                                return s || (s = !0, r.queue(a)), e = f(t), i[t] = !0, H[e] = !0
                            }
                        }(this), l = {
                            type: "change",
                            changed: null,
                            touched: null
                        }, a = function() {
                            var e, r, n, o, a, h;
                            l.changed = i, l.touched = H, e = {}, n = {}, s = !1, l.type = "change", t.trigger(l), a = l.touched, h = [];
                            for (o in a) r = a[o], l.type = "change:" + o, h.push(t.trigger(l));
                            return h
                        }, b = function(t) {
                            var e, r;
                            return e = t.split(/\./g), r = e.pop(), e.pop(), e.unshift(r), e.reduce(function(t, e) {
                                return t + e.charAt(0).toUpperCase() + e.substring(1)
                            })
                        }, m = [], k = {}, L = 0, z = e.length; z > L; L++)
                        if (M = e[L], P = M.split(":"), M = P[0], T = P[1], y = T ? [T, M].join(".") : M, R = r.getTrait(M), m.push(M), R)
                            for (d in R) x = R[d], d = [y, d].join("."), this[d] = {
                                type: "function" == typeof x.uniform ? x.uniform() : void 0,
                                last: x.make(),
                                value: x.make()
                            }, o(d, b(d)), g[d] = x.make, C[d] = null != (D = x.validate) ? D : function(t) {
                                return t
                            }, h[d] = null != (F = x.equals) ? F : function(t, e) {
                                return t === e
                            };
                    S = m.filter(function(t, e) {
                        return m.indexOf(t) === e
                    }), t.traits = S
                }
                return t
            }(), e.exports = r
        }, {}],
        30: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./node"), r = function(t) {
                function e(t, r, n, i) {
                    e.__super__.constructor.call(this, t, r, n, i), this.children = [], this.on("reindex", function(t) {
                        return function(e) {
                            var r, n, i, o, a;
                            for (o = t.children, a = [], n = 0, i = o.length; i > n; n++) r = o[n], a.push(r.trigger(e));
                            return a
                        }
                    }(this))
                }
                return o(e, t), e.prototype.add = function(t) {
                    var e;
                    return null != (e = t.parent) && e.remove(t), t._index(this.children.length, this), this.children.push(t), t._added(this)
                }, e.prototype.remove = function(t) {
                    var e, r, n, i, o, a;
                    if (r = this.children.indexOf(t), -1 !== r) {
                        for (this.children = this.children.splice(r, 1), t._index(null), t._removed(this), o = this.children, a = [], e = n = 0, i = o.length; i > n; e = ++n) t = o[e], e >= r && a.push(t._index(e));
                        return a
                    }
                }, e.prototype.empty = function() {
                    var t, e, r, n, i;
                    for (t = this.children.slice(), i = [], r = 0, n = t.length; n > r; r++) e = t[r], i.push(this.remove(e));
                    return i
                }, e
            }(n), e.exports = r
        }, {
            "./node": 34
        }],
        31: [function(t, e) {
            var r;
            r = function() {
                function t(t) {
                    this.limit = null != t ? t : 10
                }
                return t.prototype.iterate = function(t) {
                    var e, r;
                    for (e = this.limit; r = t();)
                        if (!--e) throw "Exceeded iteration limit in digest.";
                    return null
                }, t
            }(), e.exports = r
        }, {}],
        32: [function(t, e, r) {
            r.Attributes = t("./attributes"), r.Group = t("./group"), r.Guard = t("./guard"), r.Model = t("./model"), r.Node = t("./node")
        }, {
            "./attributes": 29,
            "./group": 30,
            "./guard": 31,
            "./model": 33,
            "./node": 34
        }],
        33: [function(t, e) {
            var r, n, i, o, a, s, h, u, l = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            h = t("cssauron"), r = "*", i = /^#([A-Za-z0-9_])$/, n = /^\.([A-Za-z0-9_]+)$/, a = /^\[([A-Za-z0-9_]+)\]$/, s = /^[A-Za-z0-9_]+$/, u = null, o = function() {
                function t(t) {
                    var e, r, n, i, o, a, s, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R;
                    this.root = t, this.root.model = this, this.root.root = this.root, this.ids = {}, this.classes = {}, this.traits = {}, this.types = {}, this.nodes = [], this.watchers = [], this.fire = !1, this.event = {
                        type: "update"
                    }, null == u && (u = h({
                        tag: "type",
                        id: "id",
                        "class": "classes.join(' ')",
                        parent: "parent",
                        children: "children",
                        attr: "traits.hash[attr]"
                    })), e = function() {
                        return function(t) {
                            return l(t.node)
                        }
                    }(this), g = function() {
                        return function(t) {
                            return p(t.node)
                        }
                    }(this), this.root.on("add", e), this.root.on("remove", g), l = function() {
                        return function(t) {
                            return i(t), s(t), a(t), t.on("change:node", R), R(null, t, !0), f(t)
                        }
                    }(this), p = function() {
                        return function(t) {
                            return y(t), _(t), x(t), E(t.id), v(t.classes), t.off("change:node", R), f(t)
                        }
                    }(this), m = function(t) {
                        return function(e) {
                            var r, n, i, o;
                            for (o = t.watchers, n = 0, i = o.length; i > n; n++) r = o[n], r.match = r.matcher(e);
                            return null
                        }
                    }(this), c = function(t) {
                        return function(e) {
                            var r, n, i, o;
                            for (o = t.watchers, n = 0, i = o.length; i > n; n++) r = o[n], t.fire || (t.fire = r.fire || (r.fire = r.match !== r.matcher(e)));
                            return null
                        }
                    }(this), f = function(t) {
                        return function(e) {
                            var r, n, i, o;
                            for (o = t.watchers, n = 0, i = o.length; i > n; n++) r = o[n], t.fire || (t.fire = r.fire || (r.fire = r.matcher(e)));
                            return null
                        }
                    }(this), this.digest = function(t) {
                        return function() {
                            var e, r, n, i;
                            if (!t.fire) return !1;
                            for (i = t.watchers.slice(), r = 0, n = i.length; n > r; r++) e = i[r], e.fire && (e.fire = !1, e.handler());
                            return t.fire = !1, !0
                        }
                    }(this), R = function() {
                        return function(t, e, i) {
                            var o, a, s, h, u, l, p, f;
                            return u = i || t.changed["node.id"], l = i || t.changed["node.classes"], h = !1, u && (a = e.get("node.id"), a !== e.id && (i || m(e), h = !0, null != e.id && E(e.id, e), n(a, e))), l && (o = null != (p = e.get("node.classes")) ? p : [], s = o.join(","), s !== (null != (f = e.classes) ? f.klass : void 0) && (o = o.slice(), i || h || m(e), h = !0, null != e.classes && v(e.classes, e), r(o, e), e.classes = o, e.classes.klass = s)), !i && h && c(e), null
                        }
                    }(this), o = function(t, e, r) {
                        var n, i, o, a, s;
                        if (null != e) {
                            for (o = 0, a = e.length; a > o; o++) n = e[o], i = null != (s = t[n]) ? s : [], i.push(r), t[n] = i;
                            return null
                        }
                    }, T = function(t, e, r) {
                        var n, i, o, a, s;
                        if (null != e) {
                            for (a = 0, s = e.length; s > a; a++) i = e[a], o = t[i], n = o.indexOf(r), n >= 0 && o.splice(n, 1), 0 === o.length && delete t[i];
                            return null
                        }
                    }, d = function(t) {
                        var e, r, n, i, o;
                        if (t.length > 0) {
                            for (e = t.hash = {}, o = [], n = 0, i = t.length; i > n; n++) r = t[n], o.push(e[r] = !0);
                            return o
                        }
                    }, b = function(t) {
                        return delete t.hash
                    }, n = function(t) {
                        return function(e, r) {
                            if (t.ids[e]) throw "Duplicate id `" + e + "`";
                            return null != e && (t.ids[e] = [r]), r.id = e
                        }
                    }(this), E = function(t) {
                        return function(e, r) {
                            return null != e && delete t.ids[e], delete r.id
                        }
                    }(this), r = function(t) {
                        return function(e, r) {
                            return o(t.classes, e, r), null != e ? d(e) : void 0
                        }
                    }(this), v = function(t) {
                        return function(e, r) {
                            return T(t.classes, e, r), null != e ? b(e) : void 0
                        }
                    }(this), i = function(t) {
                        return function(e) {
                            return t.nodes.push(e)
                        }
                    }(this), y = function(t) {
                        return function(e) {
                            return t.nodes.splice(t.nodes.indexOf(e), 1)
                        }
                    }(this), s = function(t) {
                        return function(e) {
                            return o(t.types, [e.type], e)
                        }
                    }(this), _ = function(t) {
                        return function(e) {
                            return T(t.types, [e.type], e)
                        }
                    }(this), a = function(t) {
                        return function(e) {
                            return o(t.traits, e.traits, e), d(e.traits)
                        }
                    }(this), x = function(t) {
                        return function(e) {
                            return T(t.traits, e.traits, e), b(e.traits)
                        }
                    }(this), l(this.root)
                }
                return t.prototype.filter = function(t, e) {
                    var r, n, i, o, a;
                    for (r = this._matcher(e), a = [], i = 0, o = t.length; o > i; i++) n = t[i], r(n) && a.push(n);
                    return a
                }, t.prototype.ancestry = function(t, e) {
                    var r, n, i, o, a;
                    for (n = [], o = 0, a = t.length; a > o; o++)
                        for (r = t[o], i = r.parent; null != i;) l.call(e, i) >= 0 ? n.push(r) : i = r.parent;
                    return n
                }, t.prototype.select = function(t, e) {
                    var r;
                    return r = this._select(t), null != e && (r = this.ancestry(unique, e)), r.sort(function(t, e) {
                        return e.order - t.order
                    }), r
                }, t.prototype.watch = function(t, e) {
                    var r;
                    return e.unwatch = function(t) {
                        return function() {
                            return t.unwatch(e)
                        }
                    }(this), e.watcher = r = {
                        handler: e,
                        matcher: this._matcher(t),
                        match: !1,
                        fire: !1
                    }, this.watchers.push(r), this.select(t)
                }, t.prototype.unwatch = function(t) {
                    var e;
                    return e = t.watcher, null != e ? (this.watchers.splice(this.watchers.indexOf(e), 1), delete t.unwatch, delete t.watcher) : void 0
                }, t.prototype._simplify = function(t) {
                    var e, o, h, u, l, c, p, f, d, m;
                    return t = t.replace(/^\s+/, ""), t = t.replace(/\s+$/, ""), o = e = t === r, o || (o = h = null != (p = t.match(i)) ? p[1] : void 0), o || (o = u = null != (f = t.match(n)) ? f[1] : void 0), o || (o = l = null != (d = t.match(a)) ? d[1] : void 0), o || (o = c = null != (m = t.match(s)) ? m[0] : void 0), [e, h, u, l, c]
                }, t.prototype._matcher = function(t) {
                    var e, r, n, i, o, a;
                    return a = this._simplify(t), e = a[0], r = a[1], n = a[2], i = a[3], o = a[4], e ? function() {
                        return !0
                    } : r ? function(t) {
                        return t.id === r
                    } : n ? function(t) {
                        var e;
                        return null != (e = t.classes) ? e.hash[n] : void 0
                    } : i ? function(t) {
                        var e;
                        return null != (e = t.traits) ? e.hash[i] : void 0
                    } : o ? function(t) {
                        return t.type === o
                    } : u(t)
                }, t.prototype._select = function(t) {
                    var e, r, n, i, o, a, s, h, u, l;
                    return a = this._simplify(t), e = a[0], r = a[1], n = a[2], i = a[3], o = a[4], e ? this.nodes : r ? null != (s = this.ids[r]) ? s : [] : n ? null != (h = this.classes[n]) ? h : [] : i ? null != (u = this.traits[i]) ? u : [] : o ? null != (l = this.types[o]) ? l : [] : this.filter(this.nodes, t)
                }, t.prototype.getRoot = function() {
                    return this.root
                }, t
            }(), e.exports = o
        }, {
            cssauron: 16
        }],
        34: [function(t, e) {
            var r;
            r = function() {
                function t(t, e, r, n) {
                    this.type = e, null == r && (r = []), this.attributes = n.apply(this, r), this.parent = this.root = this.path = this.index = null, this.set(t, null, !0)
                }
                return t.prototype.toString = function() {
                    var t, e;
                    return t = this.type, this.id && (t += "#" + this.id), (null != (e = this.classes) ? e.length : void 0) && (t += "." + this.classes.join(".")), t
                }, t.prototype._added = function(t) {
                    var e;
                    return this.parent = t, this.root = t.root, e = {
                        type: "add",
                        node: this,
                        parent: this.parent
                    }, this.root && this.root.trigger(e), e.type = "added", this.trigger(e)
                }, t.prototype._removed = function() {
                    var t;
                    return this.root = this.parent = null, t = {
                        type: "remove",
                        node: this
                    }, this.root && this.root.trigger(t), t.type = "removed", this.trigger(t)
                }, t.prototype._index = function(t, e) {
                    var r, n;
                    return null == e && (e = this.parent), this.index = t, this.path = r = null != t ? (null != (n = null != e ? e.path : void 0) ? n : []).concat([t]) : null, this.order = null != r ? this._encode(r) : 1 / 0, null != this.root ? this.trigger({
                        type: "reindex"
                    }) : void 0
                }, t.prototype._encode = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c;
                    for (a = 3, h = function(t) {
                            return a / (t + a)
                        }, s = function(t) {
                            return r + (e - r) * t
                        }, e = 1 + 1 / a, r = 0, u = 0, l = t.length; l > u; u++) o = t[u], n = h(o + 1), i = h(o + 2), c = [s(n), s(i)], e = c[0], r = c[1];
                    return e
                }, t
            }(), THREE.Binder.apply(r.prototype), e.exports = r
        }, {}],
        35: [function(t, e) {
            var r;
            r = function() {
                function t(t, e) {
                    this.context = e, this.classes = t.Classes, this.helpers = t.Helpers
                }
                return t.prototype.getTypes = function() {
                    return Object.keys(this.classes)
                }, t.prototype.make = function(t, e) {
                    var r, n, i, o;
                    if (null == e && (e = {}), n = this.classes[t], !n) throw "Unknown primitive class `" + t + "`";
                    return o = n.model, i = new o(e, t, n.traits, this.context.attributes), r = new n(i, this.context, this.helpers), i
                }, t
            }(), e.exports = r
        }, {}],
        36: [function(t, e, r) {
            r.Factory = t("./factory"), r.Primitive = t("./primitive"), r.Types = t("./types")
        }, {
            "./factory": 35,
            "./primitive": 37,
            "./types": 61
        }],
        37: [function(t, e) {
            var r, n, i = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            r = t("../model"), n = function() {
                function t(t, e, r) {
                    this.node = t, this._context = e, this._attributes = this._context.attributes, this._renderables = this._context.renderables, this._shaders = this._context.shaders, this._types = this._attributes.types, this.node.primitive = this, this.traits = this.node.traits, this.node.on("added", function(t) {
                        return function() {
                            return t._added()
                        }
                    }(this)), this.node.on("removed", function(t) {
                        return function() {
                            return t._removed()
                        }
                    }(this)), this.node.on("change", function(t) {
                        return function(e) {
                            return t.root ? t.change(e.changed, e.touched) : void 0
                        }
                    }(this)), this._get = this.node.get.bind(this.node), this._helpers = r(this, this.node.traits), this.handlers = {}, this.root = this.parent = null
                }
                return t.Node = r.Node, t.Group = r.Group, t.model = t.Node, t.traits = [], t.prototype.is = function(t) {
                    return this.traits.indexOf(t) >= 0
                }, t.prototype.make = function() {}, t.prototype.unmake = function() {}, t.prototype.change = function() {}, t.prototype.rebuild = function() {
                    return this.root ? (this.unmake(!0), this.make(), this.refresh()) : void 0
                }, t.prototype.refresh = function() {
                    return this.change({}, {}, !0)
                }, t.prototype.transform = function(t) {
                    var e;
                    return null != (e = this.parent) ? e.transform(t) : void 0
                }, t.prototype.present = function(t) {
                    var e;
                    return null != (e = this.parent) ? e.present(t) : void 0
                }, t.prototype._add = function() {}, t.prototype._remove = function() {}, t.prototype._added = function() {
                    return this.parent = this.node.parent.primitive, this.root = this.node.root.primitive, this.make(), this.refresh()
                }, t.prototype._removed = function() {
                    return this.unmake(), this.root = null, this.parent = null
                }, t.prototype._change = function() {}, t.prototype._inherit = function(t, e) {
                    return null == e && (e = !1), e && i.call(this.node.traits, t) >= 0 ? this : null != this.parent ? this.parent._inherit(t, !0) : null
                }, t.prototype._attach = function(t, e, r) {
                    var n, o, a, s, h;
                    if ("object" == typeof t && (o = t, null != o && i.call(o.traits, e) >= 0)) return o.primitive;
                    if ("<" === t) {
                        for (s = this.node; s && (a = s.parent);)
                            if (s = a.children[s.index - 1], s || (s = a), null != s && i.call(s.traits, e) >= 0) return s.primitive
                    } else if ("string" == typeof t && (h = this.root.watch(t, r), o = h[0], null != o && i.call(o.traits, e) >= 0)) return o.primitive;
                    throw null != this.node.id && (n = "#" + this.node.id), "Could not find " + e + " `" + object + "` on `" + this.node.type + n + "` " + key
                }, t
            }(), THREE.Binder.apply(n.prototype), e.exports = n
        }, {
            "../model": 32
        }],
        38: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./parent"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "object", "position"], e.prototype.make = function() {
                    return this._helpers.object.make(), this._helpers.position.make()
                }, e.prototype.unmake = function() {
                    return this._helpers.object.unmake(), this._helpers.position.unmake()
                }, e.prototype.transform = function(t) {
                    return this._helpers.position.shader(t), e.__super__.transform.apply(this, arguments)
                }, e
            }(n), e.exports = r
        }, {
            "./parent": 39
        }],
        39: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n)
                }
                return o(e, t), e.model = n.Group, e.traits = ["node"], e
            }(n), e.exports = r
        }, {
            "../../primitive": 37
        }],
        40: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./parent"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "object", "position"], e.prototype.make = function() {
                    return this._helpers.object.make(), this._helpers.position.make()
                }, e.prototype.unmake = function() {
                    return this._helpers.object.unmake(), this._helpers.position.unmake()
                }, e.prototype.present = function(t) {
                    return this._helpers.position.shader(t), e.__super__.present.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "./parent": 39
        }],
        41: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./parent"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.size = null, this.event = {
                        type: "root.update"
                    }
                }
                return o(e, t), e.traits = ["node", "root", "scene"], e.prototype.adopt = function(t) {
                    var e, r, n, i, o;
                    for (i = t.objects, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this._context.scene.add(e));
                    return o
                }, e.prototype.unadopt = function(t) {
                    var e, r, n, i, o;
                    for (i = t.objects, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this._context.scene.remove(e));
                    return o
                }, e.prototype.select = function(t) {
                    return this.node.model.select(t)
                }, e.prototype.watch = function(t, e) {
                    return this.node.model.watch(t, e)
                }, e.prototype.unwatch = function(t) {
                    return this.node.model.unwatch(t)
                }, e.prototype.resize = function(t) {
                    return this.size = t, this.trigger({
                        type: "root.resize",
                        size: t
                    })
                }, e.prototype.getSize = function() {
                    return this.size
                }, e.prototype.update = function() {
                    return this.trigger(this.event)
                }, e.prototype.present = function(t) {
                    return t.pipe("view.position")
                }, e
            }(r), e.exports = n
        }, {
            "./parent": 39
        }],
        42: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../../primitive"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n)
                }
                return o(e, t), e.traits = ["node", "data", "source"], e.prototype.callback = function(t) {
                    return null != t ? t : function() {}
                }, e.prototype.sourceShader = function() {}, e.prototype.getDimensions = function() {
                    return {
                        items: 1,
                        width: 0,
                        height: 0,
                        depth: 0
                    }
                }, e.prototype.getActive = function() {
                    return {
                        items: 1,
                        width: 0,
                        height: 0,
                        depth: 0
                    }
                }, e
            }(r), e.exports = n
        }, {
            "../../primitive": 37
        }],
        43: [function(t, e) {
            var r;
            r = {
                axis: t("./draw/axis"),
                face: t("./draw/face"),
                grid: t("./draw/grid"),
                line: t("./draw/line"),
                point: t("./draw/point"),
                strip: t("./draw/strip"),
                surface: t("./draw/surface"),
                ticks: t("./draw/ticks"),
                vector: t("./draw/vector"),
                cartesian: t("./view/cartesian"),
                cartesian4: t("./view/cartesian4"),
                polar: t("./view/polar"),
                spherical: t("./view/spherical"),
                stereographic: t("./view/stereographic"),
                stereographic4: t("./view/stereographic4"),
                project4: t("./transform/project4"),
                array: t("./data/array"),
                interval: t("./data/interval"),
                matrix: t("./data/matrix"),
                area: t("./data/area"),
                voxel: t("./data/voxel"),
                volume: t("./data/volume"),
                join: t("./operator/join"),
                lerp: t("./operator/lerp"),
                memo: t("./operator/memo"),
                remap: t("./operator/remap"),
                repeat: t("./operator/repeat"),
                swizzle: t("./operator/swizzle"),
                spread: t("./operator/spread"),
                split: t("./operator/split"),
                transpose: t("./operator/transpose"),
                present: t("./base/present"),
                group: t("./base/group"),
                root: t("./base/root"),
                rtt: t("./rtt/rtt"),
                compose: t("./rtt/compose")
            }, e.exports = r
        }, {
            "./base/group": 38,
            "./base/present": 40,
            "./base/root": 41,
            "./data/area": 44,
            "./data/array": 45,
            "./data/interval": 47,
            "./data/matrix": 48,
            "./data/volume": 49,
            "./data/voxel": 50,
            "./draw/axis": 51,
            "./draw/face": 52,
            "./draw/grid": 53,
            "./draw/line": 54,
            "./draw/point": 55,
            "./draw/strip": 56,
            "./draw/surface": 57,
            "./draw/ticks": 58,
            "./draw/vector": 59,
            "./operator/join": 62,
            "./operator/lerp": 63,
            "./operator/memo": 64,
            "./operator/remap": 66,
            "./operator/repeat": 67,
            "./operator/split": 68,
            "./operator/spread": 69,
            "./operator/swizzle": 70,
            "./operator/transpose": 71,
            "./rtt/compose": 72,
            "./rtt/rtt": 73,
            "./transform/project4": 75,
            "./view/cartesian": 78,
            "./view/cartesian4": 79,
            "./view/polar": 80,
            "./view/spherical": 81,
            "./view/stereographic": 82,
            "./view/stereographic4": 83
        }],
        44: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./matrix"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "data", "source", "matrix", "texture", "span:x", "span:y", "area", "sampler:x", "sampler:y"], e.prototype.callback = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m;
                    return s = this._get("area.axes"), m = this._get("matrix.width"), h = this._get("matrix.height"), o = this._get("x.sampler.centered"), a = this._get("y.sampler.centered"), c = this._helpers.span.get("x.", s[0]), p = this._helpers.span.get("y.", s[1]), e = c.x, r = p.x, f = c.y - c.x, d = p.y - p.x, o ? (u = 1 / Math.max(1, m), e += f * u / 2) : u = 1 / Math.max(1, m - 1), a ? (l = 1 / Math.max(1, h), r += d * l / 2) : l = 1 / Math.max(1, h - 1), n = f * u, i = d * l,
                        function(o, a, s) {
                            var h, u;
                            return h = e + n * o, u = r + i * a, t(h, u, o, a, s)
                        }
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this._helpers.span.unmake()
                }, e
            }(n), e.exports = r
        }, {
            "./matrix": 48
        }],
        45: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./data"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.buffer = this.spec = this.emitter = null, this.filled = !1, this.space = {
                        length: 0,
                        history: 0
                    }, this.used = {
                        length: 0
                    }
                }
                return a(e, t), e.traits = ["node", "data", "source", "array", "texture"], e.prototype.sourceShader = function(t) {
                    return this.buffer.shader(t)
                }, e.prototype.getDimensions = function() {
                    var t;
                    return t = this.space, {
                        items: this.items,
                        width: t.length,
                        height: t.history,
                        depth: 1
                    }
                }, e.prototype.getActive = function() {
                    var t;
                    return t = this.used, {
                        items: this.items,
                        width: t.length,
                        height: this.buffer.getFilled(),
                        depth: 1
                    }
                }, e.prototype.make = function() {
                    var t, r, n, o, a, s, h, u, l, c, p;
                    return e.__super__.make.apply(this, arguments), u = this._get("texture.minFilter"), h = this._get("texture.magFilter"), p = this._get("texture.type"), s = this._get("array.length"), o = this._get("array.history"), t = this._get("data.dimensions"), a = this._get("data.items"), n = this.spec = {
                        channels: t,
                        items: a,
                        width: s
                    }, this.items = n.items, this.channels = n.channels, r = this._get("data.data"), n = i.Data.getDimensions(r, n), l = this.space, l.length = Math.max(l.length, n.width || 1), l.history = o, this.buffer = this._renderables.make("arrayBuffer", {
                        length: l.length,
                        history: l.history,
                        channels: t,
                        items: a,
                        minFilter: u,
                        magFilter: h,
                        type: p
                    }), null != r && (c = i.Data.getThunk(r), this.emitter = i.Data.makeEmitter(c, a, t, 1)), this.trigger({
                        type: "source.rebuild"
                    })
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.buffer ? (this.buffer.dispose(), this.buffer = this.spec = this.emitter = null) : void 0
                }, e.prototype.change = function(t, e, r) {
                    var n, i;
                    if (e.array || e.texture || t["data.dimensions"]) return this.rebuild();
                    if (this.buffer) return t["data.expression"] || t["data.data"] || r ? (i = this.emitter, n = this._get("data.data"), null == n && (i = this.callback(this._get("data.expression"))), this.buffer.callback = i) : void 0
                }, e.prototype.update = function() {
                    var t, e, r, n, o, a, s, h;
                    if (this.buffer && (!this.filled || this._get("data.live"))) return t = this._get("data.data"), a = this.space, h = this.used, r = this.buffer.getFilled(), n = h.length, null != t ? (e = i.Data.getDimensions(t, this.spec), e.width > a.length && (o = a.length, s = Math.min(128, o), a.length = Math.max(o + s, e.width), this.rebuild()), h.length = e.width, this.buffer.callback.rebind(t), this.buffer.update()) : (o = this.buffer.update(), h.length = o), (h.length !== n || r !== this.buffer.getFilled()) && this.trigger({
                        type: "source.resize"
                    }), this.filled = !0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "./data": 46
        }],
        46: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../base/source"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "data", "source", "texture"], e.prototype.update = function() {}, e.prototype.make = function() {
                    return this.dataRoot = this._inherit("root"), this.handler = function(t) {
                        return function() {
                            return t.update()
                        }
                    }(this), this.dataRoot.on("root.update", this.handler)
                }, e.prototype.unmake = function() {
                    return this.dataRoot.off("root.update", this.handler)
                }, e
            }(n), e.exports = r
        }, {
            "../base/source": 42
        }],
        47: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./array"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "data", "source", "texture", "array", "span", "interval", "sampler"], e.prototype.callback = function(t) {
                    var e, r, n, i, o, a, s, h;
                    return i = this._get("interval.axis"), a = this._get("array.length"), n = this._get("sampler.centered"), s = this._helpers.span.get("", i), e = s.x, h = s.y - s.x, n ? (o = 1 / Math.max(1, a), e += h * o / 2) : o = 1 / Math.max(1, a - 1), r = h * o,
                        function(n, i) {
                            var o;
                            return o = e + r * n, t(o, n, i)
                        }
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this._helpers.span.unmake()
                }, e
            }(n), e.exports = r
        }, {
            "./array": 45
        }],
        48: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./data"), i = t("../../../util"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.buffer = this.spec = this.emitter = null, this.filled = !1, this.space = {
                        width: 0,
                        height: 0,
                        history: 0
                    }, this.used = {
                        width: 0,
                        height: 0
                    }
                }
                return a(e, t), e.traits = ["node", "data", "source", "texture", "matrix"], e.prototype.sourceShader = function(t) {
                    return this.buffer.shader(t)
                }, e.prototype.getDimensions = function() {
                    var t;
                    return t = this.space, {
                        items: this.items,
                        width: t.width,
                        height: t.height,
                        depth: t.history
                    }
                }, e.prototype.getActive = function() {
                    var t;
                    return t = this.used, {
                        items: this.items,
                        width: t.width,
                        height: t.height,
                        depth: this.buffer.getFilled()
                    }
                }, e.prototype.make = function() {
                    var t, r, n, o, a, s, h, u, l, c, p, f;
                    return e.__super__.make.apply(this, arguments), u = this._get("texture.minFilter"), h = this._get("texture.magFilter"), p = this._get("texture.type"), f = this._get("matrix.width"), o = this._get("matrix.height"), a = this._get("matrix.history"), t = this._get("data.dimensions"), s = this._get("data.items"), n = this.spec = {
                        channels: t,
                        items: s,
                        width: f,
                        height: o,
                        depth: a
                    }, this.items = n.items, this.channels = n.channels, r = this._get("data.data"), n = i.Data.getDimensions(r, n), l = this.space, l.width = Math.max(l.width, n.width || 1), l.height = Math.max(l.height, n.height || 1), l.history = a, this.buffer = this._renderables.make("matrixBuffer", {
                        width: l.width,
                        height: l.height,
                        history: l.history,
                        channels: t,
                        items: s,
                        minFilter: u,
                        magFilter: h,
                        type: p
                    }), null != r && (c = i.Data.getThunk(r), this.emitter = i.Data.makeEmitter(c, s, t, 2)), this.trigger({
                        type: "source.rebuild"
                    })
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.buffer ? (this.buffer.dispose(), this.buffer = this.spec = this.emitter = null) : void 0
                }, e.prototype.change = function(t, e, r) {
                    var n, i;
                    if (e.matrix || e.texture || t["data.dimensions"]) return this.rebuild();
                    if (this.buffer) return t["data.expression"] || t["data.data"] || r ? (i = this.emitter, n = this._get("data.data"), null == n && (i = this.callback(this._get("data.expression"))), this.buffer.callback = i) : void 0
                }, e.prototype.update = function() {
                    var t, e, r, n, o, a, s, h, u, l, c;
                    if (this.buffer && (!this.filled || this._get("data.live"))) return t = this._get("data.data"), s = this.space, u = this.used, r = this.buffer.getFilled(), l = u.width, n = u.height, null != t ? (e = i.Data.getDimensions(t, this.spec), a = !1, e.width > s.width && (a = !0, o = s.width, h = Math.min(128, o), s.width = Math.max(o + h, e.width)), e.height > s.height && (a = !0, o = s.height, h = Math.min(128, o), s.height = Math.max(o + h, e.height)), a && this.rebuild(), u.width = e.width, u.height = e.height, this.buffer.callback.rebind(t), this.buffer.update()) : (o = this.buffer.update(), u.width = c = s.width, u.height = Math.ceil(o / c)), (u.width !== l || u.height !== n || r !== this.buffer.getFilled()) && this.trigger({
                        type: "source.resize"
                    }), this.filled = !0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "./data": 46
        }],
        49: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./voxel"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "data", "source", "texture", "voxel", "span:x", "span:y", "span:z", "volume", "sampler:x", "sampler:y", "sampler:z"], e.prototype.callback = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _;
                    return c = this._get("volume.axes"), _ = this._get("voxel.width"), p = this._get("voxel.height"), l = this._get("voxel.depth"), s = this._get("x.sampler.centered"), h = this._get("y.sampler.centered"), u = this._get("z.sampler.centered"), g = this._helpers.span.get("x.", c[0]), v = this._helpers.span.get("y.", c[1]), E = this._helpers.span.get("z.", c[2]), e = g.x, r = v.x, n = E.x, y = g.y - g.x, T = v.y - v.x, x = E.y - E.x, s ? (f = 1 / Math.max(1, _), e += y * f / 2) : f = 1 / Math.max(1, _ - 1), h ? (d = 1 / Math.max(1, p), r += T * d / 2) : d = 1 / Math.max(1, p - 1), u ? (m = 1 / Math.max(1, l), n += x * m / 2) : m = 1 / Math.max(1, l - 1), i = y * f, o = T * d, a = x * m,
                        function(s, h, u, l) {
                            var c, p, f;
                            return c = e + i * s, p = r + o * h, f = n + a * u, t(c, p, f, s, h, u, l)
                        }
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this._helpers.span.unmake()
                }, e
            }(n), e.exports = r
        }, {
            "./voxel": 50
        }],
        50: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./data"), n = t("../../../util"), i = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.buffer = this.spec = this.emitter = null, this.filled = !1, this.space = {
                        width: 0,
                        height: 0,
                        depth: 0
                    }, this.used = {
                        width: 0,
                        height: 0,
                        depth: 0
                    }
                }
                return a(e, t), e.traits = ["node", "data", "source", "texture", "voxel"], e.prototype.sourceShader = function(t) {
                    return this.buffer.shader(t)
                }, e.prototype.getDimensions = function() {
                    var t;
                    return t = this.space, {
                        items: this.items,
                        width: t.width,
                        height: t.height,
                        depth: t.depth
                    }
                }, e.prototype.getActive = function() {
                    var t;
                    return t = this.used, {
                        items: this.items,
                        width: t.width,
                        height: t.height,
                        depth: t.depth * this.buffer.getFilled()
                    }
                }, e.prototype.make = function() {
                    var t, r, i, o, a, s, h, u, l, c, p, f;
                    return e.__super__.make.apply(this, arguments), u = this._get("texture.minFilter"), h = this._get("texture.magFilter"), p = this._get("texture.type"), f = this._get("voxel.width"), a = this._get("voxel.height"), i = this._get("voxel.depth"), t = this._get("data.dimensions"), s = this._get("data.items"), o = this.spec = {
                        channels: t,
                        items: s,
                        width: f,
                        height: a,
                        depth: i
                    }, this.items = o.items, this.channels = o.channels, r = this._get("data.data"), o = n.Data.getDimensions(r, o), l = this.space, l.width = Math.max(l.width, o.width || 1), l.height = Math.max(l.height, o.height || 1), l.depth = Math.max(l.depth, o.depth || 1), this.buffer = this._renderables.make("voxelBuffer", {
                        width: l.width,
                        height: l.height,
                        depth: l.depth,
                        channels: t,
                        items: s,
                        minFilter: u,
                        magFilter: h,
                        type: p
                    }), null != r && (c = n.Data.getThunk(r), this.emitter = n.Data.makeEmitter(c, s, t, 3)), this.trigger({
                        type: "source.rebuild"
                    })
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.buffer ? (this.buffer.dispose(), this.buffer = this.spec = this.emitter = null) : void 0
                }, e.prototype.change = function(t, e, r) {
                    var n, i;
                    if (e.voxel || e.texture || t["data.dimensions"]) return this.rebuild();
                    if (this.buffer) return t["data.expression"] || t["data.data"] || r ? (i = this.emitter, n = this._get("data.data"), null == n && (i = this.callback(this._get("data.expression"))), this.buffer.callback = i) : void 0
                }, e.prototype.update = function() {
                    var t, e, r, i, o, a, s, h, u, l, c;
                    if (this.buffer && (!this.filled || this._get("data.live"))) return e = this._get("data.data"), s = this.space, h = this.used, i = this.buffer.getFilled(), u = h.width, o = h.height, t = h.depth, null != e ? (r = n.Data.getDimensions(e, this.spec), (r.width > s.width || r.height > s.height || r.depth > s.depth) && this.rebuild(), h.width = r.width, h.height = r.height, h.depth = r.depth, this.buffer.callback.rebind(e), this.buffer.update()) : (a = this.buffer.update(), h.width = c = s.width, h.height = l = s.height, h.depth = Math.ceil(a / c / l)), (h.width !== u || h.height !== o || h.depth !== t || i !== this.buffer.getFilled()) && this.trigger({
                        type: "source.resize"
                    }), this.filled = !0
                }, e
            }(r), e.exports = i
        }, {
            "../../../util": 127,
            "./data": 46
        }],
        51: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.axisPosition = this.axisStep = this.resolution = this.line = this.arrows = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "axis", "span", "interval", "arrow", "position"], e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l, c;
                    return a = {
                        axisPosition: this._attributes.make(this._types.vec4()),
                        axisStep: this._attributes.make(this._types.vec4())
                    }, this.axisPosition = a.axisPosition.value, this.axisStep = a.axisStep.value, this._helpers.position.make(), o = this._shaders.shader(), o.pipe("axis.position", a), this._helpers.position.pipeline(o), l = this._helpers.style.uniforms(), n = this._helpers.line.uniforms(), t = this._helpers.arrow.uniforms(), e = this._get("axis.detail"), s = e + 1, this.resolution = 1 / e, h = this._get("arrow.start"), r = this._get("arrow.end"), u = this._get("line.stroke"), c = i.JS.merge(t, n, l), this.line = this._renderables.make("line", {
                        uniforms: c,
                        samples: s,
                        position: o,
                        clip: h || r,
                        stroke: u
                    }), this.arrows = [], c = i.JS.merge(t, l), h && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: c,
                        flip: !0,
                        samples: s,
                        position: o
                    })), r && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: c,
                        samples: s,
                        position: o
                    })), this._helpers.object.make(this.arrows.concat([this.line])), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    return this._helpers.object.unmake(), this._helpers.span.unmake(), this._helpers.position.unmake()
                }, e.prototype.change = function(t, e, r) {
                    var n, o, a, s;
                    return t["axis.detail"] || t["line.stroke"] ? this.rebuild() : e.interval || e.span || e.view || r ? (n = this._get("interval.axis"), s = this._helpers.span.get("", n), a = s.x, o = s.y, i.Axis.setDimension(this.axisPosition, n).multiplyScalar(a), i.Axis.setDimension(this.axisStep, n).multiplyScalar((o - a) * this.resolution)) : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        52: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.face = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "mesh", "face", "geometry", "position", "bind"], e.prototype.resize = function() {
                    var t, e, r, n, i;
                    if (null != this.bind.points) return e = this.bind.points.getActive(), n = e.items, i = e.width, r = e.height, t = e.depth, this.face && this.face.geometry.clip(i, r, t, n), this.line ? this.line.geometry.clip(n, i, r, t) : void 0
                }, e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l, c, p, f, d, m;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (u = this._shaders.shader(), this._helpers.position.make(), this.bind.points.sourceShader(u), this._helpers.position.pipeline(u), p = this._helpers.style.uniforms(), a = this._helpers.line.uniforms(), r = this.bind.points.getDimensions(), o = r.items, m = r.width, n = r.height, e = r.depth, h = this._get("face.outline"), l = this._get("mesh.shaded"), c = this._get("mesh.solid"), this.bind.colors && (t = this._shaders.shader(), this.bind.colors.sourceShader(t)), s = [], h && (f = this._shaders.shader(), f.pipe(i.GLSL.swizzleVec4("yzwx")), f.pipe(u), d = i.JS.merge(a, p), this.line = this._renderables.make("line", {
                        uniforms: d,
                        samples: o,
                        ribbons: m,
                        strips: n,
                        layers: e,
                        position: f,
                        color: t
                    }), s.push(this.line)), c && (d = i.JS.merge(p, {}), this.face = this._renderables.make("face", {
                        uniforms: d,
                        width: m,
                        height: n,
                        depth: e,
                        items: o,
                        position: u,
                        color: t,
                        shaded: l
                    }), s.push(this.face)), this.resize(), this._helpers.object.make(s)) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.face = this.line = null
                }, e.prototype.change = function(t) {
                    return t["geometry.points"] ? this.rebuild() : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        53: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.axes = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "grid", "area", "position", "axis:x", "axis:y", "scale:x", "scale:y", "span:x", "span:y"], e.prototype.make = function() {
                    var t, e, r, n, o;
                    return t = function(t) {
                        return function(e, r) {
                            var n, a, s, h, u, l, c, p, f, d, m, g, v;
                            return a = t._get(e + "axis.detail"), f = a + 1, p = 1 / a, d = t._helpers.scale.divide(r), n = t._renderables.make("dataBuffer", {
                                samples: d,
                                channels: 1
                            }), c = {
                                gridPosition: t._attributes.make(t._types.vec4()),
                                gridStep: t._attributes.make(t._types.vec4()),
                                gridAxis: t._attributes.make(t._types.vec4())
                            }, v = {
                                gridPosition: c.gridPosition.value,
                                gridStep: c.gridStep.value,
                                gridAxis: c.gridAxis.value
                            }, u = l = t._shaders.shader(), t._helpers.position.make(), u.callback(), n.shader(u), u.join(), u.pipe("grid.position", c), t._helpers.position.pipeline(l), m = t._helpers.style.uniforms(), h = t._helpers.line.uniforms(), g = i.JS.merge(h, m), s = t._renderables.make("line", {
                                uniforms: g,
                                samples: f,
                                strips: d,
                                position: l,
                                stroke: o
                            }), {
                                first: e,
                                second: r,
                                resolution: p,
                                samples: f,
                                line: s,
                                buffer: n,
                                values: v
                            }
                        }
                    }(this), e = this._get("grid.first"), n = this._get("grid.second"), o = this._get("line.stroke"), this.axes = [], e && this.axes.push(t("x.", "y.")), n && this.axes.push(t("y.", "x.")), r = function() {
                        var e, r, n, i;
                        for (n = this.axes, i = [], e = 0, r = n.length; r > e; e++) t = n[e], i.push(t.line);
                        return i
                    }.call(this), this._helpers.object.make(r), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    var t, e, r, n;
                    for (this._helpers.object.unmake(), this._helpers.span.unmake(), this._helpers.position.unmake(), n = this.axes, e = 0, r = n.length; r > e; e++) t = n[e], t.buffer.dispose();
                    return this.axes = null
                }, e.prototype.change = function(t, e, r) {
                    var n, o, a, s, h, u;
                    return t["x.axis.detail"] || t["y.axis.detail"] || t["grid.first"] || t["grid.second"] || t["line.stroke"] ? this.rebuild() : (o = function(t) {
                        return function(e, r, n, o, a) {
                            var s, h, u, l, c, p, f, d, m, g, v;
                            return h = a.first, m = a.second, f = a.resolution, d = a.samples, u = a.line, s = a.buffer, v = a.values, c = n.x, l = n.y, i.Axis.setDimension(v.gridPosition, e).multiplyScalar(c), i.Axis.setDimension(v.gridStep, e).multiplyScalar((l - c) * f), c = o.x, l = o.y, g = t._helpers.scale.generate(m, s, c, l), i.Axis.setDimension(v.gridAxis, r), p = g.length, u.geometry.clip(d, p, 1, 1)
                        }
                    }(this), (e.x || e.y || e.area || e.grid || e.view || r) && (n = this._get("area.axes"), s = this._helpers.span.get("x.", n[0]), h = this._helpers.span.get("y.", n[1]), a = this._get("grid.first"), u = this._get("grid.second"), a && o(n[0], n[1], s, h, this.axes[0]), u) ? o(n[1], n[0], h, s, this.axes[+a]) : void 0)
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        54: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.line = this.arrows = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "arrow", "geometry", "position", "bind"], e.prototype.resize = function() {
                    var t, e, r, n, i, o, a, s, h, u;
                    if (null != this.bind.points) {
                        for (e = this.bind.points.getActive(), i = e.width, o = e.height, n = e.depth, r = e.items, this.line.geometry.clip(i, o, n, r), h = this.arrows, u = [], a = 0, s = h.length; s > a; a++) t = h[a], u.push(t.geometry.clip(i, o, n, r));
                        return u
                    }
                }, e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l, c, p, f, d;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (s = this._shaders.shader(), this._helpers.position.make(), this.bind.points.sourceShader(s), this._helpers.position.pipeline(s), f = this._helpers.style.uniforms(), a = this._helpers.line.uniforms(), t = this._helpers.arrow.uniforms(), l = this._get("arrow.start"), n = this._get("arrow.end"), p = this._get("line.stroke"), r = this.bind.points.getDimensions(), u = r.width, c = r.height, h = r.depth, o = r.items, this.bind.colors && (e = this._shaders.shader(), this.bind.colors.sourceShader(e)), d = i.JS.merge(t, a, f), this.line = this._renderables.make("line", {
                        uniforms: d,
                        samples: u,
                        strips: c,
                        ribbons: h,
                        layers: o,
                        position: s,
                        color: e,
                        clip: l || n,
                        stroke: p
                    }), this.arrows = [], d = i.JS.merge(t, f), l && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: d,
                        flip: !0,
                        samples: u,
                        strips: c,
                        ribbons: h,
                        layers: o,
                        position: s,
                        color: e
                    })), n && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: d,
                        samples: u,
                        strips: c,
                        ribbons: h,
                        layers: o,
                        position: s,
                        color: e
                    })), this.resize(), this._helpers.object.make(this.arrows.concat([this.line]))) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.line = this.arrows = null
                }, e.prototype.change = function(t) {
                    return t["geometry.points"] || t["line.stroke"] || t["arrow.start"] || t["arrow.end"] ? this.rebuild() : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        55: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.point = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "point", "geometry", "position", "bind", "renderScale"], e.prototype.resize = function() {
                    var t, e, r, n, i;
                    if (null != this.bind.points) return e = this.bind.points.getActive(), i = e.width, r = e.height, t = e.depth, n = e.items, this.point.geometry.clip(i, r, t, n)
                }, e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l, c, p, f;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (this._helpers.renderScale.make(), h = this._shaders.shader(), this._helpers.position.make(), this.bind.points.sourceShader(h), this._helpers.position.pipeline(h), r = this.bind.points.getDimensions(), f = r.width, o = r.height, e = r.depth, a = r.items, c = this._helpers.style.uniforms(), s = this._helpers.point.uniforms(), u = this._helpers.renderScale.uniforms(), this.bind.colors && (t = this._shaders.shader(), this.bind.colors.sourceShader(t)), l = this._get("point.shape"), n = this._get("point.fill"), p = i.JS.merge(u, s, c), this.point = this._renderables.make("sprite", {
                        uniforms: p,
                        width: f,
                        height: o,
                        depth: e,
                        items: a,
                        position: h,
                        color: t,
                        shape: l,
                        fill: n
                    }), this.resize(), this._helpers.object.make([this.point])) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.renderScale.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.point = null
                }, e.prototype.change = function(t) {
                    return t["geometry.points"] || t["point.shape"] || t["point.fill"] ? this.rebuild() : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        56: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../../primitive"), i = t("../../../util"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.strip = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "mesh", "geometry", "position", "bind"], e.prototype.resize = function() {
                    var t, e, r, n, i;
                    if (null != this.bind.points) return e = this.bind.points.getActive(), n = e.items, i = e.width, r = e.height, t = e.depth, this.strip.geometry.clip(i, r, t, n)
                }, e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (s = this._shaders.shader(), this._helpers.position.make(), this.bind.points.sourceShader(s), this._helpers.position.pipeline(s), h = this._helpers.style.uniforms(), a = this._helpers.line.uniforms(), r = this.bind.points.getDimensions(), o = r.items, l = r.width, n = r.height, e = r.depth, this.bind.colors && (t = this._shaders.shader(), this.bind.colors.sourceShader(t)), u = i.JS.merge(h, {}), this.strip = this._renderables.make("strip", {
                        uniforms: u,
                        width: l,
                        height: n,
                        depth: e,
                        items: o,
                        position: s,
                        color: t
                    }), this.resize(), this._helpers.object.make([this.strip])) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.strip = null
                }, e.prototype.change = function(t) {
                    return t["geometry.points"] ? this.rebuild() : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        57: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../../primitive"), i = t("../../../util"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.line1 = this.line2 = this.surface = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "mesh", "geometry", "surface", "position", "grid", "bind"], e.prototype.resize = function() {
                    var t, e, r, n, i;
                    if (null != this.bind.points) return e = this.bind.points.getActive(), i = e.width, r = e.height, t = e.depth, n = e.items, this.surface && this.surface.geometry.clip(i, r, t, n), this.line1 && this.line1.geometry.clip(i, r, t, n), this.line2 ? this.line2.geometry.clip(r, i, t, n) : void 0
                }, e.prototype.make = function() {
                    var t, e, r, n, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (u = this._shaders.shader(), this._helpers.position.make(), this.bind.points.sourceShader(u), this._helpers.position.pipeline(u), y = u, T = this._shaders.shader(), T.pipe(i.GLSL.swizzleVec4("yxzw")), T.pipe(u), d = this._helpers.style.uniforms(), E = this._helpers.style.uniforms(), s = this._helpers.line.uniforms(), m = this._helpers.surface.uniforms(), E.styleColor = this._attributes.make(this._types.color()), E.styleZIndex = this._attributes.make(this._types.number()), this.wireColor = E.styleColor.value, this.wireZIndex = E.styleZIndex, this.wireScratch = new THREE.Color, r = this.bind.points.getDimensions(), v = r.width, o = r.height, e = r.depth, a = r.items, c = this._get("mesh.shaded"), p = this._get("mesh.solid"), n = this._get("grid.first"), l = this._get("grid.second"), f = this._get("line.stroke"), h = [], this.bind.colors && (t = this._shaders.shader(), this.bind.colors.sourceShader(t)), g = i.JS.merge(s, d, E), x = n || l ? -50 : 0, n && (this.line1 = this._renderables.make("line", {
                        uniforms: g,
                        samples: v,
                        strips: o,
                        ribbons: e,
                        layers: a,
                        position: y,
                        color: t,
                        zUnits: -x,
                        stroke: f
                    }), h.push(this.line1)), l && (this.line2 = this._renderables.make("line", {
                        uniforms: g,
                        samples: o,
                        strips: v,
                        ribbons: e,
                        layers: a,
                        position: T,
                        color: t,
                        zUnits: -x,
                        stroke: f
                    }), h.push(this.line2)), p && (g = i.JS.merge(m, d), this.surface = this._renderables.make("surface", {
                        uniforms: g,
                        width: v,
                        height: o,
                        surfaces: e,
                        layers: a,
                        position: u,
                        color: t,
                        shaded: c,
                        zUnits: x,
                        stroke: f
                    }), h.push(this.surface)), this.resize(), this._helpers.object.make(h)) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.line1 = this.line2 = this.surface = null
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o;
                    return t["geometry.points"] || t["mesh.shaded"] || t["mesh.solid"] || t["line.stroke"] || e.grid ? this.rebuild() : (t["style.color"] || t["mesh.solid"] || r) && (o = this._get("mesh.solid"), i = this._get("style.color"), this.wireZIndex.value = this._get("style.zIndex") + 5, this.wireColor.copy(i), o) ? (n = this.wireScratch, n.setRGB(i.x, i.y, i.z), n.convertGammaToLinear().multiplyScalar(.75).convertLinearToGamma(), this.wireColor.x = n.r, this.wireColor.y = n.g, this.wireColor.z = n.b) : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        58: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../../primitive"), i = t("../../../util"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.tickAxis = this.tickNormal = this.resolution = this.line = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "ticks", "interval", "span", "scale", "position"], e.prototype.make = function() {
                    var t, e, r, n, o, a, s;
                    return this.resolution = o = this._helpers.scale.divide(""), this.buffer = this._renderables.make("dataBuffer", {
                        samples: o,
                        channels: 1
                    }), n = {
                        tickSize: this.node.attributes["ticks.size"],
                        tickAxis: this._attributes.make(this._types.vec4()),
                        tickNormal: this._attributes.make(this._types.vec4())
                    }, this.tickAxis = n.tickAxis.value, this.tickNormal = n.tickNormal.value, this._helpers.position.make(), e = r = this._shaders.shader(), e.split(), e.callback(), this._helpers.position.pipeline(r), e.join(), e.next(), e.callback(), this.buffer.shader(e), e.join(), e.join(), e.pipe("ticks.position", n), a = this._helpers.style.uniforms(), t = this._helpers.line.uniforms(), s = i.JS.merge(t, a), this.line = this._renderables.make("line", {
                        uniforms: s,
                        samples: 2,
                        strips: o,
                        position: r
                    }), this._helpers.object.make([this.line]), this._helpers.span.make()
                }, e.prototype.unmake = function() {
                    return this.line = this.tickAxis = this.tickNormal = null, this._helpers.object.unmake(), this._helpers.span.unmake(), this._helpers.position.unmake()
                }, e.prototype.change = function(t, e, r) {
                    var n, o, a, s, h, u;
                    return t["scale.divide"] ? this.rebuild() : e.view || e.interval || e.span || e.scale || r ? (n = this._get("interval.axis"), h = this._helpers.span.get("", n), a = h.x, o = h.y, u = this._helpers.scale.generate("", this.buffer, a, o), i.Axis.setDimension(this.tickAxis, n), i.Axis.setDimensionNormal(this.tickNormal, n), s = u.length, this.line.geometry.clip(2, s)) : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        59: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../../primitive"), n = t("../../../util"), i = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.line = this.arrows = null
                }
                return a(e, t), e.traits = ["node", "object", "style", "line", "arrow", "geometry", "position", "bind"], e.prototype.resize = function() {
                    var t, e, r, n, i, o, a, s, h, u;
                    if (null != this.bind.points) {
                        for (e = this.bind.points.getActive(), i = e.items, o = e.width, n = e.height, r = e.depth, this.line.geometry.clip(i, o, n, r), h = this.arrows, u = [], a = 0, s = h.length; s > a; a++) t = h[a], u.push(t.geometry.clip(i, o, n, r));
                        return u
                    }
                }, e.prototype.make = function() {
                    var t, e, r, i, o, a, s, h, u, l, c, p, f, d, m;
                    return this._helpers.bind.make({
                        "geometry.points": "source",
                        "geometry.colors": "source"
                    }), null != this.bind.points ? (s = this._shaders.shader(), this._helpers.position.make(), d = n.GLSL.swizzleVec4("yzwx"), s.pipe(d), this.bind.points.sourceShader(s), this._helpers.position.pipeline(s), f = this._helpers.style.uniforms(), a = this._helpers.line.uniforms(), t = this._helpers.arrow.uniforms(), l = this._get("arrow.start"), i = this._get("arrow.end"), p = this._get("line.stroke"), r = this.bind.points.getDimensions(), u = r.items, c = r.width, h = r.height, o = r.depth, this.bind.colors && (e = this._shaders.shader(), e.pipe(d), this.bind.colors.sourceShader(e)), m = n.JS.merge(t, a, f), this.line = this._renderables.make("line", {
                        uniforms: m,
                        samples: u,
                        ribbons: h,
                        strips: c,
                        layers: o,
                        position: s,
                        color: e,
                        clip: l || i,
                        stroke: p
                    }), this.arrows = [], m = n.JS.merge(t, f), l && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: m,
                        flip: !0,
                        samples: u,
                        ribbons: h,
                        strips: c,
                        layers: o,
                        position: s,
                        color: e
                    })), i && this.arrows.push(this._renderables.make("arrow", {
                        uniforms: m,
                        samples: u,
                        ribbons: h,
                        strips: c,
                        layers: o,
                        position: s,
                        color: e
                    })), this.resize(), this._helpers.object.make(this.arrows.concat([this.line]))) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake(), this._helpers.position.unmake(), this.line = this.arrows = null
                }, e.prototype.change = function(t) {
                    return t["geometry.points"] || t["arrow.start"] || t["arrow.end"] ? this.rebuild() : void 0
                }, e
            }(r), e.exports = i
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        60: [function(t, e) {
            var r, n, i, o = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            r = t("../../util"), n = t("./view/view"), i = {
                bind: {
                    make: function(t) {
                        var e, r, n, i, o, a, s;
                        this.handlers.bindRebuild && this._helpers.bind.unmake(), this.bind = {}, this.handlers.bindResize = function(t) {
                            return function() {
                                return t.resize()
                            }
                        }(this), this.handlers.bindRebuild = function(t) {
                            return function() {
                                return t.rebuild()
                            }
                        }(this), this.handlers.bindWatchers = s = [];
                        for (e in t) o = t[e], a = function(t) {
                            return function() {
                                return t.rebuild()
                            }
                        }(this), s.push(a), r = e.split(/\./g).pop(), n = this._get(e), i = null != n ? this._attach(n, o, a) : null, null != i && (i.on("source.resize", this.handlers.bindResize), i.on("source.rebuild", this.handlers.bindRebuild)), this.bind[r] = i;
                        return null
                    },
                    unmake: function() {
                        var t, e, r, n, i, o, a;
                        if (this.bind) {
                            o = this.bind;
                            for (t in o) e = o[t], e && (e.off("source.resize", this.handlers.bindResize), e.off("source.rebuild", this.handlers.bindRebuild));
                            for (a = this.handlers.bindWatchers, n = 0, i = a.length; i > n; n++) r = a[n], "function" == typeof r.unwatch && r.unwatch();
                            return delete this.handlers.bindResize, delete this.handlers.bindRebuild, delete this.bind
                        }
                    }
                },
                span: {
                    make: function() {
                        return this.spanView = this._inherit("view"), null != this.spanView ? (this.handlers.span = function(t) {
                            return function() {
                                return t.change({}, {}, {}, !0)
                            }
                        }(this), this.spanView.on("view.range", this.handlers.span)) : void 0
                    },
                    unmake: function() {
                        return null != this.spanView && (this.spanView.off("view.range", this.handlers.span), delete this.handlers.span), delete this.spanView
                    },
                    get: function() {
                        var t;
                        return t = new THREE.Vector2(-1, 1),
                            function(e, r) {
                                var n;
                                return n = this._get(e + "span.range"), null != n ? n : null != this.spanView ? this.spanView.axis(r) : t
                            }
                    }()
                },
                scale: {
                    divide: function(t) {
                        var e;
                        return e = this._get(t + "scale.divide"), Math.round(2.5 * e)
                    },
                    generate: function(t, e, n, i) {
                        var o, a, s, h, u;
                        return a = this._get(t + "scale.divide"), u = this._get(t + "scale.unit"), o = this._get(t + "scale.base"), s = this._get(t + "scale.mode"), h = r.Ticks.make(s, n, i, a, u, o, !0, 0), e.copy(h), h
                    }
                },
                style: {
                    uniforms: function() {
                        return {
                            styleColor: this.node.attributes["style.color"],
                            styleOpacity: this.node.attributes["style.opacity"],
                            styleZIndex: this.node.attributes["style.zIndex"]
                        }
                    }
                },
                arrow: {
                    uniforms: function() {
                        var t, e, r, n, i;
                        return n = this._get("arrow.start"), t = this._get("arrow.end"), r = this._attributes.make(this._types.number(1 / (n + t))), i = this._attributes.make(this._types.vec2(+n, +t)), e = this.node.attributes["arrow.size"], {
                            clipStyle: i,
                            clipRange: e,
                            clipSpace: r,
                            arrowSpace: r,
                            arrowSize: e
                        }
                    }
                },
                point: {
                    uniforms: function() {
                        return {
                            pointSize: this.node.attributes["point.size"]
                        }
                    }
                },
                line: {
                    uniforms: function() {
                        return {
                            lineWidth: this.node.attributes["line.width"],
                            lineDepth: this.node.attributes["line.depth"]
                        }
                    }
                },
                surface: {
                    uniforms: function() {
                        return {}
                    }
                },
                position: {
                    make: function() {
                        var t, e, r, n;
                        return this.positionView = this._inherit("view"), t = this.positionDims = null != (r = null != (n = this.positionView) ? n.dimensions() : void 0) ? r : 3, this.objectMatrix = this._attributes.make(this._attributes.types.mat4()), 4 === t && (this.object4D = this._attributes.make(this._attributes.types.vec2())), e = function(e) {
                            return function() {
                                var r, n, i;
                                return r = e._get("object.position"), i = e._get("object.scale"), n = e._get("object.rotation"), e.objectMatrix.value.compose(r, n, i), 4 === t ? e.object4D.value.set(r.w, i.w) : void 0
                            }
                        }(this), this.handlers.position = function() {
                            return function(t) {
                                var r;
                                return r = t.changed, r["object.position"] || r["object.rotation"] || r["object.scale"] ? e() : void 0
                            }
                        }(this), this.node.on("change:object", this.handlers.position), e()
                    },
                    unmake: function() {
                        return this.objectMatrix ? (this.node.off("change:object", this.handlers.position), delete this.objectMatrix, delete this.object4D, delete this.handlers.position, delete this.positionView, delete this.positionDims) : void 0
                    },
                    shader: function(t) {
                        var e;
                        return e = function() {
                            switch (this.positionDims) {
                                case 4:
                                    return "object4.position";
                                default:
                                    return "object.position"
                            }
                        }.call(this), t.pipe(e, {
                            objectMatrix: this.objectMatrix,
                            object4D: this.object4D
                        })
                    },
                    pipeline: function(t) {
                        return this._helpers.position.shader(t), this.transform(t), this.present(t)
                    }
                },
                object: {
                    make: function(t, e) {
                        var r, n, i, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x;
                        for (this.objects = null != t ? t : [], null == e && (e = !1), this.objectParent = this._inherit("object"), this.objectScene = this._inherit("scene"), n = {
                                type: "object.visible"
                            }, l = r = f = p = null, i = o.call(this.traits, "style") >= 0, l = 1, c = this._get("object.visible"), r = THREE.NormalBlending, v = !0, m = !0, i && (l = this._get("style.opacity"), r = this._get("style.blending"), p = this._get("style.zFactor"), g = this._get("style.zUnits"), d = this._get("style.zOrder"), v = this._get("style.zWrite"), m = this._get("style.zTest")), h = this.handlers.objectChange = function(t) {
                                return function(e) {
                                    var n, i;
                                    return n = e.changed, i = null, n["object.visible"] && (i = c = t._get("object.visible")), n["style.opacity"] && (i = l = t._get("style.opacity")), n["style.blending"] && (i = r = t._get("style.blending")), n["style.zFactor"] && (i = p = t._get("style.zFactor")), n["style.zUnits"] && (i = g = t._get("style.zUnits")), n["style.zWrite"] && (i = v = t._get("style.zWrite")), n["style.zTest"] && (i = m = t._get("style.zTest")), null != i ? u() : void 0
                                }
                            }(this), a = null, u = this.handlers.objectVisible = function(t) {
                                return function() {
                                    var o, s, h, u, f, E, y, T, x, _, b, R;
                                    if (h = null != d ? d : t.node.order, o = c, o && (o = l > 0), o && null != t.objectParent && (o = t.objectParent.isVisible), o)
                                        if (i)
                                            for (_ = t.objects, u = 0, y = _.length; y > u; u++) s = _[u], s.show(1 > l || e, r, h), s.polygonOffset(p, g), s.depth(v, m);
                                        else
                                            for (b = t.objects, f = 0, T = b.length; T > f; f++) s = b[f], s.show(!1, r, h);
                                    else
                                        for (R = t.objects, E = 0, x = R.length; x > E; E++) s = R[E], s.hide();
                                    return t.isVisible = o, a !== o && t.trigger(n), a = o
                                }
                            }(this), this.node.on("change:object", h), this.node.on("change:style", h), this.node.on("reindex", u), null != (T = this.objectParent) && T.on("object.visible", u), x = this.objects, E = 0, y = x.length; y > E; E++) s = x[E], this.objectScene.adopt(s);
                        return u()
                    },
                    unmake: function(t) {
                        var e, r, n, i, o, a, s, h, u, l;
                        if (null == t && (t = !0), this.objects) {
                            for (h = this.objects, i = 0, a = h.length; a > i; i++) e = h[i], this.objectScene.unadopt(e);
                            if (t)
                                for (u = this.objects, o = 0, s = u.length; s > o; o++) e = u[o], e.dispose();
                            return r = this.handlers.objectChange, n = this.handlers.objectVisible, this.node.off("change:object", r), this.node.off("change:style", r), this.node.off("reindex", n), null != (l = this.objectParent) && l.off("object.visible", n), delete this.handlers.objectChange, delete this.handlers.objectVisible, delete this.objectVisible, delete this.objectParent, delete this.objectScene
                        }
                    }
                },
                renderScale: {
                    make: function() {
                        var t, e;
                        return this.renderRoot = this._inherit("root"), this.render = {
                            scale: t = this._attributes.make(this._types.number(0))
                        }, this.handlers.renderResize = function(e) {
                            return function() {
                                return t.value = e.root.size.renderHeight / 2
                            }
                        }(this), this.handlers.renderResize(), null != (e = this.renderRoot) ? e.on("root.resize", this.handlers.renderResize) : void 0
                    },
                    unmake: function() {
                        var t;
                        return null != (t = this.renderRoot) && t.off("root.resize", this.handlers.renderResize), delete this.handlers.renderResize
                    },
                    uniforms: function() {
                        return {
                            renderScale: this.render.scale
                        }
                    }
                }
            }, e.exports = function(t, e) {
                var r, n, o, a, s, h, u;
                for (r = {}, h = 0, u = e.length; u > h; h++)
                    if (s = e[h], a = i[s]) {
                        r[s] = {};
                        for (n in a) o = a[n], r[s][n] = o.bind(t)
                    }
                return r
            }
        }, {
            "../../util": 127,
            "./view/view": 84
        }],
        61: [function(t, e, r) {
            var n;
            n = t("../../model"), r.Classes = t("./classes"), r.Types = t("./types"), r.Traits = t("./traits"), r.Helpers = t("./helpers")
        }, {
            "../../model": 32,
            "./classes": 43,
            "./helpers": 60,
            "./traits": 74,
            "./types": 77
        }],
        62: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./operator"), i = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "bind", "operator", "source", "join"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.getDimensions = function() {
                    return this._resample(this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._resample(this.bind.source.getActive())
                }, e.prototype._resample = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m, g;
                    for (h = this.order, e = this.axis, l = this.overlap, a = this.length, f = this.stride, o = ["width", "height", "depth", "items"], s = h.map(function(t) {
                            return o[t - 1]
                        }), i = h.indexOf(e), p = function() {
                            var e, n, i;
                            for (i = [], e = 0, n = s.length; n > e; e++) r = s[e], i.push(t[r]);
                            return i
                        }(), c = (null != (g = p[i + 1]) ? g : 1) * f, p.splice(i, 2, c), p = p.slice(0, 3), p.push(1), u = {}, n = d = 0, m = s.length; m > d; n = ++d) r = s[n], u[r] = p[n];
                    return u
                }, e.prototype.make = function() {
                    var t, r, n, o, a, s, h, u, l;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (u = this._shaders.shader(), l = {
                        joinStride: this._attributes.make(this._types.number()),
                        joinStrideInv: this._attributes.make(this._types.number())
                    }, this.joinStride = l.joinStride, this.joinStrideInv = l.joinStrideInv, a = this._get("join.order"), t = this._get("join.axis"), this.order = a, this.axis = t, s = a.join(""), r = s.indexOf(t), h = s.replace(t, "00").substring(0, 4), n = [null, "width", "height", "depth", "items"], o = n[t], u.require(i.GLSL.swizzleVec4(t, 1)), u.require(i.GLSL.swizzleVec4(h, 4)), u.require(i.GLSL.injectVec4([r, r + 1])), u.pipe("join.position", l), u.pipe(i.GLSL.invertSwizzleVec4(a)), this.bind.source.sourceShader(u), this.operator = u, this.major = o, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments)
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s;
                    return t["join.axis"] || t["join.order"] ? this.rebuild() : !e.join && !r || (n = this.bind.source.getDimensions(), o = this.major, a = this._get("join.overlap"), i = n[o], a = Math.min(i - 1, a), s = i - a, this.overlap = a, this.length = i, this.stride = s, this.joinStride.value = s, this.joinStrideInv.value = 1 / s, r) ? void 0 : this.trigger({
                        type: "source.rebuild"
                    })
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        63: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./operator"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "bind", "operator", "source", "lerp"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.getDimensions = function() {
                    return this._resample(this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._resample(this.bind.source.getActive())
                }, e.prototype._resample = function(t) {
                    var e;
                    return e = this.resample, {
                        items: e.items * t.items,
                        width: e.width * t.width,
                        height: e.height * t.height,
                        depth: e.depth * t.depth
                    }
                }, e.prototype.make = function() {
                    var t, r, n, i, o, a, s;
                    if (e.__super__.make.apply(this, arguments), null != this.bind.source) {
                        o = this._shaders.shader(), this.bind.source.sourceShader(o), this.resample = {}, t = this.bind.source.getDimensions();
                        for (n in t) r = "lerp." + n, i = null != (s = this._get(r)) ? s : t[n], this.resample[n] = i / t[n], i !== t[n] && (a = {
                            sampleRatio: this._attributes.make(this._types.number((t[n] - 1) / (i - 1)))
                        }, o = this._shaders.shader()["import"](o), o.pipe(r, a));
                        return this.operator = o, this.trigger({
                            type: "source.rebuild"
                        })
                    }
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments)
                }, e.prototype.change = function(t, e) {
                    return e.lerp ? this.rebuild() : void 0
                }, e
            }(n), e.exports = r
        }, {
            "./operator": 65
        }],
        64: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./operator"), i = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "bind", "operator", "source", "image", "texture", "memo"], e.prototype.imageShader = function(t) {
                    return this.rtt.shaderRelative(t)
                }, e.prototype.sourceShader = function(t) {
                    return this.rtt.shaderAbsolute(t, 1)
                }, e.prototype.update = function() {
                    var t;
                    return null != (t = this.rtt) ? t.render() : void 0
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.make = function() {
                    var t, r, n, i, o, a, s, h, u, l, c, p, f, d;
                    if (e.__super__.make.apply(this, arguments), null != this.bind.source) {
                        for (this.memoRoot = this._inherit("root"), this.handler = function(t) {
                                return function() {
                                    return t.update()
                                }
                            }(this), this.memoRoot.on("root.update", this.handler), a = this._get("texture.minFilter"), o = this._get("texture.magFilter"), u = this._get("texture.type"), r = this.bind.source.getDimensions(), i = r.items, c = r.width, n = r.height, t = r.depth, this.rtt = this._renderables.make("renderToTexture", {
                                width: i * c,
                                height: n * t,
                                frames: 1,
                                minFilter: a,
                                magFilter: o,
                                type: u
                            }), l = {
                                remap2DScale: this._attributes.make(this._types.vec2()),
                                remapModulus: this._attributes.make(this._types.vec2()),
                                remapModulusInv: this._attributes.make(this._types.vec2())
                            }, this.remap2DScale = l.remap2DScale.value, this.remapModulus = l.remapModulus.value, this.remapModulusInv = l.remapModulusInv.value, h = this._shaders.shader(), h.pipe("screen.remap.4d.xyzw", l), this.bind.source.sourceShader(h), this.compose = this._renderables.make("screen", {
                                fragment: h
                            }), d = this.compose.objects, p = 0, f = d.length; f > p; p++) s = d[p], this.rtt.scene.add(s);
                        return this.trigger({
                            type: "source.rebuild"
                        })
                    }
                }, e.prototype.unmake = function() {
                    var t, r, n, i;
                    if (e.__super__.unmake.apply(this, arguments), null != this.bind.source) {
                        for (i = this.compose.objects, r = 0, n = i.length; n > r; r++) t = i[r], this.rtt.scene.remove(t);
                        return this.compose = null, this.rtt.dispose(), this.rtt = null, this.memoRoot.off("root.update", this.handler), this.memoRoot = null
                    }
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s;
                    if (e.memo || e.texture || e.operator) return this.rebuild();
                    if (null != this.bind.source) return e.memo || r ? (i = this.bind.source.getActive(), a = i.items, s = i.width, o = i.height, n = i.depth, this.remap2DScale.set(a * s, o * n), this.remapModulus.set(a, o), this.remapModulusInv.set(1 / a, 1 / o)) : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        65: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../base/source"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "operator", "source"], e.prototype.getDimensions = function() {
                    return this.bind.source.getDimensions()
                }, e.prototype.getActive = function() {
                    return this.bind.source.getActive()
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this._helpers.bind.make({
                        "operator.source": "source"
                    })
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake()
                }, e.prototype.resize = function() {
                    return this.trigger({
                        type: "source.resize"
                    })
                }, e
            }(n), e.exports = r
        }, {
            "../base/source": 42
        }],
        66: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), i = t("../../../util"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "bind", "operator", "source", "remap"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.getDimensions = function() {
                    return this._resample(this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._resample(this.bind.source.getActive())
                }, e.prototype._resample = function(t) {
                    var e;
                    return e = this.remapped, null != e.items && (t.items = e.items), null != e.width && (t.width = e.width), null != e.height && (t.height = e.height), null != e.depth && (t.depth = e.depth), t
                }, e.prototype.make = function() {
                    var t, r, n, o, a, s, h, u, l, c, p;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (o = this._get("remap.indices"), r = this._get("remap.dimensions"), u = this._get("remap.shader"), s = this._get("remap.map"), a = this._get("remap.items"), p = this._get("remap.width"), n = this._get("remap.height"), t = this._get("remap.depth"), this.remapped = {}, null != a && (this.remapped.items = a), null != p && (this.remapped.width = p), null != n && (this.remapped.height = n), null != t && (this.remapped.depth = t), h = this._shaders.shader(), l = [null, this._types.number, this._types.vec2, this._types.vec3, this._types.vec4][o], c = {
                        dataSize: this._attributes.make(l(0, 0, 0, 0)),
                        dataResolution: this._attributes.make(l(0, 0, 0, 0)),
                        dataOffset: this._attributes.make(this._types.vec2(.5, .5)),
                        targetSize: this._attributes.make(l(0, 0, 0, 0)),
                        targetResolution: this._attributes.make(l(0, 0, 0, 0)),
                        targetOffset: this._attributes.make(this._types.vec2(.5, .5)),
                        remapFactor: this._attributes.make(l(0, 0, 0, 0))
                    }, this.dataResolution = c.dataResolution, this.dataSize = c.dataSize, this.targetResolution = c.dataResolution, this.targetSize = c.targetSize, this.remapFactor = c.remapFactor, 0 === s && (null != a || null != p || null != n || null != t) && h.pipe("remap.relative", c), null != u ? (4 !== o && h.pipe(i.GLSL.truncateVec(4, o)), h.callback(), 4 !== o && h.pipe(i.GLSL.extendVec(o, 4)), this.bind.source.sourceShader(h), 4 !== r && h.pipe(i.GLSL.truncateVec(4, r)), h.join(), h.pipe(u, c), 4 !== r && h.pipe(i.GLSL.extendVec(r, 4))) : this.bind.source.sourceShader(h), this.operator = h, this.indices = o, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.operator = null
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s, h;
                    return e.operator || e.remap ? this.rebuild() : e.remap || r ? (n = this.bind.source.getActive(), h = this.getActive(), a = (n.items - 1) / Math.max(1, h.items - 1), s = (n.width - 1) / Math.max(1, h.width - 1), o = (n.height - 1) / Math.max(1, h.height - 1), i = (n.depth - 1) / Math.max(1, h.depth - 1), 1 === this.indices ? (this.dataResolution.value = 1 / n.width, this.targetResolution.value = 1 / h.width, this.dataSize.value = n.width, this.targetSize.value = h.width, this.remapFactor.value = s) : (this.dataResolution.value.set(1 / n.width, 1 / n.height, 1 / n.depth, 1 / n.items), this.targetResolution.value.set(1 / h.width, 1 / h.height, 1 / h.depth, 1 / h.items), this.dataSize.value.set(n.width, n.height, n.depth, n.items), this.targetSize.value.set(h.width, h.height, h.depth, h.items), this.remapFactor.value.set(s, o, i, a))) : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        67: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "bind", "operator", "source", "repeat"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.getDimensions = function() {
                    return this._resample(this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._resample(this.bind.source.getActive())
                }, e.prototype._resample = function(t) {
                    var e;
                    return e = this.resample, {
                        items: e.items * t.items,
                        width: e.width * t.width,
                        height: e.height * t.height,
                        depth: e.depth * t.depth
                    }
                }, e.prototype.make = function() {
                    var t, r;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (t = this._shaders.shader(), this.resample = {}, r = {
                        repeatModulus: this._attributes.make(this._types.vec4())
                    }, this.repeatModulus = r.repeatModulus, t.pipe("repeat.position", r), this.bind.source.sourceShader(t), this.operator = t, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments)
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o;
                    if (e.operator) return this.rebuild();
                    if (this.bind.source && (n = this.bind.source.getActive(), this.repeatModulus.value.set(n.width, n.height, n.depth, n.items)), e.repeat || r) {
                        for (o in this.getDimensions()) i = "repeat." + o, this.resample[o] = this._get(i);
                        if (!r) return this.trigger({
                            type: "source.rebuild"
                        })
                    }
                }, e
            }(r), e.exports = n
        }, {
            "./operator": 65
        }],
        68: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), i = t("../../../util"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "bind", "operator", "source", "split"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.getDimensions = function() {
                    return this._resample(this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._resample(this.bind.source.getActive())
                }, e.prototype._resample = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p, f, d, m;
                    for (h = this.order, e = this.axis, l = this.overlap, a = this.length, f = this.stride, o = ["width", "height", "depth", "items"], s = h.map(function(t) {
                            return o[t - 1]
                        }), i = h.indexOf(e), p = function() {
                            var e, n, i;
                            for (i = [], e = 0, n = s.length; n > e; e++) r = s[e], i.push(t[r]);
                            return i
                        }(), c = Math.floor((p[i] - l) / f), p.splice(i, 1, a, c), p = p.slice(0, 4), u = {}, n = d = 0, m = s.length; m > d; n = ++d) r = s[n], u[r] = p[n];
                    return u
                }, e.prototype.make = function() {
                    var t, r, n, o, a, s, h, u, l;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (h = this._shaders.shader(), u = {
                        splitStride: this._attributes.make(this._types.number())
                    }, this.splitStride = u.splitStride, n = this._get("split.order"), t = this._get("split.axis"), this.order = n, this.axis = t, o = n.join(""), r = o.indexOf(t), s = o[r] + (null != (l = o[r + 1]) ? l : 0), a = o.replace(s[1], "").replace(s[0], "0") + "0", h.require(i.GLSL.swizzleVec4(s, 2)), h.require(i.GLSL.swizzleVec4(a, 4)), h.require(i.GLSL.injectVec4(r)), h.pipe("split.position", u), h.pipe(i.GLSL.invertSwizzleVec4(n)), this.bind.source.sourceShader(h), this.operator = h, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments)
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a;
                    return t["split.axis"] || t["split.order"] || e.operator ? this.rebuild() : e.split || r ? (o = this._get("split.overlap"), i = this._get("split.length"), o = Math.min(i - 1, o), a = i - o, this.overlap = o, this.length = i, this.stride = a, this.splitStride.value = a, n = this.bind.source.getDimensions(), this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        69: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "bind", "operator", "source", "spread"], e.prototype.sourceShader = function(t) {
                    return t.pipe(this.operator)
                }, e.prototype.make = function() {
                    var t, r;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (r = {
                        spreadMatrix: this._attributes.make(this._types.mat4()),
                        spreadOffset: this._attributes.make(this._types.vec4())
                    }, this.spreadMatrix = r.spreadMatrix, this.spreadOffset = r.spreadOffset, t = this._shaders.shader(), t.callback(), this.bind.source.sourceShader(t), t.join(), t.pipe("spread.position", r), this.operator = t, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments)
                }, e.prototype.resize = function() {
                    return this.refresh(), e.__super__.resize.apply(this, arguments)
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _;
                    if (e.operator) return this.rebuild();
                    if ((e.spread || r) && this.bind.source) {
                        for (n = this._get("spread.anchor"), o = this.bind.source.getActive(), p = this.spreadMatrix.value, a = p.elements, d = ["width", "height", "depth", "items"], _ = [], h = v = 0, y = d.length; y > v; h = ++v) {
                            for (c = d[h], u = "spread." + c, m = this._get(u), s = 0, null != m ? (i = null != (T = o[c]) ? T : 1, f = -(i - 1) * (.5 - .5 * n)) : f = 0, l = E = 0; 4 > E; l = ++E) g = null != (x = null != m ? m.getComponent(l) : void 0) ? x : 0, a[4 * h + l] = 2 * g;
                            _.push(this.spreadOffset.value.setComponent(h, f))
                        }
                        return _
                    }
                }, e
            }(r), e.exports = n
        }, {
            "./operator": 65
        }],
        70: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), i = t("../../../util"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "bind", "operator", "source", "swizzle"], e.prototype.sourceShader = function(t) {
                    return this.bind.source.sourceShader(t), this.swizzler ? t.pipe(this.swizzler) : void 0
                }, e.prototype.make = function() {
                    var t;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (t = this._get("swizzle.order"), "1234" !== t.join() && (this.swizzler = i.GLSL.swizzleVec4(t, 4)), this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.swizzler = null
                }, e.prototype.change = function(t, e) {
                    return e.swizzle || e.operator ? this.rebuild() : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        71: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./operator"), i = t("../../../util"), o = {
                1: "width",
                2: "height",
                3: "depth",
                4: "items"
            }, n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return s(e, t), e.traits = ["node", "bind", "operator", "source", "transpose"], e.prototype.sourceShader = function(t) {
                    return this.swizzler && t.pipe(this.swizzler), this.bind.source.sourceShader(t)
                }, e.prototype.getDimensions = function() {
                    return this._remap(this.transpose, this.bind.source.getDimensions())
                }, e.prototype.getActive = function() {
                    return this._remap(this.transpose, this.bind.source.getActive())
                }, e.prototype._remap = function(t, e) {
                    var r, n, i, a, s, h;
                    for (i = {}, n = s = 0; 3 >= s; n = ++s) r = o[n + 1], a = o[t[n]], i[r] = null != (h = e[a]) ? h : 1;
                    return i
                }, e.prototype.make = function() {
                    var t;
                    return e.__super__.make.apply(this, arguments), null != this.bind.source ? (t = this._get("transpose.order"), "1234" !== t.join() && (this.swizzler = i.GLSL.invertSwizzleVec4(t)), this.transpose = t, this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), this.swizzler = null
                }, e.prototype.change = function(t, e) {
                    return e.transpose || e.operator ? this.rebuild() : void 0
                }, e
            }(r), e.exports = n
        }, {
            "../../../util": 127,
            "./operator": 65
        }],
        72: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../../primitive"), i = t("../../../util"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.compose = null
                }
                return a(e, t), e.traits = ["node", "bind", "object", "operator", "style", "compose"], e.defaults = {
                    zWrite: !1,
                    zTest: !1
                }, e.prototype.resize = function() {
                    var t, e, r, n, i;
                    if (this.compose && this.bind.source) return e = this.bind.source.getActive(), i = e.width, r = e.height, t = e.depth, n = e.items, this.remap2DScale.set(i, r)
                }, e.prototype.make = function() {
                    var t, e, r, n;
                    return this._helpers.bind.make({
                        "operator.source": "source"
                    }), null != this.bind.source ? (n = {
                        remap2DScale: this._attributes.make(this._types.vec2())
                    }, this.remap2DScale = n.remap2DScale.value, r = this._shaders.shader(), t = this._get("compose.alpha"), this.bind.source.is("image") ? this.bind.source.imageShader(r) : (r.pipe("screen.remap.2d.xyzw", n), this.bind.source.sourceShader(r)), t || r.pipe("color.opaque"), e = this._helpers.style.uniforms(), this.compose = this._renderables.make("screen", {
                        fragment: r,
                        uniforms: e
                    }), this.resize(), this._helpers.object.make([this.compose], !0)) : void 0
                }, e.prototype.unmake = function() {
                    return this._helpers.bind.unmake(), this._helpers.object.unmake()
                }, e.prototype.change = function(t) {
                    return t["operator.source"] || t["compose.alpha"] ? this.rebuild() : void 0
                }, e
            }(n), e.exports = r
        }, {
            "../../../util": 127,
            "../../primitive": 37
        }],
        73: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../base/root"), r = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n), this.rtt = this.scene = this.width = this.height = this.history = this.size = null, this.event = {
                        type: "update"
                    }
                }
                return o(e, t), e.traits = ["node", "root", "scene", "texture", "rtt", "source", "image"], e.defaults = {
                    minFilter: "linear",
                    magFilter: "linear",
                    type: "unsignedByte"
                }, e.prototype.imageShader = function(t) {
                    return this.rtt.shaderRelative(t)
                }, e.prototype.sourceShader = function(t) {
                    return this.rtt.shaderAbsolute(t, this.history)
                }, e.prototype.update = function() {
                    var t;
                    return this.trigger(this.event), null != (t = this.rtt) ? t.render() : void 0
                }, e.prototype.getDimensions = function() {
                    return {
                        items: 1,
                        width: this.width,
                        height: this.height,
                        depth: this.history
                    }
                }, e.prototype.getActive = function() {
                    return this.getDimensions()
                }, e.prototype.make = function() {
                    var t, e, r, n, i;
                    return this.parentRoot = this._inherit("root"), this.size = this.parentRoot.getSize(), this.updateHandler = function(t) {
                        return function() {
                            return t.update()
                        }
                    }(this), this.resizeHandler = function(t) {
                        return function(e) {
                            return t.resize(e.size)
                        }
                    }(this), this.parentRoot.on("root.update", this.updateHandler), this.parentRoot.on("root.resize", this.resizeHandler), null != this.size ? (e = this._get("texture.minFilter"), t = this._get("texture.magFilter"), r = this._get("texture.type"), this.width = null != (n = this._get("rtt.width")) ? n : this.size.renderWidth, this.height = null != (i = this._get("rtt.height")) ? i : this.size.renderHeight, this.history = this._get("rtt.history"), null == this.scene && (this.scene = this._renderables.make("scene")), this.rtt = this._renderables.make("renderToTexture", {
                        scene: this.scene,
                        width: this.width,
                        height: this.height,
                        frames: this.history,
                        minFilter: e,
                        magFilter: t,
                        type: r
                    }), this.trigger({
                        type: "source.rebuild"
                    })) : void 0
                }, e.prototype.unmake = function(t) {
                    return this.parentRoot.off("root.update", this.updateHandler), this.parentRoot.off("root.resize", this.resizeHandler), null != this.rtt ? (this.rtt.dispose(), t || this.scene.dispose(), this.rtt = this.width = this.height = this.history = null) : void 0
                }, e.prototype.change = function(t, e) {
                    return e.texture || t["rtt.width"] || t["rtt.height"] ? this.rebuild() : null != this.size ? (null != this.rtt && (this.rtt.camera.aspect = this.size.aspect), this.rtt.camera.updateProjectionMatrix(), this.trigger({
                        type: "root.resize",
                        size: this.size
                    })) : void 0
                }, e.prototype.adopt = function(t) {
                    var e, r, n, i, o;
                    for (i = t.objects, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this.scene.add(e));
                    return o
                }, e.prototype.unadopt = function(t) {
                    var e, r, n, i, o;
                    for (i = t.objects, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this.scene.remove(e));
                    return o
                }, e.prototype.resize = function(t) {
                    return this.size = t, this.change({}, {
                        texture: !0
                    }, {}, !0)
                }, e.prototype.transform = function() {}, e.prototype.present = function(t) {
                    return t.pipe("view.position")
                }, e
            }(n), e.exports = r
        }, {
            "../base/root": 41
        }],
        74: [function(t, e) {
            var r, n;
            n = t("./types"), r = {
                node: {
                    id: n.nullable(n.string()),
                    classes: n.classes()
                },
                object: {
                    position: n.vec4(),
                    rotation: n.quat(),
                    scale: n.vec4(1, 1, 1, 1),
                    visible: n.bool(!0)
                },
                style: {
                    opacity: n.number(1),
                    color: n.color(),
                    blending: n.blending(),
                    zWrite: n.bool(!0),
                    zTest: n.bool(!0),
                    zFactor: n.number(0),
                    zUnits: n.number(0),
                    zIndex: n.number(0),
                    zOrder: n.nullable(n.number())
                },
                overlay: {
                    opacity: n.number(1)
                },
                html: {
                    element: n.select()
                },
                label: {
                    attach: n.select(),
                    data: n.nullable(n.object()),
                    expression: n.nullable(n.func())
                },
                point: {
                    size: n.number(.01),
                    shape: n.shape(),
                    fill: n.bool(!0)
                },
                line: {
                    width: n.number(.01),
                    depth: n.number(.5),
                    stroke: n.stroke()
                },
                mesh: {
                    solid: n.bool(!0),
                    shaded: n.bool(!0)
                },
                face: {
                    outline: n.bool(!1)
                },
                arrow: {
                    size: n.number(.07),
                    start: n.bool(!1),
                    end: n.bool(!1)
                },
                ticks: {
                    size: n.number(.05)
                },
                view: {
                    range: n.array(n.vec2(-1, 1), 4)
                },
                span: {
                    range: n.nullable(n.vec2(-1, 1))
                },
                project4: {
                    projection: n.mat4(1, 0, 0, .577, 0, 1, 0, .577, 0, 0, 1, .577, 0, 0, 0, 0)
                },
                polar: {
                    bend: n.number(1),
                    helix: n.number(0)
                },
                spherical: {
                    bend: n.number(1)
                },
                stereographic: {
                    bend: n.number(1)
                },
                interval: {
                    axis: n.axis()
                },
                area: {
                    axes: n.swizzle([1, 2], 2)
                },
                volume: {
                    axes: n.swizzle([1, 2, 3], 3)
                },
                scale: {
                    divide: n.number(10),
                    unit: n.number(1),
                    base: n.number(10),
                    mode: n.scale()
                },
                grid: {
                    first: n.bool(!0),
                    second: n.bool(!0)
                },
                axis: {
                    detail: n.int(1)
                },
                geometry: {
                    points: n.select(),
                    colors: n.nullable(n.select())
                },
                source: {
                    hint: n.nullable(n.string())
                },
                data: {
                    data: n.nullable(n.object()),
                    expression: n.nullable(n.func()),
                    live: n.bool(!0),
                    dimensions: n.int(3),
                    items: n.int(1)
                },
                sampler: {
                    centered: n.bool(!1)
                },
                array: {
                    length: n.nullable(n.int(1)),
                    history: n.int(1)
                },
                matrix: {
                    width: n.nullable(n.int(1)),
                    height: n.nullable(n.int(1)),
                    history: n.int(1)
                },
                voxel: {
                    width: n.nullable(n.int(1)),
                    height: n.nullable(n.int(1)),
                    depth: n.nullable(n.int(1))
                },
                texture: {
                    minFilter: n.filter("nearest"),
                    magFilter: n.filter("nearest"),
                    type: n.type("float")
                },
                operator: {
                    source: n.select()
                },
                spread: {
                    items: n.nullable(n.vec4()),
                    width: n.nullable(n.vec4()),
                    height: n.nullable(n.vec4()),
                    depth: n.nullable(n.vec4()),
                    anchor: n.number(0)
                },
                split: {
                    order: n.transpose("wxyz"),
                    axis: n.axis(),
                    length: n.int(1),
                    overlap: n.int(0)
                },
                join: {
                    order: n.transpose("wxyz"),
                    axis: n.axis(),
                    overlap: n.int(0)
                },
                swizzle: {
                    order: n.swizzle()
                },
                transpose: {
                    order: n.transpose()
                },
                repeat: {
                    items: n.number(1),
                    width: n.number(1),
                    height: n.number(1),
                    depth: n.number(1)
                },
                lerp: {
                    items: n.nullable(n.int()),
                    width: n.nullable(n.int()),
                    height: n.nullable(n.int()),
                    depth: n.nullable(n.int())
                },
                remap: {
                    indices: n.number(4),
                    dimensions: n.number(4),
                    map: n.remap(),
                    shader: n.nullable(n.string()),
                    items: n.nullable(n.int()),
                    width: n.nullable(n.int()),
                    height: n.nullable(n.int()),
                    depth: n.nullable(n.int())
                },
                root: {
                    camera: n.nullable(n.select())
                },
                rtt: {
                    width: n.nullable(n.int()),
                    height: n.nullable(n.int()),
                    history: n.int(1)
                },
                compose: {
                    alpha: n.bool(!1)
                }
            }, e.exports = r
        }, {
            "./types": 77
        }],
        75: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./transform"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "project4"], e.prototype.make = function() {
                    return this.uniforms = {
                        projectionMatrix: this.node.attributes["project4.projection"]
                    }
                }, e.prototype.unmake = function() {
                    return delete this.uniforms
                }, e.prototype.to = function(t) {
                    return t.applyMatrix4(this.projectionMatrix)
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("project4.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e
            }(n), e.exports = r
        }, {
            "./transform": 76
        }],
        76: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../base/parent"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node"], e.prototype.to = function() {}, e
            }(r), e.exports = n
        }, {
            "../base/parent": 39
        }],
        77: [function(t, e) {
            var r, n = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            r = {
                array: function(t, e, r) {
                    return null == r && (r = null), {
                        uniform: function() {
                            return t.uniform ? t.uniform() + "v" : void 0
                        },
                        make: function() {
                            var n, i, o;
                            if (null != r) return r.slice();
                            if (!e) return [];
                            for (o = [], n = i = 0; e >= 0 ? e > i : i > e; n = e >= 0 ? ++i : --i) o.push(t.make());
                            return o
                        },
                        validate: function(r, n) {
                            var i, o, a, s, h;
                            if (null != r.constructor && r.constructor === Array)
                                for (o = n.length = e ? e : r.length, i = s = 0; o >= 0 ? o > s : s > o; i = o >= 0 ? ++s : --s) a = t.validate(r[i], n[i]), void 0 !== a && (n[i] = a);
                            else
                                for (o = n.length = e, i = h = 0; o >= 0 ? o >= h : h >= o; i = o >= 0 ? ++h : --h) n[i] = t.value
                        },
                        equals: function(e, r) {
                            var n, i, o, a, s;
                            if (n = e.length, i = r.length, n !== i) return !1;
                            for (a = Math.min(n, i), o = s = 0; a >= 0 ? a > s : s > a; o = a >= 0 ? ++s : --s)
                                if (!("function" == typeof t.equals ? t.equals(e[o], r[o]) : void 0)) return !1;
                            return !0
                        }
                    }
                },
                letters: function(t, e, n) {
                    var i, o, a, s, h;
                    if (null == n && (n = null), null != n)
                        for (n === "" + n && (n = n.split("")), o = s = 0, h = n.length; h > s; o = ++s) a = n[o], n[o] = t.validate(a, a);
                    return i = r.array(t, e, n), {
                        uniform: function() {
                            return i.uniform()
                        },
                        make: function() {
                            return i.make()
                        },
                        validate: function(t, e) {
                            return t === "" + t && (t = t.split("")), i.validate(t, e)
                        },
                        equals: function(t, e) {
                            return i.equals(t, e)
                        }
                    }
                },
                nullable: function(t) {
                    return {
                        make: function() {
                            return null
                        },
                        validate: function(e, r) {
                            return null === e ? e : (null === r && (r = t.make()), e = t.validate(e, r), void 0 !== e ? e : r)
                        },
                        equals: function(e, r) {
                            var n, i;
                            return n = null === e, i = null === r, n && i ? !0 : n ^ i ? !1 : "function" == typeof t.equals ? t.equals(e, r) : void 0
                        }
                    }
                },
                "enum": function(t, e, r) {
                    var n, i, o, a, s;
                    for (null == r && (r = {}), o = {}, n = a = 0, s = e.length; s > a; n = ++a) i = e[n], null == r[i] && (r[i] = n);
                    for (i in r) n = r[i], o[n] = !0;
                    return null == o[t] && (t = r[t]), {
                        make: function() {
                            return t
                        },
                        validate: function(t) {
                            var e;
                            return e = o[t] ? t : r[t], null != e ? e : void 0
                        }
                    }
                },
                select: function(t) {
                    return null == t && (t = "<"), {
                        make: function() {
                            return t
                        },
                        validate: function(t) {
                            return "string" == typeof t ? t : "object" == typeof t ? t : void 0
                        }
                    }
                },
                bool: function(t) {
                    return t = !!t, {
                        uniform: function() {
                            return "f"
                        },
                        make: function() {
                            return t
                        },
                        validate: function(t) {
                            return !!t
                        }
                    }
                },
                "int": function(t) {
                    return null == t && (t = 0), t = +Math.round(t), {
                        uniform: function() {
                            return "i"
                        },
                        make: function() {
                            return t
                        },
                        validate: function(t) {
                            return +Math.round(t) || 0
                        }
                    }
                },
                number: function(t) {
                    return null == t && (t = 0), {
                        uniform: function() {
                            return "f"
                        },
                        make: function() {
                            return +t
                        },
                        validate: function(t) {
                            return +t || 0
                        }
                    }
                },
                string: function(t) {
                    return null == t && (t = ""), {
                        make: function() {
                            return "" + t
                        },
                        validate: function(t) {
                            return "" + t
                        }
                    }
                },
                func: function() {
                    return {
                        make: function() {
                            return function() {}
                        },
                        validate: function(t) {
                            return "function" == typeof t ? t : void 0
                        }
                    }
                },
                object: function(t) {
                    return {
                        make: function() {
                            return null != t ? t : {}
                        },
                        validate: function(t) {
                            return "object" == typeof t ? t : void 0
                        }
                    }
                },
                vec2: function(t, e) {
                    var r;
                    return null == t && (t = 0), null == e && (e = 0), r = [t, e], {
                        uniform: function() {
                            return "v2"
                        },
                        make: function() {
                            return new THREE.Vector2(t, e)
                        },
                        validate: function(n, i) {
                            n instanceof THREE.Vector2 ? i.copy(n) : (null != n ? n.constructor : void 0) === Array ? (n = n.concat(r.slice(n.length)), i.set.apply(i, n)) : i.set(t, e)
                        },
                        equals: function(t, e) {
                            return t.x === e.x && t.y === e.y
                        }
                    }
                },
                vec3: function(t, e, r) {
                    var n;
                    return null == t && (t = 0), null == e && (e = 0), null == r && (r = 0), n = [t, e, r], {
                        uniform: function() {
                            return "v3"
                        },
                        make: function() {
                            return new THREE.Vector3(t, e, r)
                        },
                        validate: function(i, o) {
                            i instanceof THREE.Vector3 ? o.copy(i) : (null != i ? i.constructor : void 0) === Array ? (i = i.concat(n.slice(i.length)), o.set.apply(o, i)) : o.set(t, e, r)
                        },
                        equals: function(t, e) {
                            return t.x === e.x && t.y === e.y && t.z === e.z
                        }
                    }
                },
                vec4: function(t, e, r, n) {
                    var i;
                    return null == t && (t = 0), null == e && (e = 0), null == r && (r = 0), null == n && (n = 0), i = [t, e, r, n], {
                        uniform: function() {
                            return "v4"
                        },
                        make: function() {
                            return new THREE.Vector4(t, e, r, n)
                        },
                        validate: function(o, a) {
                            o instanceof THREE.Vector4 ? a.copy(o) : (null != o ? o.constructor : void 0) === Array ? (o = o.concat(i.slice(o.length)), a.set.apply(a, o)) : a.set(t, e, r, n)
                        },
                        equals: function(t, e) {
                            return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w
                        }
                    }
                },
                mat4: function(t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m) {
                    var g;
                    return null == t && (t = 1), null == e && (e = 0), null == r && (r = 0), null == n && (n = 0), null == i && (i = 0), null == o && (o = 1), null == a && (a = 0), null == s && (s = 0), null == h && (h = 0), null == u && (u = 0), null == l && (l = 1), null == c && (c = 0), null == p && (p = 0), null == f && (f = 0), null == d && (d = 0), null == m && (m = 1), g = [t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m], {
                        uniform: function() {
                            return "m4"
                        },
                        make: function() {
                            return new THREE.Matrix4(t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m)
                        },
                        validate: function(v, E) {
                            v instanceof THREE.Matrix4 ? E.copy(v) : (null != v ? v.constructor : void 0) === Array ? (v = v.concat(g.slice(v.length)), E.set.apply(E, v)) : E.set(t, e, r, n, i, o, a, s, h, u, l, c, p, f, d, m)
                        }
                    }
                },
                quat: function(t, e, n, i) {
                    var o;
                    return null == t && (t = 0), null == e && (e = 0), null == n && (n = 0), null == i && (i = 1), o = r.vec4(t, e, n, i), {
                        uniform: function() {
                            return "v4"
                        },
                        make: function() {
                            return new THREE.Quaternion
                        },
                        validate: function(t, e) {
                            var r;
                            return t instanceof THREE.Quaternion ? e.copy(t) : r = o.validate(t, e), (null != r ? r : e).normalize(), r
                        },
                        equals: function(t, e) {
                            return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w
                        }
                    }
                },
                color: function(t, e, n) {
                    var i;
                    return null == t && (t = .5), null == e && (e = .5), null == n && (n = .5), i = r.vec3(t, e, n), {
                        uniform: function() {
                            return "v3"
                        },
                        make: function() {
                            return new THREE.Vector3(t, e, n)
                        },
                        validate: function(t, e) {
                            var r;
                            return t === "" + t ? (r = t, t = (new THREE.Color).setStyle(r)) : t === +t && (t = new THREE.Color(t)), t instanceof THREE.Color ? void e.set(t.r, t.g, t.b) : i.validate(t, e)
                        },
                        equals: function(t, e) {
                            return t.x === e.x && t.y === e.y
                        }
                    }
                },
                axis: function(t, e) {
                    var r, i, o;
                    return null == t && (t = 1), null == e && (e = !1), r = {
                        x: 1,
                        y: 2,
                        z: 3,
                        w: 4,
                        i: 4,
                        "null": 0,
                        width: 1,
                        height: 2,
                        depth: 3,
                        items: 4
                    }, i = e ? [0, 1, 2, 3, 4] : [1, 2, 3, 4], null != (o = r[t]) && (t = o), {
                        make: function() {
                            return t
                        },
                        validate: function(t) {
                            var e;
                            return null != (o = r[t]) && (t = o), t = null != (e = Math.round(t)) ? e : 0, n.call(i, t) >= 0 ? t : void 0
                        }
                    }
                },
                transpose: function(t) {
                    var e, n;
                    return null == t && (t = [1, 2, 3, 4]), n = r.letters(r.axis(null, !1), 0, t), e = r.letters(r.axis(null, !1), 4, t), {
                        make: function() {
                            return e.make()
                        },
                        validate: function(t, r) {
                            var i, o, a, s, h;
                            return s = [1, 2, 3, 4], n.validate(t, s), s.length < 4 && (a = [1, 2, 3, 4].filter(function(t) {
                                return -1 === s.indexOf(t)
                            }), s = s.concat(a)), h = function() {
                                var t, e, r;
                                for (r = [], i = t = 0, e = s.length; e > t; i = ++t) o = s[i], r.push(s.indexOf(o) === i);
                                return r
                            }(), h.indexOf(!1) < 0 ? e.validate(s, r) : void 0
                        },
                        equals: function(t, r) {
                            return e.equals(t, r)
                        }
                    }
                },
                swizzle: function(t, e) {
                    var n, i;
                    return null == t && (t = [1, 2, 3, 4]), null == e && (e = 4), t = t.slice(0, e), i = r.letters(r.axis(null, !1), 0, t), n = r.letters(r.axis(null, !0), e, t), {
                        make: function() {
                            return n.make()
                        },
                        validate: function(r, o) {
                            var a;
                            return a = t.slice(), i.validate(r, a), a.length < e && (a = a.concat([0, 0, 0, 0]).slice(0, e)), n.validate(a, o)
                        },
                        equals: function(t, e) {
                            return n.equals(t, e)
                        }
                    }
                },
                classes: function() {
                    var t;
                    return t = r.array(r.string()), {
                        make: function() {
                            return t.make()
                        },
                        validate: function(e, r) {
                            return e === "" + e && (e = e.split(" ")), e = e.filter(function(t) {
                                return !!t.length
                            }), t.validate(e, r)
                        },
                        equals: function(e, r) {
                            return t.equals(e, r)
                        }
                    }
                },
                blending: function(t) {
                    var e;
                    return null == t && (t = "normal"), e = ["no", "normal", "add", "subtract", "multiply", "custom"], r["enum"](t, e)
                },
                filter: function(t) {
                    var e;
                    return null == t && (t = "nearest"), e = {
                        nearest: THREE.NearestFilter,
                        nearestMipMapNearest: THREE.NearestMipMapNearestFilter,
                        nearestMipMapLinear: THREE.NearestMipMapLinearFilter,
                        linear: THREE.LinearFilter,
                        linearMipMapNearest: THREE.LinearMipMapNearestFilter,
                        lienarMipmapLinear: THREE.LinearMipMapLinearFilter
                    }, r["enum"](t, [], e)
                },
                type: function(t) {
                    var e;
                    return null == t && (t = "unsignedByte"), e = {
                        unsignedByte: THREE.UnsignedByteType,
                        "byte": THREE.ByteType,
                        "short": THREE.ShortType,
                        unsignedShort: THREE.UnsignedShortType,
                        "int": THREE.IntType,
                        unsignedInt: THREE.UnsignedIntType,
                        "float": THREE.FloatType
                    }, r["enum"](t, [], e)
                },
                scale: function(t) {
                    var e;
                    return null == t && (t = "linear"), e = ["linear", "log"], r["enum"](t, e)
                },
                remap: function(t) {
                    var e;
                    return null == t && (t = "relative"), e = ["relative", "absolute"], r["enum"](t, e)
                },
                shape: function(t) {
                    var e;
                    return null == t && (t = "circle"), e = ["circle", "square", "diamond", "triangle"], r["enum"](t, e)
                },
                stroke: function(t) {
                    var e;
                    return null == t && (t = "solid"), e = ["solid", "dotted", "dashed"], r["enum"](t, e)
                }
            }, e.exports = r
        }, {}],
        78: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./view"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this.uniforms = {
                        viewMatrix: this._attributes.make(this._types.mat4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.objectMatrix = new THREE.Matrix4
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.objectMatrix, delete this.positionMatrix
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d, m;
                    if (e.object || e.view || r) return a = this._get("object.position"), u = this._get("object.scale"), s = this._get("object.rotation"), h = this._get("view.range"), f = h[0].x, d = h[1].x, m = h[2].x, n = h[0].y - f || 1, i = h[1].y - d || 1, o = h[2].y - m || 1, l = u.x, c = u.y, p = u.z, this.viewMatrix.set(2 / n, 0, 0, -(2 * f + n) / n, 0, 2 / i, 0, -(2 * d + i) / i, 0, 0, 2 / o, -(2 * m + o) / o, 0, 0, 0, 1), this.objectMatrix.compose(a, s, u), this.viewMatrix.multiplyMatrices(this.objectMatrix, this.viewMatrix), t["view.range"] ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function(t) {
                    return t.applyMatrix4(this.viewMatrix)
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("cartesian.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e
            }(n), e.exports = r
        }, {
            "./view": 84
        }],
        79: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./view"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "object", "view", "view4"], e.prototype.dimensions = function() {
                    return 4
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this.uniforms = {
                        viewMatrix: this._attributes.make(this._types.mat4()),
                        view4D: this._attributes.make(this._attributes.types.vec2()),
                        basisScale: this._attributes.make(this._types.vec4()),
                        basisOffset: this._attributes.make(this._types.vec4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.view4D = this.uniforms.view4D.value, this.basisScale = this.uniforms.basisScale.value, this.basisOffset = this.uniforms.basisOffset.value, this.rotationMatrix = new THREE.Matrix4, this.v3 = new THREE.Vector3
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.rotationMatrix, delete this.positionMatrix
                }, e.prototype.change = function(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E;
                    if (e.object || e.view || r) return s = this._get("object.position"), l = this._get("object.scale"), h = this._get("object.rotation"), u = this._get("view.range"), g = u[0].x, v = u[1].x, E = u[2].x, m = u[3].x, i = u[0].y - g || 1, o = u[1].y - v || 1, a = u[2].y - E || 1, n = u[3].y - E || 1, p = l.x, f = l.y, d = l.z, c = l.w, this.basisScale.set(2 / i, 2 / o, 2 / a, 2 / n), this.basisOffset.set(-(2 * g + i) / i, -(2 * v + o) / o, -(2 * E + a) / a, -(2 * m + n) / n), this.viewMatrix.compose(s, h, l), this.view4D.set(s.w, l.w), t["view.range"] ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function() {
                    throw "TODO"
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("cartesian4.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e
            }(n), e.exports = r
        }, {
            "./view": 84
        }],
        80: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("./view"), n = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "object", "view", "polar"], e.prototype.make = function() {
                    var t;
                    return e.__super__.make.apply(this, arguments), t = this._attributes.types, this.uniforms = {
                        polarBend: this.node.attributes["polar.bend"],
                        polarHelix: this.node.attributes["polar.helix"],
                        polarFocus: this._attributes.make(t.number()),
                        polarAspect: this._attributes.make(t.number()),
                        viewMatrix: this._attributes.make(t.mat4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.objectMatrix = new THREE.Matrix4, this.aspect = 1
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.objectMatrix
                }, e.prototype.change = function(t, e, r) {
                    var i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H;
                    if (e.object || e.view || e.polar || r) return this.helix = p = this._get("polar.helix"), this.bend = a = this._get("polar.bend"), this.focus = c = a > 0 ? 1 / a - 1 : 0, d = this._get("object.position"), v = this._get("object.scale"), m = this._get("object.rotation"), g = this._get("view.range"), b = g[0].x, R = g[1].x, w = g[2].x, s = g[0].y - b || 1, h = g[1].y - R || 1, u = g[2].y - w || 1, T = v.x, x = v.y, _ = v.z, f = s > 0 ? 1 : -1, H = n.Axis.recenterAxis(R, h, a), R = H[0], h = H[1], i = Math.abs(h), l = s + (i * f - s) * a, E = l / T, y = h / x, this.aspect = o = Math.abs(E / y), this.uniforms.polarFocus.value = c, this.uniforms.polarAspect.value = o, this.viewMatrix.set(2 / l, 0, 0, -(2 * b + s) / s, 0, 2 / h, 0, -(2 * R + h) / h, 0, 0, 2 / u, -(2 * w + u) / u, 0, 0, 0, 1), this.objectMatrix.compose(d, m, v), this.viewMatrix.multiplyMatrices(this.objectMatrix, this.viewMatrix), t["view.range"] || e.polar ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function(t) {
                    var e, r;
                    return this.bend > 1e-4 && (e = this.focus + t.y * aspect, r = t.x * this.bend, t.z += t.x * this.helix * this.bend, t.x = Math.sin(r) * e, t.y = (Math.cos(r) * e - focus) / aspect), t.applyMatrix4(this.viewMatrix)
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("polar.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e.prototype.axis = function(t) {
                    var e, r, n;
                    return n = this._get("view.range")[t - 1], r = n.x, e = n.y, 2 === t && this.bend > 0 && (e = Math.max(Math.abs(e), Math.abs(r)), r = Math.max(-this.focus / this.aspect + .001, r)), new THREE.Vector2(r, e)
                }, e
            }(i), e.exports = r
        }, {
            "../../../util": 127,
            "./view": 84
        }],
        81: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("./view"), n = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "object", "view", "spherical"], e.prototype.make = function() {
                    var t;
                    return e.__super__.make.apply(this, arguments), t = this._attributes.types, this.uniforms = {
                        sphericalBend: this.node.attributes["spherical.bend"],
                        sphericalFocus: this._attributes.make(this._types.number()),
                        sphericalAspectX: this._attributes.make(this._types.number()),
                        sphericalAspectY: this._attributes.make(this._types.number()),
                        sphericalScaleY: this._attributes.make(this._types.number()),
                        viewMatrix: this._attributes.make(this._types.mat4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.objectMatrix = new THREE.Matrix4, this.aspectX = 1, this.aspectY = 1
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.objectMatrix
                }, e.prototype.change = function(t, e, r) {
                    var i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L;
                    if (e.object || e.view || e.spherical || r) return this.bend = h = this._get("spherical.bend"), this.focus = d = h > 0 ? 1 / h - 1 : 0, v = this._get("object.position"), T = this._get("object.scale"), E = this._get("object.rotation"), y = this._get("view.range"), S = y[0].x, A = y[1].x, C = y[2].x, u = y[0].y - S || 1, l = y[1].y - A || 1, c = y[2].y - C || 1, w = T.x, H = T.y, M = T.z, k = n.Axis.recenterAxis(A, l, h), A = k[0], l = k[1], L = n.Axis.recenterAxis(C, c, h), C = L[0], c = L[1], m = u > 0 ? 1 : -1, g = l > 0 ? 1 : -1, i = Math.abs(c), p = u + (i * m - u) * h, f = l + (i * g - l) * h, _ = p / w, b = f / H, R = c / M, this.aspectX = o = Math.abs(_ / R), this.aspectY = a = Math.abs(b / R / o), s = l / u * w / H * 2, this.scaleY = x = Math.min(a / h, 1 + (s - 1) * h), this.uniforms.sphericalBend.value = h, this.uniforms.sphericalFocus.value = d, this.uniforms.sphericalAspectX.value = o, this.uniforms.sphericalAspectY.value = a, this.uniforms.sphericalScaleY.value = x, this.viewMatrix.set(2 / p, 0, 0, -(2 * S + u) / u, 0, 2 / f, 0, -(2 * A + l) / l, 0, 0, 2 / c, -(2 * C + c) / c, 0, 0, 0, 1), this.objectMatrix.compose(v, E, T), this.viewMatrix.multiplyMatrices(this.objectMatrix, this.viewMatrix), t["view.range"] || e.spherical ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function(t) {
                    var e, r, n, i;
                    return this.bend > 1e-4 && (r = this.focus + t.z * this.aspectX, n = t.x * this.bend, i = t.y * this.bend / this.aspectY * this.scaleY, e = Math.cos(i) * r, t.x = Math.sin(n) * e, t.x = Math.sin(i) * r * aspectY, t.z = (Math.cos(n) * e - focus) / aspectX), t.applyMatrix4(this.viewMatrix)
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("spherical.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e.prototype.axis = function(t) {
                    var e, r, n;
                    return n = this._get("view.range")[t - 1], r = n.x, e = n.y, 3 === t && this.bend > 0 && (e = Math.max(Math.abs(e), Math.abs(r)), r = Math.max(-this.focus / this.aspectX + .001, r)), new THREE.Vector2(r, e)
                }, e
            }(i), e.exports = r
        }, {
            "../../../util": 127,
            "./view": 84
        }],
        82: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("./view"), n = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "object", "view", "stereographic"], e.prototype.make = function() {
                    var t;
                    return e.__super__.make.apply(this, arguments), t = this._attributes.types, this.uniforms = {
                        stereoBend: this.node.attributes["stereographic.bend"],
                        viewMatrix: this._attributes.make(this._types.mat4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.objectMatrix = new THREE.Matrix4
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.rotationMatrix
                }, e.prototype.change = function(t, e, r) {
                    var i, o, a, s, h, u, l, c, p, f, d, m, g, v, E;
                    if (e.object || e.view || e.stereographic || r) return this.bend = i = this._get("stereographic.bend"), h = this._get("object.position"), c = this._get("object.scale"), u = this._get("object.rotation"), l = this._get("view.range"), m = l[0].x, g = l[1].x, v = l[2].x, o = l[0].y - m || 1, a = l[1].y - g || 1, s = l[2].y - v || 1, p = c.x, f = c.y, d = c.z, E = n.Axis.recenterAxis(v, s, i, 1), v = E[0], s = E[1], this.uniforms.stereoBend.value = i, this.viewMatrix.set(2 / o, 0, 0, -(2 * m + o) / o, 0, 2 / a, 0, -(2 * g + a) / a, 0, 0, 2 / s, -(2 * v + s) / s, 0, 0, 0, 1), this.objectMatrix.compose(h, u, c), this.viewMatrix.multiplyMatrices(this.objectMatrix, this.viewMatrix), t["view.range"] || e.stereographic ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function(t) {
                    return t.applyMatrix4(this.viewMatrix)
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("stereographic.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e.prototype.axis = function(t) {
                    var e, r, n;
                    return n = this._get("view.range")[t - 1], r = n.x, e = n.y, new THREE.Vector2(r, e)
                }, e
            }(i), e.exports = r
        }, {
            "../../../util": 127,
            "./view": 84
        }],
        83: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("./view"), n = t("../../../util"), r = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return a(e, t), e.traits = ["node", "object", "view", "view4", "stereographic"], e.prototype.dimensions = function() {
                    return 4
                }, e.prototype.make = function() {
                    return e.__super__.make.apply(this, arguments), this.uniforms = {
                        stereoBend: this.node.attributes["stereographic.bend"],
                        viewMatrix: this._attributes.make(this._types.mat4()),
                        view4D: this._attributes.make(this._types.vec2()),
                        basisScale: this._attributes.make(this._types.vec4()),
                        basisOffset: this._attributes.make(this._types.vec4())
                    }, this.viewMatrix = this.uniforms.viewMatrix.value, this.view4D = this.uniforms.view4D.value, this.basisScale = this.uniforms.basisScale.value, this.basisOffset = this.uniforms.basisOffset.value, this.objectMatrix = new THREE.Matrix4, this.v3 = new THREE.Vector3
                }, e.prototype.unmake = function() {
                    return e.__super__.unmake.apply(this, arguments), delete this.viewMatrix, delete this.rotationMatrix
                }, e.prototype.change = function(t, e, r) {
                    var i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x;
                    if (e.object || e.view || r) return this.bend = i = this._get("stereographic.bend"), u = this._get("object.position"), p = this._get("object.scale"), l = this._get("object.rotation"), c = this._get("view.range"), E = c[0].x, y = c[1].x, T = c[2].x, v = c[3].x, a = c[0].y - E || 1, s = c[1].y - y || 1, h = c[2].y - T || 1, o = c[3].y - T || 1, d = p.x, m = p.y, g = p.z, f = p.w, x = n.Axis.recenterAxis(v, o, i, 1), v = x[0], o = x[1], this.uniforms.stereoBend.value = i, this.basisScale.set(2 / a, 2 / s, 2 / h, 2 / o), this.basisOffset.set(-(2 * E + a) / a, -(2 * y + s) / s, -(2 * T + h) / h, -(2 * v + o) / o), this.viewMatrix.compose(u, l, p), this.view4D.set(u.w, p.w), t["view.range"] || e.stereographic ? this.trigger({
                        type: "view.range"
                    }) : void 0
                }, e.prototype.to = function() {
                    throw "TODO"
                }, e.prototype.transform = function(t) {
                    var e;
                    return t.pipe("stereographic4.position", this.uniforms), null != (e = this.parent) ? e.transform(t) : void 0
                }, e
            }(i), e.exports = r
        }, {
            "../../../util": 127,
            "./view": 84
        }],
        84: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("../base/parent"), n = function(t) {
                function e() {
                    return e.__super__.constructor.apply(this, arguments)
                }
                return o(e, t), e.traits = ["node", "object", "view"], e.prototype.make = function() {
                    return this._helpers.object.make()
                }, e.prototype.unmake = function() {
                    return this._helpers.object.unmake()
                }, e.prototype.dimensions = function() {
                    return 3
                }, e.prototype.axis = function(t) {
                    return this._get("view.range")[t - 1]
                }, e.prototype.to = function() {}, e
            }(r), e.exports = n
        }, {
            "../base/parent": 39
        }],
        85: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./buffer"), i = t("./texture/datatexture"), o = t("../../util"), r = function(t) {
                function e(t, r, n) {
                    this.callback = n.callback || function() {}, this.length = n.length || 1, this.history = n.history || 1, this.samples = this.length, e.__super__.constructor.call(this, t, r, n)
                }
                return s(e, t), e.prototype.shader = function(t) {
                    return t.pipe("map.xyzw.texture", this.uniforms), e.__super__.shader.call(this, t)
                }, e.prototype.build = function(t) {
                    return e.__super__.build.apply(this, arguments), this.data = new Float32Array(this.samples * this.channels * this.items), this.texture = new i(this.gl, this.samples * this.items, this.history, this.channels, t), this.index = 0, this.filled = 0, this.dataPointer = this.uniforms.dataPointer.value, this._adopt(this.texture.uniforms), this._adopt({
                        textureItems: {
                            type: "f",
                            value: this.items
                        },
                        textureHeight: {
                            type: "f",
                            value: 1
                        }
                    })
                }, e.prototype.getFilled = function() {
                    return this.filled
                }, e.prototype.iterate = function() {
                    var t, e, r, n;
                    for (t = this.callback, n = this.generate(), r = this.samples, null != t.reset && t.reset(), e = 0; r > e && t(e++, n) !== !1;);
                    return e
                }, e.prototype.write = function(t) {
                    return null == t && (t = this.samples), this.texture.write(this.data, 0, this.index, t * this.items, 1), this.dataPointer.set(.5, this.index + .5), this.index = (this.index + this.history - 1) % this.history, this.filled = Math.min(this.history, this.filled + 1)
                }, e
            }(n), e.exports = r
        }, {
            "../../util": 127,
            "./buffer": 86,
            "./texture/datatexture": 90
        }],
        86: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../renderable"), i = t("../../util"), r = function(t) {
                function e(t, r, n) {
                    null == this.items && (this.items = n.items || 1), null == this.samples && (this.samples = n.samples || 1), null == this.channels && (this.channels = n.channels || 4), e.__super__.constructor.call(this, t, r), this.build(n)
                }
                return a(e, t), e.iterationLimit = 65535, e.prototype.shader = function(t) {
                    return t.pipe("map.2d.data", this.uniforms), t.pipe("sample.2d", this.uniforms), this.channels < 4 ? t.pipe(i.GLSL.swizzleVec4(["0000", "x000", "xw00", "xyz0"][this.channels])) : void 0
                }, e.prototype.build = function() {
                    return this.uniforms = {
                        dataPointer: {
                            type: "v2",
                            value: new THREE.Vector2
                        }
                    }
                }, e.prototype.dispose = function() {
                    return this.data = null, this.texture.dispose(), e.__super__.dispose.apply(this, arguments)
                }, e.prototype.update = function() {
                    var t;
                    return t = this.iterate(), this.write(t), t
                }, e.prototype.copy = function(t) {
                    var e, r, n, i;
                    for (n = Math.min(t.length, this.samples * this.channels * this.items), e = this.data, r = i = 0; n >= 0 ? n > i : i > n; r = n >= 0 ? ++i : --i) e[r] = t[r];
                    return this.write(Math.floor(n / this.channels / this.items))
                }, e.prototype.write = function() {}, e.prototype.iterate = function() {}, e.prototype.generate = function() {
                    var t, e, r;
                    switch (t = this.data, r = this.samples * this.channels * this.items, e = 0, this.channels) {
                        case 1:
                            return function(n) {
                                return t[e++] = n, r - e > 0
                            };
                        case 2:
                            return function(n, i) {
                                return t[e++] = n, t[e++] = i, r - e > 0
                            };
                        case 3:
                            return function(n, i, o) {
                                return t[e++] = n, t[e++] = i, t[e++] = o, r - e > 0
                            };
                        case 4:
                            return function(n, i, o, a) {
                                return t[e++] = n, t[e++] = i, t[e++] = o, t[e++] = a, r - e > 0
                            }
                    }
                }, e
            }(n), e.exports = r
        }, {
            "../../util": 127,
            "../renderable": 114
        }],
        87: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./buffer"), i = t("./texture/datatexture"), n = function(t) {
                function e(t, r, n) {
                    e.__super__.constructor.call(this, t, r, n)
                }
                return a(e, t), e.prototype.build = function(t) {
                    return e.__super__.build.apply(this, arguments), this.data = new Float32Array(this.samples * this.channels * this.items), this.texture = new i(this.gl, this.samples * this.items, 1, this.channels, t), this.dataPointer = this.uniforms.dataPointer.value, this._adopt(this.texture.uniforms)
                }, e.prototype.write = function(t) {
                    return null == t && (t = this.samples * this.items), this.texture.write(this.data, 0, 0, t, 1), this.dataPointer.set(.5, .5)
                }, e
            }(r), e.exports = n
        }, {
            "./buffer": 86,
            "./texture/datatexture": 90
        }],
        88: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./buffer"), n = t("./texture/datatexture"), i = function(t) {
                function e(t, r, n) {
                    this.callback = n.callback || function() {}, this.width = n.width || 1, this.height = n.height || 1, this.history = n.history || 1, this.samples = this.width * this.height, e.__super__.constructor.call(this, t, r, n)
                }
                return a(e, t), e.prototype.shader = function(t) {
                    return t.pipe("map.xyzw.texture", this.uniforms), e.__super__.shader.call(this, t)
                }, e.prototype.build = function(t) {
                    return e.__super__.build.apply(this, arguments), this.data = new Float32Array(this.samples * this.items * this.channels), this.texture = new n(this.gl, this.width * this.items, this.height * this.history, this.channels, t), this.index = 0, this.filled = 0, this.dataPointer = this.uniforms.dataPointer.value, this._adopt(this.texture.uniforms), this._adopt({
                        textureItems: {
                            type: "f",
                            value: this.items
                        },
                        textureHeight: {
                            type: "f",
                            value: this.height
                        }
                    })
                }, e.prototype.getFilled = function() {
                    return this.filled
                }, e.prototype.iterate = function() {
                    var t, e, r, n, i, o, a, s;
                    for (t = this.callback, a = this.generate(), o = this.width, i = this.samples, null != t.reset && t.reset(), e = r = n = 0; i > n && (n++, s = t(e, r, a), ++e === o && (e = 0, r++), s !== !1););
                    return n
                }, e.prototype.write = function(t) {
                    var e, r;
                    return null == t && (t = this.samples), r = this.width * this.items, e = Math.ceil(t / this.width), this.texture.write(this.data, 0, this.index * this.height, r, e), this.dataPointer.set(.5, this.index * this.height + .5), this.index = (this.index + this.history - 1) % this.history, this.filled = Math.min(this.history, this.filled + 1)
                }, e
            }(r), e.exports = i
        }, {
            "./buffer": 86,
            "./texture/datatexture": 90
        }],
        89: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("../renderable"), r = t("./texture/rendertarget"), o = t("../../util"), n = function(t) {
                function e(t, r, n) {
                    var i;
                    this.scene = null != (i = n.scene) ? i : new THREE.Scene, e.__super__.constructor.call(this, t, r), this.build(n)
                }
                return s(e, t), e.prototype.shaderRelative = function(t) {
                    return t.pipe("sample.2d", this.uniforms)
                }, e.prototype.shaderAbsolute = function(t, e) {
                    var r;
                    return null == e && (e = 1), 1 === e ? (t.pipe(o.GLSL.truncateVec(4, 2)), t.pipe("map.2d.data", this.uniforms), t.pipe("sample.2d", this.uniforms)) : (r = o.GLSL.sample2DArray(Math.min(e, this.target.frames)), t.pipe("map.xyzw.2dv"), t.split(), t.pipe("map.2d.data", this.uniforms), t.pass(), t.pipe(r, this.uniforms))
                }, e.prototype.build = function(t) {
                    var e;
                    return this.camera = new THREE.PerspectiveCamera, this.camera.position.set(0, 0, 3), this.camera.lookAt(new THREE.Vector3), "function" == typeof(e = this.scene).inject && e.inject(), this.target = new r(this.gl, t.width, t.height, t.frames, t), this.target.warmup(function(t) {
                        return function(e) {
                            return t.renderer.setRenderTarget(e)
                        }
                    }(this)), this.renderer.setRenderTarget(null), this._adopt(this.target.uniforms), this._adopt({
                        dataPointer: {
                            type: "v2",
                            value: new THREE.Vector2(.5, .5)
                        }
                    }), this.filled = 0
                }, e.prototype.render = function(t) {
                    var e;
                    return null == t && (t = this.camera), this.renderer.render(null != (e = this.scene.scene) ? e : this.scene, this.camera, this.target.write), this.target.cycle(), this.filled < this.target.frames ? this.filled++ : void 0
                }, e.prototype.read = function(t) {
                    return null == t && (t = 0), this.target.reads[Math.abs(t)]
                }, e.prototype.getFrames = function() {
                    return this.target.frames
                }, e.prototype.getFilled = function() {
                    return this.filled
                }, e.prototype.dispose = function() {
                    var t;
                    return "function" == typeof(t = this.scene).unject && t.unject(), this.scene = this.camera = null, this.target.dispose(), e.__super__.dispose.apply(this, arguments)
                }, e
            }(i), e.exports = n
        }, {
            "../../util": 127,
            "../renderable": 114,
            "./texture/rendertarget": 91
        }],
        90: [function(t, e) {
            var r, n;
            n = t("../../../Util"), r = function() {
                function t(t, e, r, i, o) {
                    var a, s, h, u, l, c;
                    this.gl = t, this.width = e, this.height = r, this.channels = i, this.n = this.width * this.height * this.channels, t = this.gl, s = null != (u = o.minFilter) ? u : THREE.NearestFilter, a = null != (l = o.magFilter) ? l : THREE.NearestFilter, h = null != (c = o.type) ? c : THREE.FloatType, this.minFilter = n.Three.paramToGL(t, s), this.magFilter = n.Three.paramToGL(t, s), this.type = n.Three.paramToGL(t, h), this.ctor = n.Three.paramToArrayStorage(h), this.build()
                }
                return t.prototype.build = function() {
                    var t;
                    return t = this.gl, this.texture = t.createTexture(), this.format = [null, t.LUMINANCE, t.LUMINANCE_ALPHA, t.RGB, t.RGBA][this.channels], this.format3 = [null, THREE.LuminanceFormat, THREE.LuminanceAlphaFormat, THREE.RGBFormat, THREE.RGBAFormat][this.channels], t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, this.minFilter), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, this.magFilter), this.data = new this.ctor(this.n), t.pixelStorei(t.UNPACK_ALIGNMENT, 1), t.texImage2D(t.TEXTURE_2D, 0, this.format, this.width, this.height, 0, this.format, this.type, this.data), this.textureObject = new THREE.Texture(new Image, new THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter), this.textureObject.__webglInit = !0, this.textureObject.__webglTexture = this.texture, this.textureObject.format = this.format3, this.textureObject.type = THREE.FloatType, this.textureObject.unpackAlignment = 1, this.uniforms = {
                        dataResolution: {
                            type: "v2",
                            value: new THREE.Vector2(1 / this.width, 1 / this.height)
                        },
                        dataTexture: {
                            type: "t",
                            value: this.textureObject
                        }
                    }
                }, t.prototype.write = function(t, e, r, n, i) {
                    var o;
                    return o = this.gl, o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_ALIGNMENT, 1), o.texSubImage2D(o.TEXTURE_2D, 0, e, r, n, i, this.format, this.type, t)
                }, t.prototype.dispose = function() {
                    return this.gl.deleteTexture(this.texture), this.textureObject.__webglInit = !1, this.textureObject.__webglTexture = null, this.textureObject = this.texture = null
                }, t
            }(), e.exports = r
        }, {
            "../../../Util": 23
        }],
        91: [function(t, e) {
            var r;
            r = function() {
                function t(t, e, r, n, i) {
                    this.gl = t, null == i && (i = {}), null == i.minFilter && (i.minFilter = THREE.LinearFilter), null == i.magFilter && (i.magFilter = THREE.LinearFilter), null == i.format && (i.format = THREE.RGBAFormat), null == i.type && (i.type = THREE.UnsignedByteType), this.options = i, this.width = e || 1, this.height = r || 1, this.frames = n || 1, this.buffers = this.frames + 1, this.build()
                }
                return t.prototype.build = function() {
                    var t, e;
                    return e = function(t) {
                        return function() {
                            return new THREE.WebGLRenderTarget(t.width, t.height, t.options)
                        }
                    }(this), this.targets = function() {
                        var r, n, i;
                        for (i = [], t = r = 0, n = this.buffers; n >= 0 ? n > r : r > n; t = n >= 0 ? ++r : --r) i.push(e());
                        return i
                    }.call(this), this.reads = function() {
                        var r, n, i;
                        for (i = [], t = r = 0, n = this.buffers; n >= 0 ? n > r : r > n; t = n >= 0 ? ++r : --r) i.push(e());
                        return i
                    }.call(this), this.write = e(), this.index = 0, this.uniforms = {
                        dataResolution: {
                            type: "v2",
                            value: new THREE.Vector2(1 / this.width, 1 / this.height)
                        },
                        dataTexture: {
                            type: "t",
                            value: this.reads[0]
                        },
                        dataTextures: {
                            type: "tv",
                            value: this.reads
                        }
                    }
                }, t.prototype.cycle = function() {
                    var t, e, r, n, i, o, a, s, h;
                    for (i = ["__webglTexture", "__webglFramebuffer", "__webglRenderbuffer"], e = this.buffers, r = function(t, e) {
                            var r, n, o;
                            for (n = 0, o = i.length; o > n; n++) r = i[n], e[r] = t[r];
                            return null
                        }, t = function(t, r) {
                            return (t + r + 2 * e) % e
                        }, r(this.write, this.targets[this.index]), h = this.reads, n = a = 0, s = h.length; s > a; n = ++a) o = h[n], r(this.targets[t(this.index, -n)], o);
                    return this.index = t(this.index, 1), r(this.targets[this.index], this.write)
                }, t.prototype.warmup = function(t) {
                    var e, r, n, i;
                    for (i = [], e = r = 0, n = this.buffers; n >= 0 ? n > r : r > n; e = n >= 0 ? ++r : --r) t(this.write), i.push(this.cycle());
                    return i
                }, t.prototype.dispose = function() {
                    var t, e, r, n;
                    for (n = this.targets, e = 0, r = n.length; r > e; e++) t = n[e], t.dispose();
                    return this.targets = this.reads = this.write = null
                }, t
            }(), e.exports = r
        }, {}],
        92: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./buffer"), n = t("./texture/datatexture"), i = function(t) {
                function e(t, r, n) {
                    this.callback = n.callback || function() {}, this.width = n.width || 1, this.height = n.height || 1, this.depth = n.depth || 1, this.samples = this.width * this.height * this.depth, e.__super__.constructor.call(this, t, r, n)
                }
                return a(e, t), e.prototype.shader = function(t) {
                    return t.pipe("map.xyzw.texture", this.uniforms), e.__super__.shader.call(this, t)
                }, e.prototype.build = function(t) {
                    return e.__super__.build.apply(this, arguments), this.data = new Float32Array(this.samples * this.items * this.channels), this.texture = new n(this.gl, this.width * this.items, this.height * this.depth, this.channels, t), this.filled = 0, this.dataPointer = this.uniforms.dataPointer.value, this._adopt(this.texture.uniforms), this._adopt({
                        textureItems: {
                            type: "f",
                            value: this.items
                        },
                        textureHeight: {
                            type: "f",
                            value: this.height
                        }
                    })
                }, e.prototype.getFilled = function() {
                    return this.filled
                }, e.prototype.iterate = function() {
                    var t, e, r, n, i, o, a, s, h, u, l;
                    for (t = this.callback, u = this.generate(), s = this.width, a = this.height, h = this.depth, o = this.samples, null != t.reset && t.reset(), e = r = n = i = 0; o > i && (i++, l = t(e, r, n, u), ++e === s && (e = 0, ++r === a && (r = 0, n++)), l !== !1););
                    return i
                }, e.prototype.write = function(t) {
                    var e, r;
                    return null == t && (t = this.samples), r = this.width * this.items, e = Math.ceil(t / this.width), this.texture.write(this.data, 0, 0, r, e), this.dataPointer.set(.5, .5), this.filled = 1
                }, e
            }(r), e.exports = i
        }, {
            "./buffer": 86,
            "./texture/datatexture": 90
        }],
        93: [function(t, e) {
            var r;
            r = {
                sprite: t("./meshes/sprite"),
                line: t("./meshes/line"),
                surface: t("./meshes/surface"),
                face: t("./meshes/face"),
                strip: t("./meshes/strip"),
                arrow: t("./meshes/arrow"),
                screen: t("./meshes/screen"),
                debug: t("./meshes/debug"),
                dataBuffer: t("./buffer/databuffer"),
                arrayBuffer: t("./buffer/arraybuffer"),
                matrixBuffer: t("./buffer/matrixbuffer"),
                voxelBuffer: t("./buffer/voxelbuffer"),
                renderToTexture: t("./buffer/rendertotexture"),
                scene: t("./scene")
            }, e.exports = r
        }, {
            "./buffer/arraybuffer": 85,
            "./buffer/databuffer": 87,
            "./buffer/matrixbuffer": 88,
            "./buffer/rendertotexture": 89,
            "./buffer/voxelbuffer": 92,
            "./meshes/arrow": 105,
            "./meshes/debug": 107,
            "./meshes/face": 108,
            "./meshes/line": 109,
            "./meshes/screen": 110,
            "./meshes/sprite": 111,
            "./meshes/strip": 112,
            "./meshes/surface": 113,
            "./scene": 115
        }],
        94: [function(t, e) {
            var r;
            r = function() {
                function t(t, e, r) {
                    this.gl = t, this.classes = e, this.shaders = r
                }
                return t.prototype.getTypes = function() {
                    return Object.keys(this.classes)
                }, t.prototype.make = function(t, e) {
                    return new this.classes[t](this.gl, this.shaders, e)
                }, t
            }(), e.exports = r
        }, {}],
        95: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./geometry"), r = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k, L, z, P, D, F, U, O, B, V, N;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.sides = w = +t.sides || 12, this.samples = R = +t.samples || 2, this.strips = M = +t.strips || 1, this.ribbons = b = +t.ribbons || 1, this.layers = y = +t.layers || 1, this.flip = d = null != (V = t.flip) ? V : !1, this.anchor = n = null != (N = t.anchor) ? N : d ? 0 : R - 1, a = M * b * y, x = (w + 2) * a, A = 2 * w * a, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * A), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * x), 4)), this.addAttribute("arrow", new THREE.BufferAttribute(new Float32Array(3 * x), 3)), this.addAttribute("attach", new THREE.BufferAttribute(new Float32Array(2 * x), 2)), this._autochunk(), g = this._emitter("index"), _ = this._emitter("position4"), o = this._emitter("arrow"), s = this._emitter("attach"), p = [], v = z = 0; w >= 0 ? w > z : z > w; v = w >= 0 ? ++z : --z) i = v / w * τ, p.push([Math.cos(i), Math.sin(i), 1]);
                    for (l = 0, m = P = 0; a >= 0 ? a > P : P > a; m = a >= 0 ? ++P : --P) {
                        for (S = l++, u = S + w + 1, v = D = 0; w >= 0 ? w > D : D > w; v = w >= 0 ? ++D : --D) r = l + v % w, h = l + (v + 1) % w, g(S), g(r), g(h), g(h), g(r), g(u);
                        l += w + 1
                    }
                    for (H = d ? 1 : -1, f = d ? R - 1 : 0, T = n + H, C = n, E = F = 0; y >= 0 ? y > F : F > y; E = y >= 0 ? ++F : --F)
                        for (L = U = 0; b >= 0 ? b > U : U > b; L = b >= 0 ? ++U : --U)
                            for (k = O = 0; M >= 0 ? M > O : O > M; k = M >= 0 ? ++O : --O) {
                                for (_(C, k, L, E), o(0, 0, 0), s(T, f), v = B = 0; w >= 0 ? w > B : B > w; v = w >= 0 ? ++B : --B) _(C, k, L, E), c = p[v], o(c[0], c[1], c[2]), s(T, f);
                                _(C, k, L, E), o(0, 0, 1), s(T, f)
                            }
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a, s;
                    return null == t && (t = this.samples), null == e && (e = this.strips), null == r && (r = this.ribbons), null == n && (n = this.layers), s = Math.max(0, t - 1), this.geometryClip.set(s, e, r, n), t > this.anchor ? (i = [n, r, e], o = [this.layers, this.ribbons, this.strips], a = this.sides * this._reduce(i, o)) : a = 0, this._offsets([{
                        start: 0,
                        count: 6 * a
                    }])
                }, e
            }(n), e.exports = r
        }, {
            "./geometry": 97
        }],
        96: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./geometry"), r = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.items = s = +t.items || 2, this.width = m = +t.width || 1, this.height = i = +t.height || 1, this.depth = n = +t.depth || 1, this.sides = f = Math.max(0, s - 2), p = m * i * n, l = s * p, d = f * p, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * d), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * l), 4)), this._autochunk(), a = this._emitter("index"), c = this._emitter("position4"), r = 0, o = y = 0; p >= 0 ? p > y : y > p; o = p >= 0 ? ++y : --y) {
                        for (h = T = 0; f >= 0 ? f > T : T > f; h = f >= 0 ? ++T : --T) a(r), a(r + h + 1), a(r + h + 2);
                        r += s
                    }
                    for (E = x = 0; n >= 0 ? n > x : x > n; E = n >= 0 ? ++x : --x)
                        for (v = _ = 0; i >= 0 ? i > _ : _ > i; v = i >= 0 ? ++_ : --_)
                            for (g = b = 0; m >= 0 ? m > b : b > m; g = m >= 0 ? ++b : --b)
                                for (u = R = 0; s >= 0 ? s > R : R > s; u = s >= 0 ? ++R : --R) c(g, v, E, u);
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a, s;
                    return null == t && (t = this.width), null == e && (e = this.height), null == r && (r = this.depth), null == n && (n = this.items), a = Math.max(0, n - 2), this.geometryClip.set(t, e, r, n), i = [r, e, t, a], o = [this.depth, this.height, this.width, this.sides], s = this._reduce(i, o), this._offsets([{
                        start: 0,
                        count: 3 * s
                    }])
                }, e
            }(n), e.exports = r
        }, {
            "./geometry": 97
        }],
        97: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = !1, i = function() {
                var t;
                return t = +new Date,
                    function(e) {
                        var r;
                        return r = +new Date - t, console.log(e, r + " ms"), r
                    }
            }, r = function(t) {
                function e() {
                    THREE.BufferGeometry.call(this), null == this.uniforms && (this.uniforms = {}), null == this.offsets && (this.offsets = []), n && (this.tock = i()), this.chunked = !1, this.limit = 65535
                }
                return a(e, t), e.prototype._reduce = function(t, e) {
                    var r, n, i, o, a, s, h;
                    for (o = !1, n = s = 0, h = t.length; h > s; n = ++s) r = t[n], i = e[n], o && (t[n] = i), r > 1 && (o = !0);
                    return a = t.reduce(function(t, e) {
                        return t * e
                    })
                }, e.prototype._emitter = function(t) {
                    var e, r, n, i, o, a, s, h;
                    return r = this.attributes[t], n = r.itemSize, e = r.array, o = 0, a = function(t) {
                        return e[o++] = t
                    }, h = function(t, r) {
                        return e[o++] = t, e[o++] = r
                    }, s = function(t, r, n) {
                        return e[o++] = t, e[o++] = r, e[o++] = n
                    }, i = function(t, r, n, i) {
                        return e[o++] = t, e[o++] = r, e[o++] = n, e[o++] = i
                    }, [null, a, h, s, i][n]
                }, e.prototype._autochunk = function() {
                    var t, e, r, n, i, o;
                    r = this.attributes.index, o = this.attributes;
                    for (n in o)
                        if (e = o[n], "index" !== n && r) {
                            i = e.array.length / e.itemSize, i > this.limit && (this.chunked = !0);
                            break
                        }
                    return this.chunked && !r.u16 ? (r.u16 = t = r.array, r.array = new Uint32Array(t.length)) : void 0
                }, e.prototype._finalize = function() {
                    var t;
                    if (this.chunked) return t = this.attributes.index, this.chunks = this._chunks(t.array, this.limit), this._chunkify(t, this.chunks), n ? this.tock(this.constructor.name) : void 0
                }, e.prototype._chunks = function(t, e) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v;
                    for (i = [], p = 0, g = t[0], o = t[0], m = function(t) {
                            var e, r, n;
                            return n = 3 * p, r = 3 * t, e = r - n, i.push({
                                index: g,
                                start: n,
                                count: e,
                                end: r
                            })
                        }, f = Math.floor(t.length / 3), d = 0, a = v = 0; f >= 0 ? f > v : v > f; a = f >= 0 ? ++v : --v) s = t[d++], h = t[d++], u = t[d++], c = Math.min(s, h, u), l = Math.max(s, h, u), r = Math.min(g, c), n = Math.max(o, l), n - r > e && (m(a), r = c, n = l, p = a), g = r, o = n;
                    return m(f), i
                }, e.prototype._chunkify = function(t, e) {
                    var r, n, i, o, a, s, h, u, l, c;
                    if (t.u16) {
                        for (n = t.array, a = t.u16, s = 0, u = e.length; u > s; s++)
                            for (r = e[s], o = r.index, i = h = l = r.start, c = r.end; c >= l ? c > h : h > c; i = c >= l ? ++h : --h) a[i] = n[i] - o;
                        return t.array = t.u16, delete t.u16
                    }
                }, e.prototype._offsets = function(t) {
                    var e, r, n, i, o, a, s, h, u, l, c, p;
                    if (this.chunked)
                        for (r = this.chunks, o = this.offsets, o.length = null, h = 0, l = t.length; l > h; h++)
                            for (i = t[h], a = i.start, n = i.count - a, u = 0, c = r.length; c > u; u++) e = r[u], p = e.start, s = e.end, (p >= a && n > p || s > a && n >= s || a > p && s > n) && (p = Math.max(a, p), s = Math.min(n, s), o.push({
                                index: e.index,
                                start: p,
                                count: s - p
                            }));
                    else this.offsets = t;
                    return null
                }, e
            }(THREE.BufferGeometry), e.exports = r
        }, {}],
        98: [function(t, e, r) {
            r.Geometry = t("./geometry"), r.ArrowGeometry = t("./arrowgeometry"), r.FaceGeometry = t("./facegeometry"), r.LineGeometry = t("./linegeometry"), r.ScreenGeometry = t("./screengeometry"), r.SpriteGeometry = t("./spritegeometry"), r.StripGeometry = t("./stripgeometry"), r.SurfaceGeometry = t("./surfacegeometry")
        }, {
            "./arrowgeometry": 95,
            "./facegeometry": 96,
            "./geometry": 97,
            "./linegeometry": 99,
            "./screengeometry": 100,
            "./spritegeometry": 101,
            "./stripgeometry": 102,
            "./surfacegeometry": 103
        }],
        99: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./geometry"), n = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.samples = m = +t.samples || 2, this.strips = E = +t.strips || 1, this.ribbons = d = +t.ribbons || 1, this.layers = u = +t.layers || 1, this.segments = g = m - 1, c = m * E * d * u * 2, f = g * E * d * u, y = 2 * f, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * y), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * c), 4)), this.addAttribute("line", new THREE.BufferAttribute(new Float32Array(2 * c), 2)), this.addAttribute("strip", new THREE.BufferAttribute(new Float32Array(2 * c), 2)), this._autochunk(), o = this._emitter("index"), p = this._emitter("position4"), l = this._emitter("line"), v = this._emitter("strip"), r = 0, i = b = 0, C = d * u; C >= 0 ? C > b : b > C; i = C >= 0 ? ++b : --b)
                        for (a = R = 0; E >= 0 ? E > R : R > E; a = E >= 0 ? ++R : --R) {
                            for (s = w = 0; g >= 0 ? g > w : w > g; s = g >= 0 ? ++w : --w) o(r), o(r + 1), o(r + 2), o(r + 2), o(r + 1), o(r + 3), r += 2;
                            r += 2
                        }
                    for (h = H = 0; u >= 0 ? u > H : H > u; h = u >= 0 ? ++H : --H)
                        for (_ = M = 0; d >= 0 ? d > M : M > d; _ = d >= 0 ? ++M : --M)
                            for (x = S = 0; E >= 0 ? E > S : S > E; x = E >= 0 ? ++S : --S)
                                for (T = A = 0; m >= 0 ? m > A : A > m; T = m >= 0 ? ++A : --A) n = 0 === T ? -1 : T === g ? 1 : 0, p(T, x, _, h), p(T, x, _, h), l(n, 1), l(n, -1), v(0, g), v(0, g);
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a, s;
                    return null == t && (t = this.samples), null == e && (e = this.strips), null == r && (r = this.ribbons), null == n && (n = this.layers), s = t - 1, this.geometryClip.set(s, e - 1, r - 1, n - 1), i = [n, r, e, s], o = [this.layers, this.ribbons, this.strips, this.segments], a = this._reduce(i, o), this._offsets([{
                        start: 0,
                        count: 6 * a
                    }])
                }, e
            }(r), e.exports = n
        }, {
            "./geometry": 97
        }],
        100: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./surfacegeometry"), r = function(t) {
                function e(t) {
                    var r, n;
                    null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryScale = {
                        type: "v4",
                        value: new THREE.Vector4
                    }, t.width = Math.max(2, null != (r = +t.width) ? r : 2), t.height = Math.max(2, null != (n = +t.height) ? n : 2), e.__super__.constructor.call(this, t)
                }
                return o(e, t), e.prototype.clip = function(t, r, n, i) {
                    var o;
                    return null == t && (t = this.width), null == r && (r = this.height), null == n && (n = this.surfaces), null == i && (i = this.layers), e.__super__.clip.call(this, t, r, n, i), o = function(t) {
                        return 1 / Math.max(1, t - 1)
                    }, this.uniforms.geometryScale.value.set(o(t), o(r), o(n), o(i))
                }, e
            }(n), e.exports = r
        }, {
            "./surfacegeometry": 103
        }],
        101: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./geometry"), n = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.items = s = +t.items || 2, this.width = g = +t.width || 1, this.height = i = +t.height || 1, this.depth = n = +t.depth || 1, p = s * g * i * n, u = 4 * p, d = 2 * p, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * d), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * u), 4)), this.addAttribute("sprite", new THREE.BufferAttribute(new Float32Array(2 * u), 2)), this._autochunk(), a = this._emitter("index"), l = this._emitter("position4"), f = this._emitter("sprite"), c = [
                            [-1, -1],
                            [-1, 1],
                            [1, -1],
                            [1, 1]
                        ], r = 0, o = T = 0; p >= 0 ? p > T : T > p; o = p >= 0 ? ++T : --T) a(r), a(r + 1), a(r + 2), a(r + 1), a(r + 2), a(r + 3), r += 4;
                    for (y = x = 0; n >= 0 ? n > x : x > n; y = n >= 0 ? ++x : --x)
                        for (E = _ = 0; i >= 0 ? i > _ : _ > i; E = i >= 0 ? ++_ : --_)
                            for (v = b = 0; g >= 0 ? g > b : b > g; v = g >= 0 ? ++b : --b)
                                for (h = w = 0; s >= 0 ? s > w : w > s; h = s >= 0 ? ++w : --w)
                                    for (H = 0, R = c.length; R > H; H++) m = c[H], l(v, E, y, h), f(m[0], m[1]);
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a;
                    return null == t && (t = this.width), null == e && (e = this.height), null == r && (r = this.depth), null == n && (n = this.items), this.geometryClip.set(t, e, r, n), i = [r, e, t, n], o = [this.depth, this.height, this.width, this.items], a = this._reduce(i, o), this._offsets([{
                        start: 0,
                        count: 6 * a
                    }])
                }, e
            }(r), e.exports = n
        }, {
            "./geometry": 97
        }],
        102: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./geometry"), n = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.items = h = +t.items || 2, this.width = y = +t.width || 1, this.height = o = +t.height || 1, this.depth = n = +t.depth || 1, this.sides = g = Math.max(0, h - 2), m = y * o * n, f = h * m, E = g * m, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * E), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * f), 4)), this.addAttribute("strip", new THREE.BufferAttribute(new Float32Array(3 * f), 3)), this._autochunk(), s = this._emitter("index"), d = this._emitter("position4"), v = this._emitter("strip"), r = 0, a = b = 0; m >= 0 ? m > b : b > m; a = m >= 0 ? ++b : --b) {
                        for (p = r, u = R = 0; g >= 0 ? g > R : R > g; u = g >= 0 ? ++R : --R) 1 & u ? (s(p + 1), s(p), s(p + 2)) : (s(p), s(p + 1), s(p + 2)), p++;
                        r += h
                    }
                    for (c = h - 1, _ = w = 0; n >= 0 ? n > w : w > n; _ = n >= 0 ? ++w : --w)
                        for (x = H = 0; o >= 0 ? o > H : H > o; x = o >= 0 ? ++H : --H)
                            for (T = M = 0; y >= 0 ? y > M : M > y; T = y >= 0 ? ++M : --M) {
                                for (i = 1, d(T, x, _, 0), v(1, 2, i), l = S = 1; c >= 1 ? c > S : S > c; l = c >= 1 ? ++S : --S) d(T, x, _, l), v(l - 1, l + 1, i = -i);
                                d(T, x, _, c), v(c - 2, c - 1, -i)
                            }
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a, s;
                    return null == t && (t = this.width), null == e && (e = this.height), null == r && (r = this.depth), null == n && (n = this.items), a = Math.max(0, n - 2), this.geometryClip.set(t, e, r, n), i = [r, e, t, a], o = [this.depth, this.height, this.width, this.sides], s = this._reduce(i, o), this._offsets([{
                        start: 0,
                        count: 3 * s
                    }])
                }, e
            }(r), e.exports = n
        }, {
            "./geometry": 97
        }],
        103: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./geometry"), n = function(t) {
                function e(t) {
                    var r, n, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S, A, C, k;
                    for (e.__super__.constructor.call(this, t), this.geometryClip = new THREE.Vector4, null == this.uniforms && (this.uniforms = {}), this.uniforms.geometryClip = {
                            type: "v4",
                            value: this.geometryClip
                        }, this.width = T = +t.width || 2, this.height = o = +t.height || 2, this.surfaces = E = +t.surfaces || 1, this.layers = c = +t.layers || 1, this.segmentsX = m = T - 1, this.segmentsY = g = o - 1, p = T * o * E * c, d = m * g * E * c, y = 2 * d, this.addAttribute("index", new THREE.BufferAttribute(new Uint16Array(3 * y), 1)), this.addAttribute("position4", new THREE.BufferAttribute(new Float32Array(4 * p), 4)), this.addAttribute("surface", new THREE.BufferAttribute(new Float32Array(2 * p), 2)), this._autochunk(), s = this._emitter("index"), f = this._emitter("position4"), v = this._emitter("surface"), r = 0, a = R = 0, k = E * c; k >= 0 ? k > R : R > k; a = k >= 0 ? ++R : --R) {
                        for (h = w = 0; g >= 0 ? g > w : w > g; h = g >= 0 ? ++w : --w) {
                            for (u = H = 0; m >= 0 ? m > H : H > m; u = m >= 0 ? ++H : --H) s(r), s(r + 1), s(r + T), s(r + T), s(r + 1), s(r + T + 1), r++;
                            r++
                        }
                        r += T
                    }
                    for (l = M = 0; c >= 0 ? c > M : M > c; l = c >= 0 ? ++M : --M)
                        for (b = S = 0; E >= 0 ? E > S : S > E; b = E >= 0 ? ++S : --S)
                            for (_ = A = 0; o >= 0 ? o > A : A > o; _ = o >= 0 ? ++A : --A)
                                for (i = 0 === _ ? -1 : _ === g ? 1 : 0, x = C = 0; T >= 0 ? T > C : C > T; x = T >= 0 ? ++C : --C) n = 0 === x ? -1 : x === m ? 1 : 0, f(x, _, b, l), v(n, i);
                    this._finalize(), this.clip()
                }
                return o(e, t), e.prototype.clip = function(t, e, r, n) {
                    var i, o, a, s, h;
                    return null == t && (t = this.width), null == e && (e = this.height), null == r && (r = this.surfaces), null == n && (n = this.layers), s = Math.max(0, t - 1), h = Math.max(0, e - 1), this.geometryClip.set(s, h, r, n), i = [n, r, h, s], o = [this.layers, this.surfaces, this.segmentsY, this.segmentsX], a = this._reduce(i, o), this._offsets([{
                        start: 0,
                        count: 6 * a
                    }])
                }, e
            }(r), e.exports = n
        }, {
            "./geometry": 97
        }],
        104: [function(t, e, r) {
            r.Scene = t("./scene"), r.Factory = t("./factory"), r.Renderable = t("./scene"), r.Classes = t("./classes")
        }, {
            "./classes": 93,
            "./factory": 94,
            "./scene": 115
        }],
        105: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            i = t("./base"), n = t("../geometry").ArrowGeometry, r = function(t) {
                function e(t, r, i) {
                    var o, a, s, h, u, l, c, p;
                    e.__super__.constructor.call(this, t, r, i), l = null != (p = i.uniforms) ? p : {}, u = i.position, o = i.color, this.geometry = new n({
                        sides: i.sides,
                        samples: i.samples,
                        strips: i.strips,
                        ribbons: i.ribbons,
                        layers: i.layers,
                        anchor: i.anchor,
                        flip: i.flip
                    }), this._adopt(l), this._adopt(this.geometry.uniforms), s = r.material(), c = s.vertex, o && (c.require(o), c.pipe("mesh.vertex.color", this.uniforms)), u && c.require(u), c.pipe("arrow.position", this.uniforms), c.pipe("project.position", this.uniforms), a = s.fragment, a.pipe("style.color", this.uniforms), o && a.pipe("mesh.fragment.color", this.uniforms), a.pipe("fragment.color", this.uniforms), this.material = new THREE.ShaderMaterial(s.link({
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), h = new THREE.Mesh(this.geometry, this.material), h.frustumCulled = !1, h.matrixAutoUpdate = !1, this._raw(h), this.objects = [h]
                }
                return a(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(i), e.exports = r
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        106: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("../renderable"), r = function(t) {
                function e(t, r, n) {
                    var i;
                    e.__super__.constructor.call(this, t, r, n), this.zUnits = null != (i = n.zUnits) ? i : 0
                }
                return o(e, t), e.prototype.raw = function() {
                    var t, e, r, n;
                    for (n = this.objects, e = 0, r = n.length; r > e; e++) t = n[e], this._raw(t);
                    return null
                }, e.prototype.depth = function(t, e) {
                    var r, n, i, o;
                    for (o = this.objects, n = 0, i = o.length; i > n; n++) r = o[n], this._depth(r, t, e);
                    return null
                }, e.prototype.polygonOffset = function(t, e) {
                    var r, n, i, o;
                    for (o = this.objects, n = 0, i = o.length; i > n; n++) r = o[n], this._polygonOffset(r, t, e);
                    return null
                }, e.prototype.show = function(t, e, r) {
                    var n, i, o, a, s;
                    for (a = this.objects, s = [], i = 0, o = a.length; o > i; i++) n = a[i], s.push(this._show(n, t, e, r));
                    return s
                }, e.prototype.hide = function() {
                    var t, e, r, n;
                    for (n = this.objects, e = 0, r = n.length; r > e; e++) t = n[e], this._hide(t);
                    return null
                }, e.prototype._raw = function(t) {
                    return t.rotationAutoUpdate = !1, t.frustumCulled = !1, t.matrixAutoUpdate = !1
                }, e.prototype._depth = function(t, e, r) {
                    var n;
                    return n = t.material, n.depthWrite = e, n.depthTest = r
                }, e.prototype._polygonOffset = function(t, e, r) {
                    var n, i;
                    return r -= this.zUnits, n = 0 !== r, i = t.material, i.polygonOffset = n, n ? (i.polygonOffsetFactor = e, i.polygonOffsetUnits = r) : void 0
                }, e.prototype._show = function(t, e, r, n) {
                    var i, o;
                    return r > THREE.NormalBlending && (e = !0), o = e ? n : -n, i = t.material, t.renderDepth = o, t.visible = !0, i.transparent = e, i.blending = r, null
                }, e.prototype._hide = function(t) {
                    return t.visible = !1
                }, e
            }(n), e.exports = r
        }, {
            "../renderable": 114
        }],
        107: [function(t, e) {
            var r, n, i = {}.hasOwnProperty,
                o = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) i.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), n = function(t) {
                function e(t, r, n) {
                    var i;
                    e.__super__.constructor.call(this, t, r, n), this.geometry = new THREE.PlaneGeometry(1, 1), this.material = new THREE.MeshBasicMaterial({
                        map: n.map
                    }), this.material.side = THREE.DoubleSide, i = new THREE.Mesh(this.geometry, this.material), i.position.x += n.x || 0, i.position.y += n.y || 0, i.frustumCulled = !1, i.scale.set(2, 2, 2), i.__debug = !0, this.objects = [i]
                }
                return o(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "./base": 106
        }],
        108: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").FaceGeometry, n = function(t) {
                function e(t, r, n) {
                    var o, a, s, h, u, l, c, p, f, d;
                    e.__super__.constructor.call(this, t, r, n), c = null != (f = n.uniforms) ? f : {}, u = n.position, l = null != (d = n.shaded) ? d : !0, o = n.color, this.geometry = new i({
                        items: n.items,
                        width: n.width,
                        height: n.height,
                        depth: n.depth
                    }), this._adopt(c), this._adopt(this.geometry.uniforms), s = r.material(), p = s.vertex, o && (p.require(o), p.pipe("mesh.vertex.color", this.uniforms)), u && p.require(u), p.split(), l || p.pipe("face.position", this.uniforms), l && p.pipe("face.position.normal", this.uniforms), p.pass(), p.pipe("project.position", this.uniforms), a = s.fragment, l || a.pipe("style.color", this.uniforms), l && a.pipe("style.color.shaded", this.uniforms), o && a.pipe("mesh.fragment.color", this.uniforms), a.pipe("fragment.color", this.uniforms), this.material = new THREE.ShaderMaterial(s.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), h = new THREE.Mesh(this.geometry, this.material), this._raw(h), this.objects = [h]
                }
                return a(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        109: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").LineGeometry, n = function(t) {
                function e(t, r, n) {
                    var o, a, s, h, u, l, c, p, f, d, m;
                    e.__super__.constructor.call(this, t, r, n), f = null != (m = n.uniforms) ? m : {}, c = n.position, a = n.color, o = n.clip, p = n.stroke, p = [null, "dotted", "dashed"][p], this.geometry = new i({
                        samples: n.samples,
                        strips: n.strips,
                        ribbons: n.ribbons,
                        layers: n.layers,
                        anchor: n.anchor
                    }), this._adopt(f), this._adopt(this.geometry.uniforms), u = r.material(), s = p ? {
                        LINE_STROKE: ""
                    } : {}, d = u.vertex, a && (d.require(a), d.pipe("mesh.vertex.color", this.uniforms)), c && d.require(c), d.split(), d.pipe("line.position", this.uniforms, s), d.pass(), d.fan(), o && d.pipe("line.clip.ends", this.uniforms), d.next(), d.pipe("project.position", this.uniforms), d.join(), h = u.fragment, p && h.pipe("fragment.clip." + p, this.uniforms), o && h.pipe("fragment.clip.ends", this.uniforms), h.pipe("style.color", this.uniforms), a && h.pipe("mesh.fragment.color", this.uniforms), h.pipe("fragment.color", this.uniforms), this.material = new THREE.ShaderMaterial(u.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), l = new THREE.Mesh(this.geometry, this.material), this._raw(l), this.objects = [l]
                }
                return a(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        110: [function(t, e) {
            var r, n, i, o, a = {}.hasOwnProperty,
                s = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) a.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").ScreenGeometry, o = t("../../util"), n = function(t) {
                function e(t, r, n) {
                    var a, s, h, u, l, c, p, f;
                    e.__super__.constructor.call(this, t, r, n), c = null != (f = n.uniforms) ? f : {}, h = n.fragment, u = null != c.styleColor, this.geometry = new i({
                        width: n.width,
                        height: n.height
                    }), this._adopt(c), this._adopt(this.geometry.uniforms), s = r.material(), p = s.vertex, p.pipe("raw.position.scale", this.uniforms), p.fan(), p.pipe("stpq.xyzw.2d", this.uniforms), p.next(), p.pipe("screen.position", this.uniforms), p.join(), a = s.fragment, a.require(n.fragment), a.pipe("stpq.sample.2d"), u && (a.pipe("style.color", this.uniforms), a.pipe(o.GLSL.binaryOperator("vec4", "*"))), a.pipe("fragment.color"), this.material = new THREE.ShaderMaterial(s.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), l = new THREE.Mesh(this.geometry, this.material), this._raw(l), this.objects = [l]
                }
                return s(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../../util": 127,
            "../geometry": 98,
            "./base": 106
        }],
        111: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").SpriteGeometry, n = function(t) {
                function e(t, r, n) {
                    var o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b;
                    e.__super__.constructor.call(this, t, r, n), v = null != (y = n.uniforms) ? y : {}, d = n.position, a = n.color, m = null != (T = +n.shape) ? T : 0, u = null != (x = n.fill) ? x : !0, g = ["circle", "square", "diamond", "triangle"], f = ["circle", "generic", "generic", "generic"], c = null != (_ = g[m]) ? _ : g[0], p = null != (b = f[m]) ? b : f[0], o = u ? p : "" + p + ".hollow", this.geometry = new i({
                        items: n.items,
                        width: n.width,
                        height: n.height,
                        depth: n.depth
                    }), this._adopt(v), this._adopt(this.geometry.uniforms), E = r.shader(), a && (E.require(a), E.pipe("mesh.vertex.color", this.uniforms)), d && E.require(d), E.pipe("sprite.position", this.uniforms), E.pipe("project.position", this.uniforms), s = r.material(), s.vertex.pipe(E), h = s.fragment, h.pipe("style.color", this.uniforms), a && h.pipe("mesh.fragment.color", this.uniforms), h.require("sprite.mask." + c, this.uniforms), h.require("sprite.alpha." + o, this.uniforms), h.pipe("sprite.edge", this.uniforms), l = r.material(), l.vertex.pipe(E), h = l.fragment, h.pipe("style.color", this.uniforms), a && h.pipe("mesh.fragment.color", this.uniforms), h.require("sprite.mask." + c, this.uniforms), h.require("sprite.alpha." + o, this.uniforms), h.pipe("sprite.fill", this.uniforms), this.edgeMaterial = new THREE.ShaderMaterial(s.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), this.fillMaterial = new THREE.ShaderMaterial(l.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), this.edgeObject = new THREE.Mesh(this.geometry, this.edgeMaterial), this.fillObject = new THREE.Mesh(this.geometry, this.fillMaterial), this._raw(this.edgeObject), this._raw(this.fillObject), this.objects = [this.edgeObject, this.fillObject]
                }
                return a(e, t), e.prototype.show = function(t, e, r, n) {
                    return this._show(this.edgeObject, !0, e, r, n), this._show(this.fillObject, t, e, r, n)
                }, e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.edgeMaterial.dispose(), this.fillMaterial.dispose(), this.objects = this.edgeObject = this.fillObject = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        112: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").StripGeometry, n = function(t) {
                function e(t, r, n) {
                    var o, a, s, h, u, l, c, p, f, d;
                    e.__super__.constructor.call(this, t, r, n), c = null != (f = n.uniforms) ? f : {}, u = n.position, l = null != (d = n.shaded) ? d : !0, o = n.color, this.geometry = new i({
                        items: n.items,
                        width: n.width,
                        height: n.height,
                        depth: n.depth
                    }), this._adopt(c), this._adopt(this.geometry.uniforms), s = r.material(), p = s.vertex, o && (p.require(o), p.pipe("mesh.vertex.color", this.uniforms)), u && p.require(u), p.split(), l || p.pipe("mesh.position", this.uniforms), l && p.pipe("strip.position.normal", this.uniforms), p.pass(), p.pipe("project.position", this.uniforms), a = s.fragment, l || a.pipe("style.color", this.uniforms), l && a.pipe("style.color.shaded", this.uniforms), o && a.pipe("mesh.fragment.color", this.uniforms), a.pipe("fragment.color", this.uniforms), this.material = new THREE.ShaderMaterial(s.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), h = new THREE.Mesh(this.geometry, this.material), this._raw(h), this.objects = [h]
                }
                return a(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        113: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            r = t("./base"), i = t("../geometry").SurfaceGeometry, n = function(t) {
                function e(t, r, n) {
                    var o, a, s, h, u, l, c, p, f, d;
                    e.__super__.constructor.call(this, t, r, n), c = null != (f = n.uniforms) ? f : {}, u = n.position, o = n.color, l = null != (d = n.shaded) ? d : !0, this.geometry = new i({
                        width: n.width,
                        height: n.height,
                        surfaces: n.surfaces,
                        layers: n.layers
                    }), this._adopt(c), this._adopt(this.geometry.uniforms), s = r.material(), p = s.vertex, o && (p.require(o), p.pipe("mesh.vertex.color", this.uniforms)), u && p.require(u), l || p.pipe("surface.position", this.uniforms), l && p.pipe("surface.position.normal", this.uniforms), p.pipe("project.position", this.uniforms), a = s.fragment, l || a.pipe("style.color", this.uniforms), l && a.pipe("style.color.shaded", this.uniforms), o && a.pipe("mesh.fragment.color", this.uniforms), a.pipe("fragment.color", this.uniforms), this.material = new THREE.ShaderMaterial(s.link({
                        side: THREE.DoubleSide,
                        defaultAttributeValues: null,
                        index0AttributeName: "position4"
                    })), h = new THREE.Mesh(this.geometry, this.material), this._raw(h), this.objects = [h]
                }
                return a(e, t), e.prototype.dispose = function() {
                    return this.geometry.dispose(), this.material.dispose(), this.objects = this.geometry = this.material = null, e.__super__.dispose.apply(this, arguments)
                }, e
            }(r), e.exports = n
        }, {
            "../geometry": 98,
            "./base": 106
        }],
        114: [function(t, e) {
            var r;
            r = function() {
                function t(t, e) {
                    this.renderer = t, this.shaders = e, this.gl = this.renderer.context, null == this.uniforms && (this.uniforms = {})
                }
                return t.prototype.dispose = function() {
                    return this.uniforms = null
                }, t.prototype._adopt = function(t) {
                    var e, r;
                    for (e in t) r = t[e], this.uniforms[e] = r
                }, t.prototype._set = function(t) {
                    var e, r;
                    for (e in t) r = t[e], null != this.uniforms[e] && (this.uniforms[e].value = r)
                }, t
            }(), e.exports = r
        }, {}],
        115: [function(t, e) {
            var r, n, i, o = {}.hasOwnProperty,
                a = function(t, e) {
                    function r() {
                        this.constructor = t
                    }
                    for (var n in e) o.call(e, n) && (t[n] = e[n]);
                    return r.prototype = e.prototype, t.prototype = new r, t.__super__ = e.prototype, t
                };
            n = t("./renderable"), r = function(t) {
                function e() {
                    e.__super__.constructor.apply(this, arguments), this.rotationAutoUpdate = !1, this.frustumCulled = !1, this.matrixAutoUpdate = !1
                }
                return a(e, t), e
            }(THREE.Object3D), i = function(t) {
                function e(t, n, i) {
                    e.__super__.constructor.call(this, t, n, i), this.root = new r, null != (null != i ? i.scene : void 0) && (this.scene = i.scene), null == this.scene && (this.scene = new THREE.Scene)
                }
                return a(e, t), e.prototype.inject = function(t) {
                    return null != t && (this.scene = t), this.scene.add(this.root)
                }, e.prototype.unject = function() {
                    var t;
                    return null != (t = this.scene) ? t.remove(this.root) : void 0
                }, e.prototype.add = function(t) {
                    return this.root.add(t)
                }, e.prototype.remove = function(t) {
                    return this.root.remove(t)
                }, e.prototype.dispose = function() {
                    return null != this.root.parent ? this.unject() : void 0
                }, e
            }(n), e.exports = i
        }, {
            "./renderable": 114
        }],
        116: [function(t, e) {
            var r;
            r = function(t) {
                var e;
                return e = function(e) {
                    var r, n;
                    if (n = t[e], null != n) return n;
                    if (r = document.getElementById(e), null != r && "SCRIPT" === r.tagName) return r.textContent || r.innerText;
                    throw "Unknown shader `" + e + "`"
                }, new ShaderGraph(e)
            }, e.exports = r
        }, {}],
        117: [function(t, e, r) {
            r.Factory = t("./factory"), r.Snippets = MathBox.Shaders
        }, {
            "./factory": 116
        }],
        118: [function(t, e) {
            var r;
            r = function() {
                function t(t) {
                    this.model = t
                }
                return t.prototype.update = function() {}, t
            }(), e.exports = r
        }, {}],
        119: [function(t, e) {
            var r;
            r = function() {
                function t(t, e, r) {
                    var n, i, o, a, s, h, u, l, c, p;
                    for (this._context = t, this._up = e, this._targets = r, i = this._context.controller.getRoot(), null == this._targets && (this._targets = [i]), this.isRoot = 1 === this._targets.length && this._targets[0] === i, this.isLeaf = 1 === this._targets.length && null == this._targets[0].children, c = this._targets, n = s = 0, u = c.length; u > s; n = ++s) o = c[n], this[n] = o;
                    for (this.length = this._targets.length, p = this._context.controller.getTypes(), h = 0, l = p.length; l > h; h++) a = p[h], "root" !== a && ! function(t) {
                        return function(e) {
                            return t[e] = function(r) {
                                return t.add(e, r)
                            }
                        }
                    }(this)(a)
                }
                return t.prototype.each = function(t) {
                    var e, r, n;
                    for (e = r = 0, n = this.length; n >= 0 ? n > r : r > n; e = n >= 0 ? ++r : --r) t(this[e], e, this);
                    return this
                }, t.prototype.select = function(t) {
                    var e;
                    return e = this._context.model.select(t, this.isRoot ? null : _targets), this.push(e)
                }, t.prototype.add = function(t, e) {
                    var r, n, i, o, a, s, h;
                    if (r = this._context.controller, this.isLeaf) return this.pop().add(t, e);
                    for (i = [], h = this._targets, a = 0, s = h.length; s > a; a++) o = h[a], n = r.make(t, e), r.add(n, o), i.push(n);
                    return this.push(i)
                }, t.prototype.remove = function(t) {
                    var e, r, n, i, o;
                    if (t) return this.select(t).remove();
                    for (i = this._targets, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this._context.controller.remove(e));
                    return o
                }, t.prototype.set = function(t, e) {
                    var r, n, i, o;
                    for (o = this._targets, n = 0, i = o.length; i > n; n++) r = o[n], this._context.controller.set(r, t, e);
                    return this
                }, t.prototype.get = function(t) {
                    var e, r, n, i, o;
                    if (t) return this.select(t).get();
                    for (i = this._targets, o = [], r = 0, n = i.length; n > r; r++) e = i[r], o.push(this._context.controller.get(e));
                    return o
                }, t.prototype.push = function(e) {
                    return new t(this._context, this, e)
                }, t.prototype.pop = function() {
                    var t;
                    return null != (t = this._up) ? t : this
                }, t.prototype.reset = function() {
                    var t, e;
                    return null != (t = null != (e = this._up) ? e.reset() : void 0) ? t : this
                }, t.prototype.end = function() {
                    return (this.isLeaf ? this.pop() : this).pop()
                }, t
            }(), e.exports = r
        }, {}],
        120: [function(t, e) {
            var r;
            r = function() {
                function t(t, e) {
                    this.model = t, this.factory = e
                }
                return t.prototype._name = function(t) {
                    var e;
                    return e = t.type, t.id && (e += "#" + t.id), t.classes.length && (e += "." + t.classes.join(".")), "[" + e + "]"
                }, t.prototype.getRoot = function() {
                    return this.model.getRoot()
                }, t.prototype.getTypes = function() {
                    return this.factory.getTypes()
                }, t.prototype.make = function(t, e) {
                    return this.factory.make(t, e)
                }, t.prototype.get = function(t) {
                    return t.get()
                }, t.prototype.set = function(t, e, r) {
                    var n;
                    try {
                        return t.set(e, r)
                    } catch (i) {
                        return n = i, console.warn(this._name(t), n)
                    }
                }, t.prototype.add = function(t, e) {
                    return null == e && (e = this.model.getRoot()), e.add(t)
                }, t.prototype.remove = function(t) {
                    var e;
                    return e = t.parent, e ? e.remove(t) : void 0
                }, t
            }(), e.exports = r
        }, {}],
        121: [function(t, e) {
            var r;
            r = function() {
                function t(t, e) {
                    this.model = t, this.script = e
                }
                return t
            }(), e.exports = r
        }, {}],
        122: [function(t, e, r) {
            r.Animator = t("./animator"), r.API = t("./api"), r.Controller = t("./controller"), r.Director = t("./director")
        }, {
            "./animator": 118,
            "./api": 119,
            "./controller": 120,
            "./director": 121
        }],
        123: [function(t, e, r) {
            r.setDimension = function(t, e) {
                var r, n, i, o;
                return n = 1 === e ? 1 : 0, i = 2 === e ? 1 : 0, o = 3 === e ? 1 : 0, r = 4 === e ? 1 : 0, t.set(n, i, o, r)
            }, r.setDimensionNormal = function(t, e) {
                var r, n, i, o;
                return n = 1 === e ? 1 : 0, i = 2 === e ? 1 : 0, o = 3 === e ? 1 : 0, r = 4 === e ? 1 : 0, t.set(i, o + n, r, 0)
            }, r.recenterAxis = function() {
                var t;
                return t = [0, 0],
                    function(e, r, n, i) {
                        var o, a, s, h, u, l;
                        return null == i && (i = 0), n > 0 && (u = e, l = e + r, o = Math.max(Math.abs(u), Math.abs(l)), a = o * i, h = Math.min(u, l), s = Math.max(u, l), e = h + (-o + a - h) * n, r = s + (o + a - s) * n - e), t[0] = e, t[1] = r, t
                    }
            }()
        }, {}],
        124: [function(t, e, r) {
            var n;
            r.getSizes = n = function(t) {
                var e, r;
                for (r = [], e = t; null != (null != e ? e.length : void 0);) r.push(e.length), e = e[0];
                return r
            }, r.getDimensions = function(t, e) {
                var r, i, o, a, s, h, u, l, c, p, f, d, m, g, v;
                return null == e && (e = {}), s = e.items, r = e.channels, p = e.width, a = e.height, i = e.depth, o = {}, t && t.length ? (c = n(t), l = c.length, o.channels = 1 !== r && c.length > 1 ? c.pop() : r, o.items = 1 !== s && c.length > 1 ? c.pop() : s, o.width = 1 !== p && c.length > 1 ? c.pop() : p, o.height = 1 !== a && c.length > 1 ? c.pop() : a, o.depth = 1 !== i && c.length > 1 ? c.pop() : i, h = l, 1 === r && h++, 1 === s && h > 1 && h++, 1 === p && h > 2 && h++, 1 === a && h > 3 && h++, u = null != (f = c.pop()) ? f : 1, 1 >= h && (u /= null != (d = o.channels) ? d : 1), 2 >= h && (u /= null != (m = o.items) ? m : 1), 3 >= h && (u /= null != (g = o.width) ? g : 1), 4 >= h && (u /= null != (v = o.height) ? v : 1), u = Math.floor(u), null == o.width && (o.width = u, u = 1), null == o.height && (o.height = u, u = 1), null == o.depth && (o.depth = u, u = 1), o) : {
                    items: s,
                    channels: r,
                    width: null != p ? p : 0,
                    height: null != a ? a : 0,
                    depth: null != i ? i : 0
                }
            }, r.makeEmitter = function(t, e, r, n) {
                var i, o, a;
                return i = function() {
                    switch (r) {
                        case 0:
                            return function() {
                                return !0
                            };
                        case 1:
                            return function(e) {
                                return e(t())
                            };
                        case 2:
                            return function(e) {
                                return e(t(), t())
                            };
                        case 3:
                            return function(e) {
                                return e(t(), t(), t())
                            };
                        case 4:
                            return function(e) {
                                return e(t(), t(), t(), t())
                            }
                    }
                }(), o = function() {
                    switch (e) {
                        case 0:
                            return function() {
                                return !0
                            };
                        case 1:
                            return function(t) {
                                return i(t)
                            };
                        case 2:
                            return function(t) {
                                return i(t), i(t)
                            };
                        case 3:
                            return function(t) {
                                return i(t), i(t), i(t)
                            };
                        case 4:
                            return function(t) {
                                return i(t), i(t), i(t), i(t)
                            }
                    }
                }(), a = function() {
                    switch (n) {
                        case 1:
                            return function(t, e) {
                                return o(e)
                            };
                        case 2:
                            return function(t, e, r) {
                                return o(r)
                            };
                        case 3:
                            return function(t, e, r, n) {
                                return o(n)
                            };
                        case 4:
                            return function(t, e, r, n, i) {
                                return o(i)
                            }
                    }
                }(), a.reset = t.reset, a.rebind = t.rebind, a
            }, r.getThunk = function(t) {
                var e, r, i, o, a, s, h, u, l, c, p, f, d, m, g, v, E, y, T, x, _, b, R, w, H, M, S;
                switch (g = n(t), d = g.length, e = g.pop(), r = g.pop(), i = g.pop(), o = g.pop(), a = !1, d) {
                    case 0:
                        E = function() {}, E.reset = function() {};
                        break;
                    case 1:
                        u = 0, E = function() {
                            return t[u++]
                        }, E.reset = function() {
                            return u = 0
                        };
                        break;
                    case 2:
                        u = l = 0, s = null != (y = t[l]) ? y : [], E = function() {
                            var r, n, i;
                            return r = s[u++], u === e && (n = [0, l + 1], u = n[0], l = n[1], s = null != (i = t[l]) ? i : []), r
                        }, E.reset = function() {
                            return u = l = 0
                        };
                        break;
                    case 3:
                        u = l = c = 0, m = null != (T = t[c]) ? T : [], s = null != (x = m[l]) ? x : [], E = function() {
                            var n, i, o, a, h;
                            return n = s[u++], u === e && (i = [0, l + 1], u = i[0], l = i[1], l === r && (o = [0, c + 1], l = o[0], c = o[1], m = null != (a = t[c]) ? a : []), s = null != (h = m[l]) ? h : []), n
                        }, E.reset = function() {
                            return u = l = c = 0
                        };
                        break;
                    case 4:
                        u = l = c = p = 0, v = null != (_ = t[p]) ? _ : [], m = null != (b = v[c]) ? b : [], s = null != (R = m[l]) ? R : [], E = function() {
                            var n, o, a, h, f, d, g;
                            return n = s[u++], u === e && (h = [0, l + 1], u = h[0], l = h[1], l === r && (f = [0, c + 1], l = f[0], c = f[1], c === i && (d = [0, p + 1], c = d[0], p = d[1], v = null != (g = t[p]) ? g : []), m = null != (o = v[c]) ? o : []), s = null != (a = m[l]) ? a : []), n
                        }, E.reset = function() {
                            return u = l = c = p = 0
                        };
                        break;
                    case 5:
                        u = l = c = p = f = 0, h = null != (w = t[f]) ? w : [], v = null != (H = h[p]) ? H : [], m = null != (M = v[c]) ? M : [], s = null != (S = m[l]) ? S : [], E = function() {
                            var n, a, d, g, E, y, T, x, _;
                            return n = s[u++], u === e && (a = [0, l + 1], u = a[0], l = a[1], l === r && (d = [0, c + 1], l = d[0], c = d[1], c === i && (g = [0, p + 1], c = g[0], p = g[1], p === o && (E = [0, f + 1], p = E[0], f = E[1], h = null != (y = t[f]) ? y : []), v = null != (T = h[p]) ? T : []), m = null != (x = v[c]) ? x : []), s = null != (_ = m[l]) ? _ : []), n
                        }, E.reset = function() {
                            return u = l = c = p = f = 0
                        }
                }
                return E.rebind = function(o) {
                    return t = o, g = n(t), g.length && (e = g.pop()), g.length && (r = g.pop()), g.length && (i = g.pop()), g.length ? o = g.pop() : void 0
                }, E
            }
        }, {}],
        125: [function(t, e) {
            var r;
            r = {
                cosine: function(t) {
                    return .5 - .5 * Math.cos(t * π)
                }
            }, e.exports = r
        }, {}],
        126: [function(t, e, r) {
            var n, i, o, a = [].indexOf || function(t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t) return e;
                return -1
            };
            i = "xyzw".split(""), n = {
                0: -1,
                x: 0,
                y: 1,
                z: 2,
                w: 3
            }, o = function(t) {
                return t === "" + t && (t = t.split("")), t === +t && (t = [t]), t
            }, r.sample2DArray = function(t) {
                var e, r;
                return r = function(t, e) {
                    var n, i;
                    return t === e ? i = "return texture2D(dataTextures[" + t + "], uv);" : (n = Math.ceil(t + (e - t) / 2), i = "if (z < " + (n - .5) + ") {\n  " + r(t, n - 1) + "\n}\nelse {\n  " + r(n, e) + "\n}"), i = i.replace(/\n/g, "\n  ")
                }, e = r(0, t - 1), "uniform sampler2D dataTextures[" + t + "];\n\nvec4 sample2DArray(vec2 uv, float z) {\n  " + e + "\n}"
            }, r.binaryOperator = function(t, e) {
                return "" + t + " binaryOperator(" + t + " a, " + t + " b) {\n  return a " + e + " b;\n}"
            }, r.extendVec = function(t, e) {
                var r, n, i, o;
                return n = e - t, t = "vec" + t, e = "vec" + e, "vec1" === t && (t = "float"), "vec1" === e && (e = "float"), i = function() {
                    o = [];
                    for (var t = 0; n >= 0 ? n >= t : t >= n; n >= 0 ? t++ : t--) o.push(t);
                    return o
                }.apply(this).map(function(t) {
                    return t ? "0.0" : "v"
                }), r = i.join(","), "" + e + " extendVec(" + t + " v) { return " + e + "(" + r + "); }"
            }, r.truncateVec = function(t, e) {
                var r;
                return r = "." + "xyzw".substr(0, e), t = "vec" + t, e = "vec" + e, "vec1" === e && (e = "float"), "" + e + " truncateVec(" + t + " v) { return v" + r + "; }"
            }, r.injectVec4 = function(t) {
                var e, r, i, a, s, h, u;
                for (s = ["0.0", "0.0", "0.0", "0.0"], t = o(t), t = t.map(function(t) {
                        return t === "" + t ? n[t] : t
                    }), i = h = 0, u = t.length; u > h; i = ++h) r = t[i], s[r] = ["a", "b", "c", "d"][i];
                return a = s.slice(0, 4).join(", "), e = ["float a", "float b", "float c", "float d"].slice(0, t.length), "vec4 inject(" + e + ") {\n  return vec4(" + a + ");\n}"
            }, r.swizzleVec4 = function(t, e) {
                var r, i;
                for (null == e && (e = null), r = ["0.0", "xyzw.x", "xyzw.y", "xyzw.z", "xyzw.w"], null == e && (e = t.length), t = o(t), t = t.map(function(t) {
                        return a.call([0, 1, 2, 3, 4], +t) >= 0 && (t = +t), t === "" + t && (t = n[t] + 1), r[t]
                    }); t.length < e;) t.push("0.0");
                return i = t.join(", "), ("vec" + e + " swizzle(vec4 xyzw) {\n  return vec" + e + "(" + i + ");\n}").replace(/vec1/g, "float")
            }, r.invertSwizzleVec4 = function(t) {
                var e, r, a, s, h, u, l, c;
                for (u = ["0.0", "0.0", "0.0", "0.0"], t = o(t), t = t.map(function(t) {
                        return t === +t ? i[t - 1] : t
                    }), e = l = 0, c = t.length; c > l; e = ++l) a = t[e], h = i[e], r = n[a], u[r] = "xyzw." + h;
                return s = u.join(", "), "vec4 invertSwizzle(vec4 xyzw) {\n  return vec4(" + s + ");\n}"
            }
        }, {}],
        127: [function(t, e, r) {
            r.Data = t("./data"), r.Ticks = t("./ticks"), r.Ease = t("./ease"), r.GLSL = t("./glsl"), r.Axis = t("./axis"), r.JS = t("./js"), r.Three = t("./three")
        }, {
            "./axis": 123,
            "./data": 124,
            "./ease": 125,
            "./glsl": 126,
            "./js": 128,
            "./three": 129,
            "./ticks": 130
        }],
        128: [function(t, e, r) {
            r.merge = function() {
                var t, e, r, n, i, o;
                for (n = {}, i = 0, o = arguments.length; o > i; i++) {
                    e = arguments[i];
                    for (t in e) r = e[t], n[t] = r
                }
                return n
            }, r.clone = function(t) {
                return JSON.parse(JSON.serialize(t))
            }
        }, {}],
        129: [function(t, e, r) {
            r.paramToGL = function(t, e) {
                return e === THREE.RepeatWrapping ? t.REPEAT : e === THREE.ClampToEdgeWrapping ? t.CLAMP_TO_EDGE : e === THREE.MirroredRepeatWrapping ? t.MIRRORED_REPEAT : e === THREE.NearestFilter ? t.NEAREST : e === THREE.NearestMipMapNearestFilter ? t.NEAREST_MIPMAP_NEAREST : e === THREE.NearestMipMapLinearFilter ? t.NEAREST_MIPMAP_LINEAR : e === THREE.LinearFilter ? t.LINEAR : e === THREE.LinearMipMapNearestFilter ? t.LINEAR_MIPMAP_NEAREST : e === THREE.LinearMipMapLinearFilter ? t.LINEAR_MIPMAP_LINEAR : e === THREE.UnsignedByteType ? t.UNSIGNED_BYTE : e === THREE.UnsignedShort4444Type ? t.UNSIGNED_SHORT_4_4_4_4 : e === THREE.UnsignedShort5551Type ? t.UNSIGNED_SHORT_5_5_5_1 : e === THREE.UnsignedShort565Type ? t.UNSIGNED_SHORT_5_6_5 : e === THREE.ByteType ? t.BYTE : e === THREE.ShortType ? t.SHORT : e === THREE.UnsignedShortType ? t.UNSIGNED_SHORT : e === THREE.IntType ? t.INT : e === THREE.UnsignedIntType ? t.UNSIGNED_INT : e === THREE.FloatType ? t.FLOAT : e === THREE.AlphaFormat ? t.ALPHA : e === THREE.RGBFormat ? t.RGB : e === THREE.RGBAFormat ? t.RGBA : e === THREE.LuminanceFormat ? t.LUMINANCE : e === THREE.LuminanceAlphaFormat ? t.LUMINANCE_ALPHA : e === THREE.AddEquation ? t.FUNC_ADD : e === THREE.SubtractEquation ? t.FUNC_SUBTRACT : e === THREE.ReverseSubtractEquation ? t.FUNC_REVERSE_SUBTRACT : e === THREE.ZeroFactor ? t.ZERO : e === THREE.OneFactor ? t.ONE : e === THREE.SrcColorFactor ? t.SRC_COLOR : e === THREE.OneMinusSrcColorFactor ? t.ONE_MINUS_SRC_COLOR : e === THREE.SrcAlphaFactor ? t.SRC_ALPHA : e === THREE.OneMinusSrcAlphaFactor ? t.ONE_MINUS_SRC_ALPHA : e === THREE.DstAlphaFactor ? t.DST_ALPHA : e === THREE.OneMinusDstAlphaFactor ? t.ONE_MINUS_DST_ALPHA : e === THREE.DstColorFactor ? t.DST_COLOR : e === THREE.OneMinusDstColorFactor ? t.ONE_MINUS_DST_COLOR : e === THREE.SrcAlphaSaturateFactor ? t.SRC_ALPHA_SATURATE : 0
            }, r.paramToArrayStorage = function(t) {
                switch (t) {
                    case THREE.UnsignedByteType:
                        return Uint8Array;
                    case THREE.ByteType:
                        return Int8Array;
                    case THREE.ShortType:
                        return Int16Array;
                    case THREE.UnsignedShortType:
                        return Uint16Array;
                    case THREE.IntType:
                        return Int32Array;
                    case THREE.UnsignedIntType:
                        return Uint32Array;
                    case THREE.FloatType:
                        return Float32Array
                }
            }
        }, {}],
        130: [function(t, e, r) {
            var n, i, o, a, s;
            o = function(t, e, r, n, i, o, a) {
                var s, h, u, l, c, p, f, d, m, g, v, E;
                for (r || (r = 10), a || (a = 0), d = e - t, p = d / r, n || (n = 1), i || (i = 10), f = n * (a + Math.pow(i, Math.floor(Math.log(p / n) / Math.log(i)))), l = i % 2 === 0 ? [i / 2, 1, .5] : i % 3 === 0 ? [i / 3, 1, 1 / 3] : [1], g = function() {
                        var t, e, r;
                        for (r = [], t = 0, e = l.length; e > t; t++) u = l[t], r.push(f * u);
                        return r
                    }(), s = 1 / 0, m = g.reduce(function(t, e) {
                        var r, n;
                        return n = e / p, r = Math.max(n, 1 / n), s > r ? (s = r, e) : t
                    }, f), h = +!o, t = (Math.ceil(t / m) + h) * m, e = (Math.floor(e / m) - h) * m, r = Math.ceil((e - t) / m), E = [], c = v = 0; r >= 0 ? r >= v : v >= r; c = r >= 0 ? ++v : --v) E.push(t + c * m);
                return E
            }, a = function() {
                throw "Log ticks not yet implemented."
            }, n = 0, i = 1, s = function(t, e, r, s, h, u, l, c) {
                switch (t) {
                    case n:
                        return o(e, r, s, h, u, l, c);
                    case i:
                        return a(e, r, s, h, u, l, c)
                }
            }, r.make = s, r.linear = o, r.log = a
        }, {}]
    }, {}, [28]);